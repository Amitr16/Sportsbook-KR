<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kryzel Sports Betting Platform</title>
    
    <!-- Public betting page - no authentication required -->
    <script>
      (function() {
        // Tenant helper
        function tenant() {
          const seg = (location.pathname.split("/")[1] || "").trim();
          return seg && !["api","static","superadmin","login"].includes(seg) ? seg : "";
        }
        
        // Expose tenant globally for other snippets
        window.__TENANT__ = tenant();
        console.log("[PUBLIC] Public betting page loaded for tenant:", window.__TENANT__);
      })();
    </script>
    
    <!-- Dynamic Theme CSS -->
    <link rel="preload" as="style" href="" id="theme-css-preload" 
          onload="this.onload=null;document.getElementById('theme-css').href=this.href">
    <link id="theme-css" rel="stylesheet" type="text/css" href="">
    
    <!-- Anti-flicker styles -->
    <style id="anti-flicker">
        #mainApp {
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }
        
        #mainApp.visible {
            opacity: 1;
        }
        
        #mainApp.loading {
            opacity: 0.8;
        }
    </style>

    <script>
        // API base configuration with fallback
        const API_BASE = '';
        console.log('[CONFIG] API_BASE:', API_BASE);
        
        // Old theme loading functions removed - now handled by loadThemeCSSAndData()
        
        // Apply theme to page (using same logic as theme customizer)
        function applyThemeToPage(theme) {
            console.log('🎨 Applying theme to page:', theme);
            
            // Set CSS variables on document root (same as theme customizer)
            const cssVars = {
                '--primary-color': theme.primaryColor || '#22C55E',
                '--secondary-color': theme.secondaryColor || '#3b82f6',
                '--accent-color': theme.accentColor || '#22C55E',
                '--background-color': theme.backgroundColor || '#1A1A1A',
                '--text-color': theme.textColor || '#FFFFFF'
            };
            
            console.log('🎨 CSS variables to set:', cssVars);
            
            // Set on document root for global access (same as theme customizer)
            Object.entries(cssVars).forEach(([key, value]) => {
                document.documentElement.style.setProperty(key, value);
                console.log(`🎨 Set CSS variable ${key} = ${value}`);
            });
            
            console.log('✅ CSS variables set on document root');
            
            // Apply font family if available
            if (theme.fontFamily) {
                document.body.style.fontFamily = theme.fontFamily;
                console.log('🎨 Applied font family:', theme.fontFamily);
            }
            
            // Update logo text if available
            const logoText = document.querySelector('.logo-text');
            if (logoText && theme.sportsbookName) {
                logoText.textContent = theme.sportsbookName;
                console.log('🎨 Updated logo text to:', theme.sportsbookName);
            }
            
            // Update logo icon if available
            const logoIcon = document.querySelector('.logo-icon');
            if (logoIcon && theme.logoType && theme.logoType !== 'default') {
                const logoMap = {
                    'crown': '👑',
                    'trophy': '🏆',
                    'star': '⭐',
                    'diamond': '💎',
                    'fire': '🔥',
                    'lightning': '⚡',
                    'target': '🎯',
                    'default': '⚽'
                };
                logoIcon.textContent = logoMap[theme.logoType] || '⚽';
                console.log('🎨 Updated logo icon to:', logoMap[theme.logoType] || '⚽');
            }
            
            // Force a repaint to ensure changes are visible (same as theme customizer)
            document.body.style.display = 'none';
            document.body.offsetHeight; // Force reflow
            document.body.style.display = 'block';
            
            console.log('✅ Theme applied successfully to page');
            
            // Debug: Check if CSS variables are actually set
            console.log('🔍 Debug: Current CSS variables on document root:');
            console.log('--primary-color:', getComputedStyle(document.documentElement).getPropertyValue('--primary-color'));
            console.log('--background-color:', getComputedStyle(document.documentElement).getPropertyValue('--background-color'));
            console.log('--text-color:', getComputedStyle(document.documentElement).getPropertyValue('--text-color'));
        }
        
        // Unified loading function to prevent flickering
        let loadingComplete = false;
        let themeLoaded = false;
        let authLoaded = false;
        
        function checkLoadingComplete() {
            if (themeLoaded && authLoaded && !loadingComplete) {
                loadingComplete = true;
                hideLoadingScreen();
            }
        }
        
        function hideLoadingScreen() {
            const loadingScreen = document.getElementById('loadingScreen');
            const mainContent = document.getElementById('mainApp');
            
            if (loadingScreen && mainContent) {
                // Fade out loading screen
                loadingScreen.style.opacity = '0';
                loadingScreen.style.transition = 'opacity 0.3s ease-in-out';
                
                // Show main content
                mainContent.classList.add('loaded');
                
                // Remove loading screen after fade
                setTimeout(() => {
                    loadingScreen.remove();
                }, 300);
            }
        }
        
        // Load everything in parallel
        async function initializePage() {
            console.log('🚀 Starting parallel initialization...');
            
            // Load theme CSS and data in parallel
            const themePromise = loadThemeCSSAndData();
            
            // Wait for both theme and auth to complete
            await Promise.all([themePromise]);
            
            console.log('✅ Page initialization complete');
        }
        
        // Modified theme loading function
        async function loadThemeCSSAndData() {
            const path = window.location.pathname;
            const subdomain = path.split('/')[1];
            
            if (subdomain && subdomain !== 'static' && subdomain !== 'api') {
                const themeUrl = `/api/theme-css/${subdomain}`;
                const themeDataUrl = `/${subdomain}/api/public/load-theme`;
                
                console.log('[THEME] Loading CSS and data in parallel...');
                
                // Load both CSS and data in parallel
                const [cssResponse, dataResponse] = await Promise.allSettled([
                    fetch(themeUrl),
                    fetch(themeDataUrl)
                ]);
                
                // Apply CSS immediately
                const themeCssLink = document.getElementById('theme-css');
                const themeCssPreload = document.getElementById('theme-css-preload');
                if (themeCssPreload) themeCssPreload.href = themeUrl;
                if (themeCssLink) themeCssLink.href = themeUrl;
                
                // Apply theme data if available
                if (dataResponse.status === 'fulfilled' && dataResponse.value.ok) {
                    try {
                        const themeData = await dataResponse.value.json();
                        applyThemeToPage(themeData);
                    } catch (e) {
                        console.log('Theme data parsing failed, using CSS only');
                    }
                }
                
                console.log('[THEME] Theme loading complete');
            }
            
            themeLoaded = true;
            checkLoadingComplete();
        }
        
        // Start initialization immediately
        initializePage();
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        /* Loading screen to prevent flickering */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #1A1A1A;
            color: #FFFFFF;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        
        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top: 3px solid #22C55E;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .loading-text {
            font-size: 16px;
            font-weight: 500;
        }
        
        /* Hide main content until loaded */
        .main-content {
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }
        
        .main-content.loaded {
            opacity: 1;
        }

        body {
            font-family: var(--font-family, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif);
            background: var(--background-color, linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%));
            color: var(--text-color, #ffffff);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .header {
            background: var(--background-color, #2A2A2A);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding: 1rem 2rem;
            position: sticky;
            top: 0;
            z-index: 1000;
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 1400px;
            margin: 0 auto;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 1.5rem;
            font-weight: bold;
            color: #4ade80;
        }

        .logo-icon {
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, var(--primary-color, #4ade80), var(--secondary-color, #22c55e));
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
        }

        .search-container {
            flex: 1;
            max-width: 400px;
            margin: 0 2rem;
            position: relative;
        }

        .search-input {
            width: 100%;
            padding: 0.75rem 1rem 0.75rem 2.5rem;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 25px;
            color: var(--text-color, #ffffff);
            font-size: 0.9rem;
            outline: none;
            transition: all 0.3s ease;
        }

        .search-input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        .search-input:focus {
            background: rgba(255, 255, 255, 0.15);
            border-color: var(--primary-color, #4ade80);
            box-shadow: 0 0 0 3px rgba(74, 222, 128, 0.1);
        }

        .search-icon {
            position: absolute;
            left: 0.75rem;
            top: 50%;
            transform: translateY(-50%);
            color: rgba(255, 255, 255, 0.6);
            font-size: 1rem;
        }
        
        .search-clear {
            position: absolute;
            right: 0.75rem;
            top: 50%;
            transform: translateY(-50%);
            color: rgba(255, 255, 255, 0.6);
            font-size: 1rem;
            cursor: pointer;
            display: none;
            transition: all 0.3s ease;
        }
        
        .search-clear:hover {
            color: #ef4444;
        }
        
        .search-clear.visible {
            display: block;
        }

        .user-section {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        .loading-indicator {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            color: #4ade80;
            font-size: 1rem;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .balance {
            background: linear-gradient(135deg, var(--primary-color, #4ade80), var(--secondary-color, #22c55e));
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-weight: 600;
            font-size: 1rem;
        }

        .user-menu {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 0.5rem 1rem;
            color: var(--text-color, #ffffff);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .user-menu:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .google-signin-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            background: #fff;
            color: #333;
            border: 1px solid #dadce0;
            border-radius: 8px;
            padding: 8px 16px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .google-signin-btn:hover {
            background: #f8f9fa;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
            transform: translateY(-1px);
        }

        .google-signin-btn:active {
            transform: translateY(0);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .user-dropdown {
            position: absolute;
            top: 100%;
            right: 0;
            background: var(--background-color, rgba(26, 26, 46, 0.95));
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 0.5rem 0;
            margin-top: 0.5rem;
            min-width: 150px;
            z-index: 1000;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .dropdown-item {
            padding: 0.75rem 1rem;
            color: var(--text-color, #ffffff);
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }

        .dropdown-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .user-section {
            position: relative;
        }

        .main-container {
            display: flex;
            max-width: 1400px;
            margin: 0 auto;
            min-height: calc(100vh - 80px);
        }

        .sidebar {
            width: 280px;
            background: var(--background-color, #1A1A1A);
            backdrop-filter: blur(10px);
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            padding: 1.5rem;
            overflow-y: auto;
        }

        .sidebar-section {
            margin-bottom: 2rem;
        }

        .sidebar-title {
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 1rem;
        }

        .sport-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem 1rem;
            margin-bottom: 0.5rem;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .sport-item:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: var(--primary-color, #4ade80);
        }

        .sport-item.active {
            background: var(--primary-color, #22C55E);
            border-color: var(--primary-color, #22C55E);
            color: white;
        }

        .sport-info {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .sport-icon {
            font-size: 1.2rem;
        }

        .sport-name {
            font-weight: 500;
        }

        .event-count {
            background: rgba(255, 255, 255, 0.2);
            padding: 0.25rem 0.5rem;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .sport-item.active .event-count {
            background: rgba(0, 0, 0, 0.2);
            color: #000;
        }

        /* Hide rugby sports using CSS */
        .sport-item[onclick*="rugby"],
        .sport-item[onclick*="rugbyleague"] {
            display: none !important;
        }

        .filter-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem 1rem;
            margin-bottom: 0.5rem;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .filter-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .filter-info {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .filter-icon {
            font-size: 1rem;
        }

        .content-area {
            flex: 1;
            padding: 1.5rem;
            background: var(--background-color, #2A2A2A);
        }

        .breadcrumb {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1rem;
            font-size: 0.9rem;
            color: var(--text-color, rgba(255, 255, 255, 0.7));
        }



        .breadcrumb-separator {
            color: rgba(255, 255, 255, 0.4);
        }

        .content-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }
        
        .live-status {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        .status-indicator {
            font-size: 0.9rem;
            font-weight: 600;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .status-indicator.connected {
            background: rgba(34, 197, 94, 0.2);
            border-color: var(--primary-color, #22C55E);
            color: var(--primary-color, #22C55E);
        }
        
        .status-indicator.disconnected {
            background: rgba(239, 68, 68, 0.2);
            border-color: #ef4444;
            color: #ef4444;
        }
        
        .refresh-btn {
            padding: 0.5rem 1rem;
            background: var(--primary-color, #22C55E);
            border: none;
            border-radius: 6px;
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }
        
        .refresh-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(74, 222, 128, 0.3);
        }
        
        /* Animations for bet slip updates */
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(74, 222, 128, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(74, 222, 128, 0); }
            100% { box-shadow: 0 0 0 0 rgba(74, 222, 128, 0); }
        }
        
        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        @keyframes slideOut {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(100%); opacity: 0; }
        }

        .view-options {
            display: flex;
            gap: 0.5rem;
        }

        .view-btn {
            padding: 0.5rem 1rem;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: #ffffff;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }

        .view-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .view-btn.active {
            background: var(--primary-color, #22C55E);
            border-color: var(--primary-color, #22C55E);
        }

        .bet-slip {
            width: 320px;
            background: var(--background-color, #1A1A1A);
            backdrop-filter: blur(10px);
            border-left: 1px solid rgba(255, 255, 255, 0.1);
            padding: 1.5rem;
            overflow-y: auto;
        }

        .bet-slip-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 1.5rem;
            padding: 1.25rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }
        
        .bet-slip-title {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-color, #ffffff);
        }

        .bet-count {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: white;
            padding: 0.25rem 0.6rem;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
            min-width: 20px;
            text-align: center;
            box-shadow: 0 2px 4px rgba(239, 68, 68, 0.3);
        }

        .bet-slip-controls {
            display: flex;
            align-items: center;
            gap: 1.25rem;
        }

        /* Modern Slider Toggle */
        .slider-toggle {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 30px;
            background: linear-gradient(135deg, #3b82f6, #2563eb);
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border: 1px solid #3b82f6;
        }

        .slider-toggle:hover {
            background: linear-gradient(135deg, #2563eb, #1d4ed8);
            transform: scale(1.05);
        }

        .slider-toggle.active {
            background: linear-gradient(135deg, #4ade80, #22c55e);
            border-color: #4ade80;
            box-shadow: 0 0 0 3px rgba(74, 222, 128, 0.1);
        }

        .slider-toggle.active:hover {
            background: linear-gradient(135deg, #22c55e, #16a34a);
            transform: scale(1.05);
        }

        .slider-toggle .slider-thumb {
            position: absolute;
            top: 2px;
            left: 2px;
            width: 26px;
            height: 26px;
            background: white;
            border-radius: 50%;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .slider-toggle.active .slider-thumb {
            transform: translateX(30px);
        }

        .slider-toggle .slider-label {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            font-size: 0.75rem;
            font-weight: 600;
            pointer-events: none;
            transition: all 0.3s ease;
        }

        .slider-toggle:not(.active) .slider-label {
            right: 8px;
            color: #000;
            font-weight: 700;
            text-shadow: none;
        }

        .slider-toggle.active .slider-label {
            left: 8px;
            color: #000;
            font-weight: 700;
            text-shadow: none;
        }

        .live-indicator {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            font-size: 0.75rem;
            font-weight: 600;
            color: #ef4444;
            animation: pulse 2s infinite;
        }

        .bet-slip-content {
            text-align: center;
            color: rgba(255, 255, 255, 0.6);
            padding: 2rem 0;
        }

        .login-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .login-modal {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 16px;
            padding: 2rem;
            width: 100%;
            max-width: 400px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }

        .login-title {
            text-align: center;
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 1.5rem;
            color: #4ade80;
        }

        .form-group {
            margin-bottom: 1rem;
        }

        .form-label {
            display: block;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
            font-weight: 500;
            color: rgba(255, 255, 255, 0.8);
        }

        .form-input {
            width: 100%;
            padding: 0.75rem;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: #ffffff;
            font-size: 1rem;
            outline: none;
            transition: all 0.3s ease;
        }

        .form-input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .form-input:focus {
            background: rgba(255, 255, 255, 0.15);
            border-color: #4ade80;
            box-shadow: 0 0 0 3px rgba(74, 222, 128, 0.1);
        }

        .login-btn {
            width: 100%;
            padding: 0.75rem;
            background: linear-gradient(135deg, #4ade80, #22c55e);
            border: none;
            border-radius: 8px;
            color: #000;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 1rem;
        }

        .login-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 10px 30px rgba(74, 222, 128, 0.3);
        }

        .login-footer {
            text-align: center;
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.9rem;
        }

        .login-footer a {
            color: #4ade80;
            text-decoration: none;
            font-weight: 500;
        }

        .login-footer a:hover {
            text-decoration: underline;
        }

        .loading-text {
            text-align: center;
            color: rgba(255, 255, 255, 0.6);
            padding: 2rem;
            font-size: 1.1rem;
        }

        .load-more-btn {
            display: block;
            width: 100%;
            padding: 1rem;
            margin: 1rem 0;
            background: linear-gradient(135deg, #4ade80, #22c55e);
            color: #000;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .load-more-btn:hover {
            background: linear-gradient(135deg, #22c55e, #16a34a);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(34, 197, 94, 0.3);
        }

        .events-table {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            overflow: hidden;
        }

        .market-tabs {
            display: flex;
            background: rgba(255, 255, 255, 0.05);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .market-tab {
            flex: 1;
            padding: 1rem;
            text-align: center;
            background: transparent;
            border: none;
            color: rgba(255, 255, 255, 0.7);
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
            font-weight: 500;
        }

        .market-tab:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
        }

        .market-tab.active {
            background: #3b82f6;
            color: #ffffff;
        }

        .no-markets-message {
            color: #fbbf24;
            text-align: center;
            padding: 1rem;
            font-style: italic;
            background: rgba(251, 191, 36, 0.1);
            border-radius: 8px;
            border: 1px solid rgba(251, 191, 36, 0.3);
        }

        .table-header {
            display: grid;
            gap: 1rem;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.05);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            font-weight: 600;
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.8);
        }

        .event-row {
            display: grid;
            gap: 1rem;
            padding: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            transition: all 0.3s ease;
            align-items: center;
        }

        .live-match {
            background: rgba(239, 68, 68, 0.1);
            border-left: 3px solid #ef4444;
        }

        .live-indicator {
            color: #ef4444;
            font-weight: bold;
            font-size: 0.8rem;
            margin-left: 0.5rem;
        }

        .live-score {
            color: #fbbf24;
            font-weight: bold;
            margin-left: 0.5rem;
            white-space: nowrap;
            display: inline-block;
        }

        .event-row:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .event-time {
            font-weight: 600;
            color: #fbbf24;
            font-size: 0.9rem;
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .match-status {
            font-size: 0.8rem;
            color: #4ade80;
            font-weight: 500;
        }

        .event-info {
            display: flex;
            flex-direction: column;
        }

        .event-teams {
            font-weight: 600;
            margin-bottom: 0.25rem;
        }

        .event-league {
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.6);
        }

        .odds-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            padding: 0.5rem;
            color: #ffffff;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            text-align: center;
        }

        .odds-btn:hover {
            background: #4ade80;
            border-color: #4ade80;
            color: #000;
            transform: translateY(-1px);
        }

        .odds-btn.selected {
            background: #4ade80;
            border-color: #4ade80;
            color: #000;
        }
        
        /* Coupon view specific odds button styling */
        .coupon-view .odds-btn {
            min-width: 80px;
            height: 60px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            margin: 0.25rem;
        }
        
        .coupon-view .odds-btn div:first-child {
            font-size: 1.2rem;
            font-weight: 700;
        }

        .live-odds-container {
            margin-top: 2rem;
            padding: 1.5rem;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            overflow-y: auto;
            max-height: 300px; /* Adjust as needed */
        }

        .live-odds-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .live-odds-header h3 {
            color: #4ade80;
            font-size: 1.1rem;
            font-weight: 600;
        }

        .live-odds-timer {
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.6);
        }

        .live-odds-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 1rem;
        }

        .live-odds-card {
            background: var(--background-color, rgba(26, 26, 46, 0.8));
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 1.25rem;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .live-odds-card:hover {
            background: rgba(255, 255, 255, 0.05);
            border-color: #4ade80;
        }

        .match-header {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .bet-slip-title {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-color, #ffffff);
        }

        .match-teams {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-color, #ffffff);
        }

        .vs {
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.9rem;
        }

        .live-score {
            font-size: 1.5rem;
            font-weight: bold;
            color: #fbbf24;
        }

        .match-status {
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.6);
        }

        .odds-markets {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .market-section h4 {
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 0.5rem;
        }

        .odds-row {
            display: flex;
            justify-content: space-around;
            gap: 1rem;
            font-size: 0.9rem;
            color: var(--text-color, #ffffff);
        }

        .odds-row .selection {
            font-weight: 500;
            color: var(--text-color, rgba(255, 255, 255, 0.8));
        }

        .odds-row .odds {
            font-weight: 600;
            color: #4ade80;
        }

        .match-progress {
            margin-top: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.6);
        }

        .progress-bar {
            flex: 1;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(135deg, #4ade80, #22c55e);
            border-radius: 4px;
            transition: width 0.3s ease-in-out;
        }

        .no-live-odds {
            text-align: center;
            color: rgba(255, 255, 255, 0.7);
            padding: 2rem;
        }

        @media (max-width: 1024px) {
            .main-container {
                flex-direction: column;
            }
            
            .sidebar {
                width: 100%;
                order: 2;
            }
            
            .content-area {
                order: 1;
            }
            
            .bet-slip {
                width: 100%;
                order: 3;
            }
            
            .header-content {
                flex-direction: column;
            gap: 1rem;
            }
            
            .search-container {
                margin: 0;
                max-width: 100%;
            }
        }

        @media (max-width: 768px) {
            .header {
                padding: 1rem;
            }
            
            .sidebar, .content-area, .bet-slip {
            padding: 1rem;
        }

            .table-header, .event-row {
                grid-template-columns: 80px 1fr 80px 80px 80px;
                gap: 0.5rem;
                padding: 0.75rem;
                font-size: 0.8rem;
            }
        }

        /* Custom Fancy Alert Styles */
        .custom-alert-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(8px);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            animation: fadeIn 0.3s ease-out;
        }

        .custom-alert {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border: 2px solid rgba(0, 255, 255, 0.3);
            border-radius: 20px;
            padding: 2rem;
            max-width: 400px;
            width: 90%;
            text-align: center;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
            position: relative;
            overflow: hidden;
            animation: slideIn 0.4s ease-out;
        }

        .custom-alert::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, #00ffff, #00ff88, #00ffff);
            animation: shimmer 2s infinite;
        }

        .custom-alert.success::before {
            background: linear-gradient(90deg, #00ff88, #00ffff, #00ff88);
        }

        .custom-alert.error::before {
            background: linear-gradient(90deg, #ff4444, #ff8844, #ff4444);
        }

        .custom-alert.warning::before {
            background: linear-gradient(90deg, #ffaa00, #ffff00, #ffaa00);
        }

        .custom-alert-icon {
            font-size: 4rem;
            margin-bottom: 1rem;
            animation: bounceIn 0.6s ease-out;
        }

        .custom-alert-title {
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 1rem;
            color: #ffffff;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        .custom-alert-message {
            font-size: 1.1rem;
            color: #b8c5d6;
            margin-bottom: 2rem;
            line-height: 1.5;
        }

        .custom-alert-button {
            background: linear-gradient(135deg, #00ffff 0%, #00ff88 100%);
            border: none;
            color: #1a1a2e;
            padding: 12px 32px;
            border-radius: 25px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 255, 255, 0.3);
        }

        .custom-alert-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 255, 255, 0.4);
        }

        .custom-alert-button:active {
            transform: translateY(0);
        }

        .custom-alert.success .custom-alert-button {
            background: linear-gradient(135deg, #00ff88 0%, #00ffff 100%);
            box-shadow: 0 4px 15px rgba(0, 255, 136, 0.3);
        }

        .custom-alert.success .custom-alert-button:hover {
            box-shadow: 0 6px 20px rgba(0, 255, 136, 0.4);
        }

        .custom-alert.error .custom-alert-button {
            background: linear-gradient(135deg, #ff4444 0%, #ff8844 100%);
            box-shadow: 0 4px 15px rgba(255, 68, 68, 0.3);
        }

        .custom-alert.error .custom-alert-button:hover {
            box-shadow: 0 6px 20px rgba(255, 68, 68, 0.4);
        }

        .custom-alert.warning .custom-alert-button {
            background: linear-gradient(135deg, #ffaa00 0%, #ffff00 100%);
            box-shadow: 0 4px 15px rgba(255, 170, 0, 0.3);
        }

        .custom-alert.warning .custom-alert-button:hover {
            box-shadow: 0 6px 20px rgba(255, 170, 0, 0.4);
        }

        /* Animations */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideIn {
            from { 
                opacity: 0;
                transform: translateY(-50px) scale(0.9);
            }
            to { 
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        @keyframes bounceIn {
            0% { 
                opacity: 0;
                transform: scale(0.3);
            }
            50% { 
                opacity: 1;
                transform: scale(1.05);
            }
            70% { 
                transform: scale(0.9);
            }
            100% { 
                opacity: 1;
                transform: scale(1);
            }
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        /* Responsive */
        @media (max-width: 480px) {
            .custom-alert {
                padding: 1.5rem;
                margin: 1rem;
            }
            
            .custom-alert-icon {
                font-size: 3rem;
            }
            
            .custom-alert-title {
                font-size: 1.3rem;
            }
            
            .custom-alert-message {
                font-size: 1rem;
            }
        }
    </style>
</head>
<body>
    <!-- Loading screen to prevent flickering -->
    <div id="loadingScreen" class="loading-screen">
        <div class="loading-spinner"></div>
        <div class="loading-text">Loading Sportsbook...</div>
    </div>
    
    <!-- Custom Fancy Alert Component -->
    <div class="custom-alert-overlay" id="customAlertOverlay">
        <div class="custom-alert" id="customAlert">
            <div class="custom-alert-icon" id="customAlertIcon">🎯</div>
            <div class="custom-alert-title" id="customAlertTitle">Alert</div>
            <div class="custom-alert-message" id="customAlertMessage">This is a custom alert message.</div>
            <button class="custom-alert-button" id="customAlertButton" onclick="hideCustomAlert()">OK</button>
        </div>
    </div>

    <!-- Tenant + redirect helpers - must be defined BEFORE any auth code -->
    <script>
      // --- tenant + redirect helpers ---
      function getTenant() {
        // Use global tenant if available, otherwise parse from path
        return window.__TENANT__ || (() => {
          const seg = (location.pathname.split("/")[1] || "").trim();
          return seg && !["api","static","superadmin","login"].includes(seg) ? seg : "";
        })();
      }
      function redirectToTenantLogin() {
        const t = getTenant();
        // avoid duplicate redirects
        if (window.__redirecting) return;
        window.__redirecting = true;
        window.location.href = t ? `/${t}/login` : `/login`;
      }
      // normalize legacy hooks
      window.showLogin = redirectToTenantLogin;
      window.showRegister = redirectToTenantLogin;
    </script>

    <!-- Authentication check - runs immediately when page loads -->
    <script>
      let bootstrapAuthInProgress = false;
      
      (async function bootstrapAuth() {
        if (bootstrapAuthInProgress) {
          console.log('🚫 bootstrapAuth already in progress, skipping...');
          return;
        }
        
        // Check if we just came back from OAuth callback
        const urlParams = new URLSearchParams(window.location.search);
        const fromOAuth = urlParams.get('code') || urlParams.get('state');
        
        // Post-login race guard (prevents split-second 401 → redirect loop on slower disks)
        if (sessionStorage.getItem('justLoggedIn') || fromOAuth) {
          console.log('⏳ Just logged in or returned from OAuth, giving cookie a beat to settle...');
          await new Promise(r => setTimeout(r, 500)); // Increased delay for OAuth
          sessionStorage.removeItem('justLoggedIn');
          
          // Clean URL parameters if we came from OAuth
          if (fromOAuth) {
            const cleanUrl = window.location.pathname;
            window.history.replaceState({}, document.title, cleanUrl);
            console.log('🧹 Cleaned OAuth parameters from URL');
          }
        }
        
        bootstrapAuthInProgress = true;
        
        const meUrl = '/api/auth/me'; // session cookie based

        try {
          const me = await fetch(meUrl, {
            method: 'GET',
            credentials: 'include',
            cache: 'no-store',
            headers: { 'Accept': 'application/json' }
          });

          // Check content-type before trusting a 200 response
          const ctype = (me.headers.get('content-type') || '').toLowerCase();
          if (!ctype.includes('application/json')) {
            // It's likely an HTML redirect page; treat as unauth
            console.warn('🚨 Non-JSON response received, treating as unauthorized');
            showPublicMode();
            return;
          }

          if (me.status === 200) {
            // Auth OK — set global flag and lock redirects
            window.__AUTH_OK = true;
            
            // Hydrate UI and show app
            const data = await me.json().catch(() => ({}));
            window.AUTH = data;

            // Show authenticated user UI
            showAuthenticatedMode(data);
            
            // Initialize the app after successful authentication
            if (typeof initializeAppAfterLogin === 'function') {
              console.log('🚀 Initializing app after successful auth...');
              await initializeAppAfterLogin();
            } else {
              console.warn('⚠️ initializeAppAfterLogin function not found');
            }
            
            return; // ✅ stay on the page
          }

          if (me.status === 401 || me.status === 403) {
            // User not authenticated - show public mode
            console.log('🔓 User not authenticated, showing public mode');
            showPublicMode();
            return;
          }

          console.warn("[auth] unexpected status", me.status);
          // Show public mode on other errors
          showPublicMode();
        } catch (err) {
          console.warn("[auth] probe failed:", err);
          // Show public mode on network errors
          showPublicMode();
        } finally {
          bootstrapAuthInProgress = false;
          authLoaded = true;
          checkLoadingComplete();
        }
      })();

      // Function to show authenticated user mode
      function showAuthenticatedMode(userData) {
        console.log('✅ Showing authenticated mode for user:', userData);
        
        // Hide non-authenticated UI
        const nonAuthUser = document.getElementById('nonAuthenticatedUser');
        if (nonAuthUser) {
          nonAuthUser.style.display = 'none';
        }
        
        // Show authenticated UI
        const authUser = document.getElementById('authenticatedUser');
        if (authUser) {
          authUser.style.display = 'flex';
        }

        // Update user menu if present
        const userMenu = document.getElementById('userMenu');
        if (userMenu && (userData.username || userData.email)) {
          userMenu.textContent = `${userData.username || userData.email} ▼`;
        }

        // Update balance immediately after login
        const balanceElement = document.getElementById('userBalance');
        if (balanceElement && userData.balance !== undefined) {
          balanceElement.textContent = `$${parseFloat(userData.balance).toFixed(2)}`;
          console.log('✅ Balance updated immediately after login:', userData.balance);
        }

        // Unhide main app container
        const root = document.getElementById('mainApp');
        if (root) root.style.display = 'block';

        // Start periodic refreshes
        if (typeof startBalanceAutoRefresh === 'function') {
          startBalanceAutoRefresh();
        }
        
        // Show bet history in sidebar for authenticated users
        const betHistoryItems = document.querySelectorAll('.filter-item');
        betHistoryItems.forEach(item => {
            if (item.textContent.includes('Bet History')) {
                item.style.display = 'block';
            }
        });
      }

      // Function to show public (non-authenticated) mode
      function showPublicMode() {
        console.log('🔓 Showing public mode - user not authenticated');
        
        // Hide authenticated UI
        const authUser = document.getElementById('authenticatedUser');
        if (authUser) {
          authUser.style.display = 'none';
        }
        
        // Show non-authenticated UI
        const nonAuthUser = document.getElementById('nonAuthenticatedUser');
        if (nonAuthUser) {
          nonAuthUser.style.display = 'block';
        }

        // Unhide main app container (but with limited functionality)
        const root = document.getElementById('mainApp');
        if (root) root.style.display = 'block';

        // Initialize public app (view-only mode)
        if (typeof initializePublicApp === 'function') {
          console.log('🚀 Initializing public app...');
          initializePublicApp();
        } else {
          console.warn('⚠️ initializePublicApp function not found');
        }
      }

      // Google Sign-In function
      function initiateGoogleSignIn() {
        console.log('🔐 Initiating Google sign-in...');
        // Use dynamic redirect URI that works for both localhost and production
        const redirectUrl = location.origin + '/auth/google/callback';
        const tenant = getTenant();
        const tenantParam = tenant ? `&tenant=${encodeURIComponent(tenant)}` : '';
        window.location.href = `/auth/google/login?redirect_uri=${encodeURIComponent(redirectUrl)}${tenantParam}`;
      }
      
      // CONSOLIDATED INITIALIZATION: Single entry point to prevent refresh loops
      let isInitialized = false;
      let initializationInProgress = false;
      

      
      // Atomic table swapping to prevent empty table flashing
      function swapTableAtomically(renderFn) {
        const eventsRoot = document.getElementById('eventsContent');
        if (!eventsRoot) return;
        
        const buffer = document.createElement('div');
        buffer.style.position = 'absolute';
        buffer.style.left = '-99999px'; // off-screen
        buffer.style.top = '0';
        document.body.appendChild(buffer);

        try {
          // Render the new content into buffer
          renderFn(buffer);

                              // Detect if this render produced meaningful content
                    // Look for either table rows OR event rows OR coupon view (since we use div-based grid layout)
                    const newTable = buffer.querySelector('table');
                    const newEventRows = buffer.querySelectorAll('.event-row');
                    const newCouponView = buffer.querySelector('.coupon-view');
                    const newRows = newTable ? newTable.tBodies?.[0]?.rows?.length || 0 : 
                                   newCouponView ? 1 : newEventRows.length;

                              console.log(`🔍 swapTableAtomically: Found ${newRows} rows (table: ${newTable ? 'yes' : 'no'}, event-rows: ${newEventRows.length}, coupon-view: ${newCouponView ? 'yes' : 'no'})`);

          if (newRows > 0) {
            // Atomic swap in next frame (prevents paint thrash)
            requestAnimationFrame(() => {
              // Clear existing content
              eventsRoot.innerHTML = '';
              
              // Move all content from buffer to live container
              while (buffer.firstChild) {
                eventsRoot.appendChild(buffer.firstChild);
              }
              

              console.log('🔄 Atomic content swap: Replaced with', newRows, 'rows');
            });
          } else {
            // No rows yet → skip swap (keeps previous visible; avoids empty flash)
            console.log('⏸️ Skipping content swap: No rows to display');
          }
        } finally {
          buffer.remove(); // clean up
        }
      }
      
      // Single DOMContentLoaded event listener to prevent conflicts
      document.addEventListener('DOMContentLoaded', async function() {
          // Initialize mainApp state to prevent flickering
          const mainApp = document.getElementById('mainApp');
          if (mainApp) {
              mainApp.classList.remove('visible', 'loading');
          }
          
          if (isInitialized || initializationInProgress) {
              console.log('🚫 Initialization already in progress or completed, skipping...');
              return;
          }
          
          // Don't start initialization here - let the unified loading system handle it
          console.log('📄 DOM ready, waiting for unified loading system...');
          
          initializationInProgress = true;
          console.log('🚀 CONSOLIDATED INITIALIZATION: Starting single initialization sequence...');
          
          try {
              // If we're already authenticated, start loading immediately
              if (window.__AUTH_OK) {
                  console.log('✅ Already authenticated, starting immediate initialization...');
                  await initializeAppAfterLogin();
              } else {
                  console.log('⏳ Not authenticated yet, waiting for bootstrapAuth...');
              }
              
              isInitialized = true;
              console.log('✅ CONSOLIDATED INITIALIZATION: Completed successfully');
              
          } catch (error) {
              console.error('❌ CONSOLIDATED INITIALIZATION: Failed:', error);
          } finally {
              initializationInProgress = false;
          }
      });
      
      // Single initialization function to prevent multiple calls
      async function initializeAppAfterLogin() {
          if (window.appInitialized) {
              console.log('🚫 App already initialized, skipping...');
              return;
          }
          
          console.log('🚀 Initializing app after login...');
          
          // Show the main app with smooth transition
          const mainApp = document.getElementById('mainApp');
          if (mainApp) {
              mainApp.classList.add('loading');
              // Use requestAnimationFrame to ensure smooth transition
              requestAnimationFrame(() => {
                  mainApp.classList.add('visible');
                  // Remove loading state after transition
                  setTimeout(() => {
                      mainApp.classList.remove('loading');
                  }, 300);
              });
          }
          

          
          // Start loading sports data immediately
          if (typeof loadSports === 'function') {
              console.log('🚀 Starting immediate sports loading...');
              await loadSports();
          }
          
          // Initialize other components
          if (typeof updateBettingMarkets === 'function') {
              updateBettingMarkets();
          }
          if (typeof updateBetModeDisplay === 'function') {
              updateBetModeDisplay();
          }
          
          // Start balance auto-refresh (only this one)
          if (typeof startBalanceAutoRefresh === 'function') {
              startBalanceAutoRefresh();
          }
          
          // Refresh balance immediately for already authenticated users
          if (typeof refreshUserBalance === 'function') {
              console.log('🔄 Refreshing balance immediately for authenticated user...');
              refreshUserBalance();
          }
          
          // Initialize WebSocket connection
          if (typeof initWebSocket === 'function') {
              console.log('🔌 Initializing WebSocket connection...');
              initWebSocket();
          }
          
          // Initialize live odds update system (only this one, not multiple)
          if (typeof initializeLiveOddsSystem === 'function') {
              console.log('🎯 Initializing Live Odds Update System...');
              initializeLiveOddsSystem();
          }
          
          // Periodic odds update checker will be started AFTER preloading completes
          console.log('⏳ Periodic odds update checker will start after preloading...');
          
          // Mark as initialized to prevent duplicate calls
          window.appInitialized = true;
          console.log('✅ App initialization completed');
        }

        // Public app initialization (for non-authenticated users)
        async function initializePublicApp() {
          if (window.publicAppInitialized) {
              console.log('🚫 Public app already initialized, skipping...');
              return;
          }
          
          console.log('🚀 Initializing public app (view-only mode)...');
          
          // Show the main app with smooth transition
          const mainApp = document.getElementById('mainApp');
          if (mainApp) {
              mainApp.classList.add('loading');
              // Use requestAnimationFrame to ensure smooth transition
              requestAnimationFrame(() => {
                  mainApp.classList.add('visible');
                  // Remove loading state after transition
                  setTimeout(() => {
                      mainApp.classList.remove('loading');
                  }, 300);
              });
          }
          
          // Start loading sports data immediately (view-only)
          if (typeof loadSports === 'function') {
              console.log('🚀 Starting immediate sports loading (public mode)...');
              await loadSports();
          }
          
          // Initialize other components (view-only)
          if (typeof updateBettingMarkets === 'function') {
              updateBettingMarkets();
          }
          if (typeof updateBetModeDisplay === 'function') {
              updateBetModeDisplay();
          }
          
          // Initialize WebSocket connection (view-only)
          if (typeof initWebSocket === 'function') {
              console.log('🔌 Initializing WebSocket connection (public mode)...');
              initWebSocket();
          }
          
          // Initialize live odds update system (view-only)
          if (typeof initializeLiveOddsSystem === 'function') {
              console.log('🎯 Initializing Live Odds Update System (public mode)...');
              initializeLiveOddsSystem();
          }
          
          // Disable betting functionality for public users
          disableBettingForPublicUsers();
          
          // Mark as initialized to prevent duplicate calls
          window.publicAppInitialized = true;
          console.log('✅ Public app initialization completed');
        }

        // Function to disable betting functionality for public users
        function disableBettingForPublicUsers() {
          console.log('🔒 Disabling betting functionality for public users...');
          
          // Disable all bet buttons
          const betButtons = document.querySelectorAll('.bet-button, .odds-button, [onclick*="addToBetSlip"]');
          betButtons.forEach(button => {
              button.disabled = true;
              button.style.opacity = '0.5';
              button.style.cursor = 'not-allowed';
              button.title = 'Sign in to place bets';
          });
          
          // Disable bet slip functionality
          const betSlip = document.querySelector('.bet-slip');
          if (betSlip) {
              betSlip.style.opacity = '0.5';
              betSlip.style.pointerEvents = 'none';
          }
          
          // Hide bet history in sidebar for public users
          const betHistoryItems = document.querySelectorAll('.filter-item');
          betHistoryItems.forEach(item => {
              if (item.textContent.includes('Bet History')) {
                  item.style.display = 'none';
              }
          });
          
          // Add overlay to bet slip with sign-in message
          const betSlipHeader = document.querySelector('.bet-slip-header');
          if (betSlipHeader) {
              const signInOverlay = document.createElement('div');
              signInOverlay.style.cssText = `
                  position: absolute;
                  top: 0;
                  left: 0;
                  right: 0;
                  bottom: 0;
                  background: rgba(0, 0, 0, 0.8);
                  color: white;
                  display: flex;
                  align-items: center;
                  justify-content: center;
                  text-align: center;
                  font-size: 14px;
                  z-index: 10;
                  border-radius: 8px;
              `;
              signInOverlay.innerHTML = '🔐 Sign in with Google to place bets';
              betSlipHeader.style.position = 'relative';
              betSlipHeader.appendChild(signInOverlay);
          }
          
          console.log('✅ Betting functionality disabled for public users');
        }
    </script>

    <!-- Balance Refresh Function -->
    <script>
        // Function to refresh user balance (can be called after bet settlement)
        async function refreshUserBalance() {
            const url = '/api/auth/me';
            console.log('[BAL] fetching', url);
            try {
                const response = await fetch(url, {
                    credentials: 'include',
                    cache: 'no-store',           // avoid cached value
                    headers: { 'Accept': 'application/json' }
                });
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                    const userData = await response.json();
                updateBalanceUI(userData.balance);
                console.log('[BAL] updated →', userData.balance);
            } catch (e) {
                console.error('[BAL] refresh failed:', e);
            }
        }

        // Robust balance UI update function
        function updateBalanceUI(v) {
            const n = Number(v);
            if (!Number.isFinite(n)) return console.warn('[BAL] bad value', v);
            
                    const balanceElement = document.getElementById('userBalance');
                    if (balanceElement) {
                balanceElement.textContent = `$${n.toFixed(2)}`;
                console.log('[BAL] UI updated →', n);
                    } else {
                console.warn('[BAL] balance element not found');
            }
        }

        // Auto-refresh balance with proper lifecycle management
        let balTimer;
        let balanceAutoRefreshStarted = false;
        
        function startBalanceAutoRefresh() {
            if (balTimer || balanceAutoRefreshStarted) {
                console.log('[BAL] auto-refresh already started, skipping...');
                return;
            }
            
            balTimer = setInterval(refreshUserBalance, 120000); // Every 2 minutes
            balanceAutoRefreshStarted = true;
            console.log('[BAL] auto-refresh started (every 2 minutes)');
            
            // Re-run on visibility change and page focus
            window.addEventListener('visibilitychange', () => { 
                if (!document.hidden) refreshUserBalance(); 
            });
            
            // Also refresh after any bet placement
            document.addEventListener('bet:placed', refreshUserBalance);
            document.addEventListener('bet:settled', refreshUserBalance);
        }
        
        function stopBalanceAutoRefresh() {
            if (balTimer) {
                clearInterval(balTimer);
                balTimer = null;
                console.log('[BAL] auto-refresh stopped');
            }
        }

        // Make functions globally accessible for WebSocket handlers
        window.refreshUserBalance = refreshUserBalance;
        window.updateBalanceUI = updateBalanceUI;
        window.startBalanceAutoRefresh = startBalanceAutoRefresh;
        window.stopBalanceAutoRefresh = stopBalanceAutoRefresh;
    </script>

    <!-- Custom Alert JavaScript Functions -->
    <script>
        // Custom Alert System
        function showCustomAlert(type, title, message, duration = 0) {
            const overlay = document.getElementById('customAlertOverlay');
            const alert = document.getElementById('customAlert');
            const icon = document.getElementById('customAlertIcon');
            const titleEl = document.getElementById('customAlertTitle');
            const messageEl = document.getElementById('customAlertMessage');
            const button = document.getElementById('customAlertButton');
            
            // Set alert type and styling
            alert.className = `custom-alert ${type}`;
            
            // Set icon based on type
            const iconMap = {
                'success': '✅',
                'error': '❌',
                'warning': '⚠️',
                'info': 'ℹ️'
            };
            icon.textContent = iconMap[type] || '🎯';
            
            // Set content
            titleEl.textContent = title;
            messageEl.textContent = message;
            
            // Show overlay
            overlay.style.display = 'flex';
            
            // Auto-hide if duration is set
            if (duration > 0) {
                setTimeout(() => {
                    hideCustomAlert();
                }, duration);
            }
        }
        
        function hideCustomAlert() {
            const overlay = document.getElementById('customAlertOverlay');
            overlay.style.display = 'none';
        }
        
        // Convenience functions for different alert types
        function showSuccessAlert(title, message, duration = 0) {
            showCustomAlert('success', title, message, duration);
        }
        
        function showErrorAlert(title, message, duration = 0) {
            showCustomAlert('error', title, message, duration);
        }
        
        function showWarningAlert(title, message, duration = 0) {
            showCustomAlert('warning', title, message, duration);
        }
        
        function showInfoAlert(title, message, duration = 0) {
            showCustomAlert('info', title, message, duration);
        }
        
        // Custom Confirm Dialog
        function showCustomConfirm(title, message, onConfirm, onCancel) {
            const overlay = document.getElementById('customAlertOverlay');
            const alert = document.getElementById('customAlert');
            const icon = document.getElementById('customAlertIcon');
            const titleEl = document.getElementById('customAlertTitle');
            const messageEl = document.getElementById('customAlertMessage');
            const button = document.getElementById('customAlertButton');
            
            // Set alert type and styling
            alert.className = 'custom-alert warning';
            icon.textContent = '❓';
            
            // Set content
            titleEl.textContent = title;
            messageEl.textContent = message;
            button.textContent = 'Confirm';
            
            // Show overlay
            overlay.style.display = 'flex';
            
            // Handle button click
            button.onclick = function() {
                hideCustomAlert();
                if (onConfirm) onConfirm();
            };
            
            // Handle cancel (clicking outside or escape key)
            const handleCancel = function() {
                hideCustomAlert();
                if (onCancel) onCancel();
            };
            
            overlay.onclick = function(e) {
                if (e.target === overlay) {
                    handleCancel();
                }
            };
            
            // Escape key to cancel
            const escapeHandler = function(e) {
                if (e.key === 'Escape') {
                    document.removeEventListener('keydown', escapeHandler);
                    handleCancel();
                }
            };
            document.addEventListener('keydown', escapeHandler);
        }
        
        // Close alert when clicking outside
        document.addEventListener('DOMContentLoaded', function() {
            const overlay = document.getElementById('customAlertOverlay');
            overlay.addEventListener('click', function(e) {
                if (e.target === overlay) {
                    hideCustomAlert();
                }
            });
        });
    </script>

    <!-- Main Application -->
                <div id="mainApp" class="main-content">
    <!-- Header -->
        <header class="header">
            <div class="header-content">
            <div class="logo">
                <span class="logo-icon">⚽</span>
                <span class="logo-text">Kryzel</span>
                </div>
                <div class="search-container">
                    <div class="search-icon">🔍</div>
                <input type="text" class="search-input" placeholder="Search teams, leagues, or events..." onkeyup="handleSearch(this.value)" oninput="toggleClearButton(this)">
                    <div class="search-clear" onclick="clearSearch()">✕</div>
            </div>
            <div class="user-section">
                    <div id="loadingIndicator" class="loading-indicator" style="display: none;">
                        <i class="fas fa-spinner fa-spin"></i>
                    </div>
                    <!-- Authenticated user section -->
                    <div id="authenticatedUser" style="display: none;">
                        <div class="balance" id="userBalance">$1000.00</div>
                        <div class="user-menu" id="userMenu" onclick="toggleUserMenu()">Loading... ▼</div>
                        <div class="user-dropdown" id="userDropdown" style="display: none;">
                            <div class="dropdown-item" onclick="showBetHistory()">📊 Bet History</div>
                            <div class="dropdown-item" onclick="logout()">🚪 Logout</div>
                        </div>
                    </div>
                    <!-- Non-authenticated user section -->
                    <div id="nonAuthenticatedUser" style="display: block;">
                        <button id="googleSignInBtn" class="google-signin-btn" onclick="initiateGoogleSignIn()">
                            <svg width="18" height="18" viewBox="0 0 24 24">
                                <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
                                <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
                                <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
                                <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
                            </svg>
                            Sign in with Google
                        </button>
                    </div>
            </div>
        </div>
    </header>

    <!-- Main Container -->
    <div class="main-container">
        <!-- Sidebar -->
        <aside class="sidebar">
                <!-- Sports Section -->
            <div class="sidebar-section">
                    <h3 class="sidebar-title">SPORTS</h3>
                    <div id="sportsContainer">
                        <div class="loading-text">Loading sports...</div>
                    </div>
            </div>
            
                <!-- Quick Filters -->
            <div class="sidebar-section" style="display: none;">
                    <h3 class="sidebar-title">QUICK FILTERS</h3>
                    <div class="filter-item" onclick="filterLiveEvents()">
                        <div class="filter-info">
                            <span class="filter-icon">🔴</span>
                            <span>Live Now</span>
                        </div>
                        <span class="event-count" id="liveCount">0</span>
                    </div>
                    <div class="filter-item" onclick="filterTodayEvents()" style="display: none;">
                        <div class="filter-info">
                            <span class="filter-icon">📅</span>
                            <span>Today</span>
                        </div>
                        <span class="event-count" id="todayCount">0</span>
                    </div>
                    <div class="filter-item" onclick="filterTomorrowEvents()" style="display: none;">
                        <div class="filter-info">
                            <span class="filter-icon">⏰</span>
                            <span>Tomorrow</span>
                        </div>
                        <span class="event-count" id="tomorrowCount">0</span>
                    </div>
            </div>
            
                <!-- Account Section -->
            <div class="sidebar-section">
                    <h3 class="sidebar-title">ACCOUNT</h3>
                    <div class="filter-item" onclick="showBetHistory()">
                        <div class="filter-info">
                            <span class="filter-icon">📊</span>
                            <span>Bet History</span>
                        </div>
                    </div>
                    <div class="filter-item" onclick="showAdminPanel()" style="display: none;">
                        <div class="filter-info">
                            <span class="filter-icon">⚙️</span>
                            <span>Admin Panel</span>
                        </div>
                    </div>
            </div>
        </aside>

            <!-- Content Area -->
            <main class="content-area">
                <div class="breadcrumb">
                    <span>Home</span>
                    <span class="breadcrumb-separator">></span>
                    <span id="currentSport">Soccer</span>
                    <span class="breadcrumb-separator">></span>
                    <span>All Events</span>
                </div>

                
                <div class="content-header">
                <div class="view-options">
                        <button class="view-btn active" onclick="switchView('list')">📋 List View</button>
                        <button class="view-btn" onclick="switchView('coupon')">🎫 Coupon View</button>
                </div>
                <div class="live-status">
                    <span id="websocketStatus" class="status-indicator">🔴 Disconnected</span>
                    <!-- Refresh button hidden for UI purposes -->
                <!-- <button onclick="forceRefreshLiveOdds()" class="refresh-btn">🔄 Refresh Live Odds</button> -->
                </div>
            </div>

                <div id="eventsContainer">
                    <div class="events-table">
                        <div class="market-tabs">
                            <!-- Market tabs will be dynamically generated by JavaScript -->
                        </div>
                        <div id="eventsContent">
                            <div class="loading-text">Loading events...</div>
                        </div>
                        <div id="liveOddsContainer" class="live-odds-container">
                            <!-- Live odds will be loaded here -->
                        </div>
                        

                </div>
            </div>
        </main>

        <!-- Bet Slip -->
        <aside class="bet-slip">
            <div class="bet-slip-header">
                <div class="bet-slip-title">
                    🎯 Bet Slip
                    <span class="bet-count" id="betCount">0</span>
                </div>
                <div class="bet-slip-controls">
                    <div id="betModeToggle" onclick="toggleBetMode()" class="slider-toggle">
                        <div class="slider-thumb"></div>
                        <div class="slider-label">Single</div>
                    </div>
                </div>
            </div>
            <div class="bet-slip-content" id="betSlipContent">
                <p>Your bet slip is empty</p>
                <p>Click on odds to add selections</p>
            </div>
        </aside>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.js"></script>
    <script>
        // Global variables
        let currentUser = null;
        let currentSport = 'soccer';
        let currentMarket = 'match_result';
        let currentView = 'list';
        let betSlip = [];
        let sportsData = {};
        let eventsData = {};
        // Initialize global eventsData for periodic checker access
        window.eventsData = {};
        let socket = null;
        let websocketConnected = false;
        let autoRefreshInterval = null;
        let comboTotalStake = 0; // Track total stake for combo bets
        let currentSearchTerm = ''; // Track current search term

        // Sports API base - these endpoints are not tenant-specific
        const SPORTS_API_BASE = '/api';
        
        // Polyfill for Object.entries (for older browser compatibility)
        if (!Object.entries) {
            Object.entries = function(obj) {
                if (obj !== Object(obj)) {
                    throw new TypeError('Object.entries called on non-object');
                }
                var ownProps = Object.keys(obj);
                var i = ownProps.length;
                var resArray = new Array(i);
                while (i--) {
                    resArray[i] = [ownProps[i], obj[ownProps[i]]];
                }
                return resArray;
            };
        }
        
        // Polyfill for Array.from (for older browser compatibility)
        if (!Array.from) {
            Array.from = function(arrayLike) {
                if (arrayLike == null) {
                    throw new TypeError('Array.from requires an array-like object');
                }
                var array = [];
                var length = arrayLike.length;
                for (var i = 0; i < length; i++) {
                    array.push(arrayLike[i]);
                }
                return array;
            };
        }
        
        // Polyfill for Set (for older browser compatibility)
        if (typeof Set === 'undefined') {
            window.Set = function() {
                var items = [];
                this.add = function(value) {
                    if (items.indexOf(value) === -1) {
                        items.push(value);
                    }
                };
                this.has = function(value) {
                    return items.indexOf(value) !== -1;
                };
                this.forEach = function(callback) {
                    for (var i = 0; i < items.length; i++) {
                        callback(items[i], items[i], this);
                    }
                };
                this.size = items.length;
            };
        }
        
        // Polyfill for Promise.allSettled (for older browser compatibility)
        if (!Promise.allSettled) {
            Promise.allSettled = function (promises) {
                return Promise.all(
                    promises.map(function (promise) {
                        return promise
                            .then(function (value) {
                                return { status: 'fulfilled', value: value };
                            })
                            .catch(function (reason) {
                                return { status: 'rejected', reason: reason };
                            });
                    })
                );
            };
        }
        
        // Basic Promise polyfill for very old browsers
        if (typeof Promise === 'undefined') {
            window.Promise = function(executor) {
                var self = this;
                self.state = 'pending';
                self.value = undefined;
                self.reason = undefined;
                self.onFulfilledCallbacks = [];
                self.onRejectedCallbacks = [];
                
                function resolve(value) {
                    if (self.state === 'pending') {
                        self.state = 'fulfilled';
                        self.value = value;
                        self.onFulfilledCallbacks.forEach(function(callback) {
                            callback(value);
                        });
                    }
                }
                
                function reject(reason) {
                    if (self.state === 'pending') {
                        self.state = 'rejected';
                        self.reason = reason;
                        self.onRejectedCallbacks.forEach(function(callback) {
                            callback(reason);
                        });
                    }
                }
                
                try {
                    executor(resolve, reject);
                } catch (e) {
                    reject(e);
                }
            };
            
            Promise.prototype.then = function(onFulfilled, onRejected) {
                var self = this;
                var promise2 = new Promise(function() {});
                
                if (self.state === 'fulfilled') {
                    setTimeout(function() {
                        try {
                            var x = onFulfilled(self.value);
                            promise2.resolve(x);
                        } catch (e) {
                            promise2.reject(e);
                        }
                    }, 0);
                } else if (self.state === 'rejected') {
                    setTimeout(function() {
                        try {
                            var x = onRejected(self.reason);
                            promise2.resolve(x);
                        } catch (e) {
                            promise2.reject(e);
                        }
                    }, 0);
                } else {
                    self.onFulfilledCallbacks.push(function(value) {
                        setTimeout(function() {
                            try {
                                var x = onFulfilled(value);
                                promise2.resolve(x);
                            } catch (e) {
                                promise2.reject(e);
                            }
                        }, 0);
                    });
                    self.onRejectedCallbacks.push(function(reason) {
                        setTimeout(function() {
                            try {
                                var x = onRejected(reason);
                                promise2.resolve(x);
                            } catch (e) {
                                promise2.reject(e);
                            }
                        }, 0);
                    });
                }
                
                return promise2;
            };
            
            Promise.prototype.catch = function(onRejected) {
                return this.then(null, onRejected);
            };
            
            Promise.resolve = function(value) {
                return new Promise(function(resolve) {
                    resolve(value);
                });
            };
            
            Promise.reject = function(reason) {
                return new Promise(function(resolve, reject) {
                    reject(reason);
                });
            };
            
            Promise.all = function(promises) {
                return new Promise(function(resolve, reject) {
                    var results = [];
                    var completed = 0;
                    
                    if (promises.length === 0) {
                        resolve(results);
                        return;
                    }
                    
                    promises.forEach(function(promise, index) {
                        Promise.resolve(promise).then(function(value) {
                            results[index] = value;
                            completed++;
                            if (completed === promises.length) {
                                resolve(results);
                            }
                        }).catch(function(reason) {
                            reject(reason);
                        });
                    });
                });
            };
        }

        // Helper function to inspect odds data structure
        function inspectOddsData(oddsArray, marketKey) {
            console.log(`🔍 Inspecting ${marketKey} odds data:`, {
                type: typeof oddsArray,
                isArray: Array.isArray(oddsArray),
                length: Array.isArray(oddsArray) ? oddsArray.length : 'N/A',
                raw: oddsArray,
                firstElement: Array.isArray(oddsArray) && oddsArray.length > 0 ? oddsArray[0] : 'N/A',
                keys: Array.isArray(oddsArray) && oddsArray.length > 0 ? Object.keys(oddsArray[0]) : 'N/A'
            });
        }
        
        // Helper function to validate odds data quality
        function hasValidOddsData(oddsArray, marketKey) {
            if (!Array.isArray(oddsArray) || oddsArray.length === 0) {
                console.log(`❌ ${marketKey}: Empty or non-array odds data:`, oddsArray);
                return false;
            }
            
            // Check if the odds array contains actual betting options with valid values
            const hasValidOption = oddsArray.some(option => {
                if (!option || typeof option !== 'object') {
                    console.log(`❌ ${marketKey}: Invalid option structure:`, option);
                    return false;
                }
                
                // Check if option has required fields - make this more lenient
                if (!option.value && !option.name && !option.label) {
                    console.log(`❌ ${marketKey}: Missing value/name/label field:`, option);
                    return false;
                }
                
                if (option.odds === undefined || option.odds === null) {
                    console.log(`❌ ${marketKey}: Missing odds field:`, option);
                    return false;
                }
                
                // Very lenient odds validation - allow any positive number
                const oddsValue = parseFloat(option.odds);
                if (isNaN(oddsValue) || oddsValue <= 0) {
                    console.log(`❌ ${marketKey}: Invalid odds value:`, option.odds, 'for option:', option);
                    return false;
                }
                
                console.log(`✅ ${marketKey}: Valid option found:`, option);
                return true;
            });
            
            if (!hasValidOption) {
                console.log(`❌ ${marketKey}: No valid options found in odds array:`, oddsArray);
            }
            
            return hasValidOption;
        }
        
        // Sport-specific betting markets - DYNAMIC MARKET DETECTION
        function getBettingMarkets(sport) {
            console.log(`🎯 Getting betting markets for ${sport}`);
            console.log(`🔍 eventsData keys:`, Object.keys(eventsData));
            console.log(`🔍 eventsData[${sport}]:`, eventsData[sport]);
            
            // Get current events to discover available markets
            const events = eventsData[sport] || [];
            if (!events || events.length === 0) {
                console.log(`No events found for ${sport}`);
                return [];
            }
            
            // Discover all available markets from the actual data
            const availableMarkets = new Set();
            events.forEach((event, index) => {
                console.log(`🔍 Event ${index}: ${event.home_team} vs ${event.away_team}`);
                console.log(`🔍 Event odds:`, event.odds);
                if (event.odds) {
                    console.log(`🔍 Event odds keys:`, Object.keys(event.odds));
                    Object.keys(event.odds).forEach(marketKey => {
                        // Skip has_draw market (should not be displayed as a separate market)
                        if (marketKey === 'has_draw') {
                            console.log(`🚫 Skipping has_draw market for ${sport}`);
                            return;
                        }
                        
                        // Filter out invalid markets for specific sports
                        if (sport === 'darts') {
                            // For darts, only allow 'home_away' market (displayed as Match Result)
                            if (marketKey === 'home_away') {
                                availableMarkets.add(marketKey);
                            }
                        } else if (sport === 'baseball') {
                            // For baseball, allow all valid markets including home_away
                            if (marketKey === 'correct_score' || 
                                marketKey === 'match_result' || 
                                marketKey === 'odd_even_including_ot' ||
                                marketKey === 'home_away') {
                                availableMarkets.add(marketKey);
                            }
                        } else if (sport === 'esports') {
                            // For esports, only allow 'home_away' market (Match Winners)
                            if (marketKey === 'home_away') {
                                availableMarkets.add(marketKey);
                            }
                        } else if (sport === 'futsal') {
                            // For futsal, only allow 'match_result' and 'ht_ft_double' markets
                            if (marketKey === 'match_result' || marketKey === 'ht_ft_double') {
                                availableMarkets.add(marketKey);
                            }
                        } else {
                            // For other sports, allow all markets
                            availableMarkets.add(marketKey);
                        }
                    });
                }
            });
            
            console.log(`Available markets in data for ${sport}:`, Array.from(availableMarkets));
            console.log(`🔍 Raw market keys found:`, events.map(e => e.odds ? Object.keys(e.odds) : []).flat());
            
            // Count events with odds for each market
            const marketCounts = {};
            availableMarkets.forEach(marketKey => {
                let count = 0;
                events.forEach(event => {
                    if (event.odds && event.odds[marketKey]) {
                        const marketData = event.odds[marketKey];
                        let hasOdds = false;
                        
                        // Handle different odds data structures
                        if (Array.isArray(marketData)) {
                            // Array structure (e.g., [1.5, 2.1])
                            hasOdds = marketData.length > 0;
                        } else if (typeof marketData === 'object' && marketData !== null) {
                            // Object structure (e.g., {'1': 1.5, 'X': 3.2, '2': 2.1})
                            hasOdds = Object.keys(marketData).length > 0;
                        } else {
                            hasOdds = false;
                        }
                        
                        if (hasOdds) {
                            count++;
                        }
                    }
                });
                marketCounts[marketKey] = count;
            });
            
            console.log(`Market counts for ${sport}:`, marketCounts);
            
            // Always include match_result first, or home_away as fallback for 2-way markets
            const finalMarkets = [];
            if (availableMarkets.has('match_result')) {
                finalMarkets.push({
                    id: 'match_result',
                    name: mapMarketKeyToDisplayName('match_result', sport),
                    eventCount: marketCounts['match_result'] || 0
                });
            } else if (availableMarkets.has('home_away')) {
                // For sports without draw option (volleyball, tennis, etc.), use home_away
                // Special case: For baseball, treat home_away as match_result
                if (sport === 'baseball') {
                    finalMarkets.push({
                        id: 'match_result', // Map to match_result for baseball
                        name: 'Match Result', // Display as "Match Result"
                        eventCount: marketCounts['home_away'] || 0
                    });
                } else if (sport === 'darts') {
                    // Special case: For darts, treat home_away as match_result
                    finalMarkets.push({
                        id: 'match_result', // Map to match_result for darts
                        name: 'Match Result', // Display as "Match Result"
                        eventCount: marketCounts['home_away'] || 0
                    });
                } else if (sport === 'esports') {
                    // Special case: For esports, treat home_away as match_result
                    finalMarkets.push({
                        id: 'match_result', // Map to match_result for esports
                        name: 'Match Winners', // Display as "Match Winners"
                        eventCount: marketCounts['home_away'] || 0
                    });
                } else {
                    finalMarkets.push({
                        id: 'home_away',
                        name: mapMarketKeyToDisplayName('home_away', sport),
                        eventCount: marketCounts['home_away'] || 0
                    });
                }
            }
            
            // Special case: For baseball, always ensure match_result is first
            if (sport === 'baseball' && !finalMarkets.some(m => m.id === 'match_result')) {
                // If no match_result found, create a placeholder with 0 count
                finalMarkets.unshift({
                    id: 'match_result',
                    name: 'Match Result',
                    eventCount: 0
                });
            }
            
            // Get top 4 markets by event count (excluding match_result and home_away)
            const otherMarkets = Array.from(availableMarkets)
                .filter(marketKey => !['match_result', 'home_away'].includes(marketKey))
                .map(marketKey => ({
                    id: marketKey,
                    name: mapMarketKeyToDisplayName(marketKey, sport),
                    eventCount: marketCounts[marketKey] || 0
                }))
                .sort((a, b) => b.eventCount - a.eventCount) // Sort by count descending
                .slice(0, 4); // Take top 4
            
            // Combine match_result with top 4 markets
            const topMarkets = [...finalMarkets, ...otherMarkets];
            
            console.log(`Top 5 markets for ${sport}:`, topMarkets);
            return topMarkets;
        }
        
        // Map market keys to display names
        function mapMarketKeyToDisplayName(marketKey, sport) {
            const marketNames = {
                // Soccer markets
                'match_result': 'Match Result',
                'home_away': sport === 'darts' ? 'Match Result' : (sport === 'esports' ? 'Match Winners' : 'Match Winner'),  // For darts, show as Match Result; for esports, show as Match Winners
                'correct_score': 'Correct Score',
                'correct_score_first_half': 'Correct Score 1st Half',
                'both_teams_score': 'Both Teams Score',
                'first_half_winner': '1st Half Winner',
                'double_chance': 'Double Chance',
                'team_to_score_first': 'Team to Score First',
                'over_under': 'Over/Under',
                'asian_handicap': 'Asian Handicap',
                'odd_even': 'Odd/Even',
                'clean_sheet_home': 'Clean Sheet - Home',
                'clean_sheet_away': 'Clean Sheet - Away',
                'win_both_halves': 'Win Both Halves',
                'ht_ft_double': 'HT/FT Double',
                'highest_scoring_half': 'Highest Scoring Half',
                'second_half_winner': '2nd Half Winner',
                'double_chance_first_half': 'Double Chance 1st Half',
                'both_teams_score_first_half': 'Both Teams Score 1st Half',
                'both_teams_score_second_half': 'Both Teams Score 2nd Half',
                'odd_even_first_half': 'Odd/Even 1st Half',
                'to_qualify': 'To Qualify',
                'results_both_teams_score': 'Results + Both Teams Score',
                'corners_1x2': 'Corners 1X2',
                
                // Basketball markets
                'first_quarter_winner': '1st Quarter Winner',
                'highest_scoring_quarter': 'Highest Scoring Quarter',
                'odd_even_including_ot': 'Odd/Even (Including OT)',
                
                // Cricket markets
                'most_sixes': 'Most Sixes',
                'most_fours': 'Most Fours',
                'most_run_outs': 'Most Run Outs',
                
                // Generic fallback
                'win_to_nil_home': 'Win to Nil - Home',
                'win_to_nil_away': 'Win to Nil - Away'
            };
            
            return marketNames[marketKey] || marketKey.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
        }
        
        function getAllMarketsForSport(sport) {
            switch(sport) {
                case 'soccer':
                    return [
                        { id: 'match_result', name: 'Match Result' },
                        { id: 'asian_handicap', name: '1st Half Winner' },
                        { id: 'over_under', name: 'Both Teams Score' }
                    ];
                case 'basketball':
                    return [
                        { id: 'match_result', name: 'Match Result' },
                        { id: 'first_half_winner', name: 'Home/Away - 1st Half' },
                        { id: 'first_quarter_winner', name: 'Home/Away - 1st Quarter' },
                        { id: 'highest_scoring_quarter', name: 'Highest Scoring Quarter' },
                        { id: 'odd_even_including_ot', name: 'Odd/Even (Including OT)' }
                    ];
                case 'tennis':
                    return [
                        { id: 'home_away', name: 'Match Winner' },  // Tennis has no draw
                        { id: 'correct_score_first_half', name: 'Correct Score 1st Half' },
                        { id: 'games_over_under', name: 'Games Over/Under' },
                        { id: 'over_under_first_set', name: 'Over/Under (1st Set)' },
                        { id: 'first_set', name: 'Home/Away (1st Set)' },
                        { id: 'asian_handicap_sets', name: 'Asian Handicap (Sets)' },
                        { id: 'asian_handicap_games', name: 'Asian Handicap (Games)' },
                        { id: 'set_betting', name: 'Set Betting' },
                        { id: 'tie_break_first_set', name: 'Tie-break (1st Set)' },
                        { id: 'second_set', name: 'Home/Away (2nd Set)' },
                        { id: 'win_one_set_player1', name: 'Win at least one set (Player 1)' },
                        { id: 'win_one_set_player2', name: 'Win at least one set (Player 2)' }
                    ];
                case 'table_tennis':
                    return [
                        { id: 'home_away', name: 'Match Winner' },  // Table Tennis has no draw
                        { id: 'first_set', name: 'Home/Away (1st Set)' },
                        { id: 'set_betting', name: 'Set Betting' }
                    ];
                case 'darts':
                    return [
                        { id: 'match_result', name: 'Match Result' }  // Darts only shows Match Result (from home_away)
                    ];
                case 'volleyball':
                    return [
                        { id: 'home_away', name: 'Match Winner' },  // Volleyball has no draw
                        { id: 'correct_score', name: 'Correct Score' },
                        { id: 'odd_even_first_set', name: 'Odd/Even (1st Set)' },
                        { id: 'over_under_first_set', name: 'Over/Under (1st Set)' },
                        { id: 'first_set', name: 'Home/Away (1st Set)' }
                    ];
                case 'handball':
                    return [
                        { id: 'match_result', name: 'Match Result' }
                    ];
                case 'baseball':
                    return [
                        { id: 'match_result', name: 'Match Result' },  // Baseball now has match_result with 2-way odds
                        { id: 'correct_score', name: 'Correct Score' },
                        { id: 'odd_even_including_ot', name: 'Odd/Even (Including OT)' }
                    ];
                case 'cricket':
                    return [
                        { id: 'home_away', name: 'Match Result' },    // Match Result (Home/Away) - updated to match backend
                        { id: 'most_sixes', name: 'Most Sixes' },      // Most Sixes
                        { id: 'most_fours', name: 'Most Fours' },     // Most Fours
                        { id: 'most_run_outs', name: 'Most Run Outs' } // Most Run Outs
                    ];
                case 'hockey':
                    return [
                        { id: 'match_result', name: 'Match Winner' },
                        { id: 'over_under', name: 'Over/Under' },
                        { id: 'first_half_winner', name: '1st Half Winner' }
                    ];
                case 'futsal':
                    return [
                        { id: 'match_result', name: 'Match Result' },
                        { id: 'over_under', name: 'Over/Under' }
                    ];
                case 'boxing':
                    return [
                        { id: 'match_result', name: 'Match Winner' },
                        { id: 'over_under', name: 'Over/Under' }
                    ];
                case 'mma':
                    return [
                        { id: 'match_result', name: 'Match Winner' },
                        { id: 'over_under', name: 'Over/Under' }
                    ];
                case 'esports':
                    return [
                        { id: 'match_result', name: 'Match Winners' }  // Esports only shows Match Winners (from home_away)
                    ];
                default:
                    return [
                        { id: 'home_away', name: 'Match Winner' },  // Default to home_away for sports without draw
                        { id: 'over_under', name: 'Over/Under' },
                        { id: 'asian_handicap', name: 'Asian Handicap' }
                    ];
            }
        }
        
        // Check if any events have odds for a specific market
        function hasOddsForMarket(sport, marketId) {
            console.log(`🔍 Checking odds for ${sport} - ${marketId}`);
            
            // Get current events for this sport
            const events = getCurrentEvents(sport);
            console.log(`Events found: ${events ? events.length : 0}`);
            
            if (!events || events.length === 0) {
                console.log('❌ No events found');
                return false;
            }
            
            // DEBUG: Show first few events and their odds structure
            console.log('📊 Sample events and their odds:');
            events.slice(0, 3).forEach((event, index) => {
                console.log(`Event ${index + 1}: ${event.home_team} vs ${event.away_team}`);
                console.log(`  Has odds object: ${!!event.odds}`);
                if (event.odds) {
                    console.log(`  Available odds keys:`, Object.keys(event.odds));
                    console.log(`  Full odds object:`, event.odds);
                }
            });
            
            // Special handling for soccer markets
            if (sport === 'soccer') {
                if (marketId === 'asian_handicap') {
                    // Check for first_half_winner market (which is what asian_handicap maps to)
                    return events.some(event => {
                        if (!event.odds) return false;
                        // Check if any event has first_half_winner odds
                        const hasOdds = event.odds.first_half_winner && event.odds.first_half_winner.length > 0;
                        console.log(`Event ${event.home_team} vs ${event.away_team}: first_half_winner = ${hasOdds}`);
                        return hasOdds;
                    });
                } else if (marketId === 'over_under') {
                    // Check for both_teams_score market (which is what over_under maps to)
                    return events.some(event => {
                        if (!event.odds) return false;
                        // Check if any event has both_teams_score odds
                        const hasOdds = event.odds.both_teams_score && event.odds.both_teams_score.length > 0;
                        console.log(`Event ${event.home_team} vs ${event.away_team}: both_teams_score = ${hasOdds}`);
                        return hasOdds;
                    });
                }
            }
            
            // Check if any event has odds for this market
            const hasOdds = events.some(event => {
                if (!event.odds || !event.odds[marketId]) {
                    return false;
                }
                
                const marketData = event.odds[marketId];
                let hasMarketOdds = false;
                
                // Handle different odds data structures
                if (Array.isArray(marketData)) {
                    // Array structure (e.g., [1.5, 2.1])
                    hasMarketOdds = marketData.length > 0;
                } else if (typeof marketData === 'object' && marketData !== null) {
                    // Object structure (e.g., {'1': 1.5, 'X': 3.2, '2': 2.1})
                    hasMarketOdds = Object.keys(marketData).length > 0;
                } else {
                    hasMarketOdds = false;
                }
                
                console.log(`Event ${event.home_team} vs ${event.away_team}: odds[${marketId}] = ${hasMarketOdds}`);
                if (event.odds) {
                    console.log('Available odds markets:', Object.keys(event.odds));
                    console.log(`Checking for market: ${marketId}`);
                    console.log(`Market exists: ${event.odds.hasOwnProperty(marketId)}`);
                    if (event.odds[marketId]) {
                        console.log(`Market data:`, event.odds[marketId]);
                    }
                }
                return hasMarketOdds;
            });
            
            console.log(`✅ Has odds for ${marketId}: ${hasOdds}`);
            return hasOdds;
        }
        
        // Get current events for a sport
        function getCurrentEvents(sport) {
            // If we're checking the current sport, use the stored events
            if (currentSport === sport && window.currentEvents) {
                return window.currentEvents;
            }
            
            // For other sports, we need to fetch the events
            // This is a simplified approach - in a real implementation you might want to cache this
            if (eventsData[sport]) {
                const events = eventsData[sport].filter(event => !event.is_completed && !event.is_cancelled);
                return events;
            }
            
            return [];
        }

        let updateBettingMarketsInProgress = false;
        
        function updateBettingMarkets() {
            // Temporarily disable the guard to fix the issue
            // if (updateBettingMarketsInProgress) {
            //     console.log('🚫 Update betting markets already in progress, skipping...');
            //     return;
            // }
            
            // updateBettingMarketsInProgress = true;
            
            const marketTabs = document.querySelector('.market-tabs');
            const markets = getBettingMarkets(currentSport);
            
            marketTabs.innerHTML = '';
            
            // Store current market selection before updating
            const previousMarket = currentMarket;
            
            if (markets.length > 0) {
                // Check if current market is still available
                const currentMarketStillAvailable = markets.some(market => market.id === previousMarket);
                
                markets.forEach((market, index) => {
                    // Skip markets that contain "Market Id" in their name
                    if (market.name && market.name.toLowerCase().includes('market id')) {
                        console.log(`🚫 Hiding market tab: ${market.name}`);
                        return; // Skip this market
                    }
                    
                    // Skip has_draw market (should not be displayed as a separate market)
                    if (market.id === 'has_draw' || market.name === 'Has Draw') {
                        console.log(`🚫 Hiding has_draw market tab: ${market.name}`);
                        return; // Skip this market
                    }
                    
                    const button = document.createElement('button');
                    // Keep current market active if it's still available, otherwise use first market
                    const isActive = currentMarketStillAvailable ? 
                        (market.id === previousMarket) : 
                        (index === 0);
                    button.className = `market-tab ${isActive ? 'active' : ''}`;
                    button.onclick = () => switchMarket(market.id);
                    button.textContent = market.name;
                    marketTabs.appendChild(button);
                });
                
                // Maintain current market if available, otherwise reset to first
                currentMarket = currentMarketStillAvailable ? previousMarket : markets[0].id;
                
                console.log(`✅ Showing ${markets.length} filtered markets for ${currentSport}:`, markets.map(m => m.id));
            } else {
                // If no markets pass validation, try to show at least match_result if available
                console.log(`⚠️ No markets passed validation for ${currentSport}, attempting to show match_result only`);
                
                // Try to get just the match_result market if it exists in the data
                const events = eventsData[currentSport] || [];
                let hasMatchResult = false;
                
                if (events.length > 0) {
                    events.forEach(event => {
                        if (event.odds && event.odds.match_result && 
                            Array.isArray(event.odds.match_result) && 
                            event.odds.match_result.length > 0) {
                            hasMatchResult = true;
                        }
                    });
                }
                
                if (hasMatchResult) {
                    // Show only match_result market
                    const button = document.createElement('button');
                    button.className = 'market-tab active';
                    button.onclick = () => switchMarket('match_result');
                    button.textContent = 'Match Result';
                    marketTabs.appendChild(button);
                    currentMarket = 'match_result';
                    console.log(`✅ Showing only match_result market for ${currentSport}`);
                } else {
                    // Show message that no markets are available
                    const messageDiv = document.createElement('div');
                    messageDiv.className = 'no-markets-message';
                    messageDiv.textContent = 'No betting markets available for this sport at the moment.';
                    messageDiv.style.cssText = 'text-align: center; padding: 20px; color: #666; font-style: italic;';
                    marketTabs.appendChild(messageDiv);
                    currentMarket = null;
                    console.log(`❌ No markets available for ${currentSport}`);
                }
            }
            
            // Clear the progress flag (disabled)
            // updateBettingMarketsInProgress = false;
        }

        // Authentication functions - REMOVED to prevent conflicts with bootstrapAuth
        // These were overriding our redirectToTenantLogin functions
        // window.showLogin and window.showRegister are now handled by bootstrapAuth
        
        // Ensure functions are also available without window prefix
        function showLogin() { window.showLogin(); }
        function showRegister() { window.showRegister(); }

        // Wait for DOM to be ready before adding event listeners
        // Add event listener for auth toggle link
        const authToggleLink = document.getElementById('authToggleLink');
        if (authToggleLink) {
            authToggleLink.addEventListener('click', function(e) {
                e.preventDefault();
                const currentMode = document.getElementById('authForm').getAttribute('data-mode') || 'login';
                if (currentMode === 'login') {
                    // showRegister(); // DISABLED: conflicts with session-based auth
                } else {
                    // showLogin(); // DISABLED: conflicts with session-based auth
                }
            });
        }

        const authForm = document.getElementById('authForm');
        if (authForm) {
        authForm.addEventListener('submit', async function(e) {
            e.preventDefault();
            const mode = this.getAttribute('data-mode');
            const username = document.getElementById('username').value;
            const password = document.getElementById('password').value;
            
            try {
                let response;
                if (mode === 'login') {
                    response = await fetch(`${API_BASE}/api/auth/login`, {
                    method: 'POST',
                    headers: {
                            'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ username, password })
                });
                } else {
                    const email = document.getElementById('email').value;
                    const confirmPassword = document.getElementById('confirmPassword').value;
            
            if (password !== confirmPassword) {
                        alert('Passwords do not match');
                return;
            }
            
                    response = await fetch(`${API_BASE}/api/auth/register`, {
                    method: 'POST',
                    headers: {
                            'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ username, email, password })
                });
                }
                
                const data = await response.json();
                
                if (response.ok) {
                    if (mode === 'register') {
                        alert('Registration successful! You can now login.');
                        // showLogin(); // DISABLED: conflicts with session-based auth
                } else {
                        localStorage.setItem('token', data.token);
                        currentUser = data.user;
                        document.getElementById('loginOverlay').style.display = 'none';
                        const mainApp = document.getElementById('mainApp');
        if (mainApp) {
            mainApp.classList.add('visible');
        }
                        document.getElementById('userBalance').textContent = `$${data.user.balance.toFixed(2)}`;
                        
                        // Initialize the app after successful login
                        await initializeAppAfterLogin();
                    }
                } else {
                    alert(data.message || 'Authentication failed');
                }
            } catch (error) {
                console.error('Auth error:', error);
                alert('Authentication failed. Please try again.');
            }
        });
        }

        // Auto-refresh odds every 1 minute
        let oddsRefreshInterval;
        
        function startOddsAutoRefresh() {
            // Clear any existing interval
            if (oddsRefreshInterval) {
                clearInterval(oddsRefreshInterval);
            }
            
            // WALLET BALANCE AUTO-REFRESH ONLY: Odds are now live via immediate updates
            // No more odds auto-refresh needed since pre-market odds update immediately
            console.log('✅ Odds auto-refresh disabled: Pre-market odds now update immediately via live JSON parsing');
            console.log('✅ Wallet balance auto-refresh remains active: Every 2 minutes for real-time balance updates');
        }
        


        // Sports loading functions
        let loadSportsInProgress = false;
        
        async function loadSports() {
            // Temporarily disable the guard to fix the issue
            // if (loadSportsInProgress) {
            //     console.log('🚫 Loading sports already in progress, skipping...');
            //     return;
            // }
            
            // loadSportsInProgress = true;
            
            try {
                console.log('🔄 Loading sports...');
                console.log('🌐 API_BASE:', API_BASE);
                console.log('🔗 Full URL:', `${API_BASE}/api/sports/sports`);
                
                // Show loading indicator
                showLoadingIndicator();
                
                // Show loading state
                document.getElementById('sportsContainer').innerHTML = '<div class="loading-text">Loading sports...</div>';
                
                console.log('Loading sports with session authentication...');
                
                const response = await fetch(`${API_BASE}/api/sports/sports`, {
                    credentials: 'include' // Include cookies for session
                });
                
                console.log('Response status:', response.status);
                console.log('Response headers:', Object.fromEntries(response.headers.entries()));
                
                if (response.ok) {
                    const responseText = await response.text();
                    console.log('Raw response text:', responseText);
                    
                    try {
                        sportsData = JSON.parse(responseText);
                    } catch (parseError) {
                        console.error('Failed to parse JSON:', parseError);
                        console.error('Response text:', responseText);
                        document.getElementById('sportsContainer').innerHTML = '<div class="loading-text">Invalid response format</div>';
                        return;
                    }
                    
                    console.log('Sports data received:', sportsData);
                    console.log('🔍 Sports data keys:', Object.keys(sportsData));
                    console.log('🔍 Sports data structure:', {
                        type: typeof sportsData,
                        isArray: Array.isArray(sportsData),
                        length: Array.isArray(sportsData) ? sportsData.length : Object.keys(sportsData).length,
                        sample: Array.isArray(sportsData) ? sportsData[0] : (Object.entries ? Object.entries(sportsData)[0] : 'Object.entries not supported')
                    });
                    
                    if (Array.isArray(sportsData) && sportsData.length > 0) {
                        currentSport = sportsData[0].name;
                        console.log('Default sport set to:', currentSport);
                    } else if (typeof sportsData === 'object' && Object.keys(sportsData).length > 0) {
                        currentSport = Object.keys(sportsData)[0];
                        console.log('Default sport set to:', currentSport);
                    }
                    
                    console.log('🔍 DEBUG: currentSport after setting:', currentSport);
                    console.log('🔍 DEBUG: sportsData type:', typeof sportsData);
                    console.log('🔍 DEBUG: sportsData keys:', Object.keys(sportsData));
                    
                    // First display sports so user can see them
                    displaySports();
                    
                    // Update the active state for the default sport
                    if (currentSport) {
                        updateSportsActiveState(currentSport);
                    }
                    
                    // Then load events for the default sport immediately
                    if (currentSport) {
                        loadEvents(currentSport);
                    }
                    
                    // Also warm up cache for the default sport immediately for instant loading
                    if (currentSport) {
                        loadEventsForCache(currentSport).catch(error => {
                            console.error('Default sport cache warming failed:', error);
                        });
                    }
                    
                    // Finally, cache events for ALL sports and THEN start the periodic checker
                    preloadAllSportsEvents().then(() => {
                        console.log('🚀 Preloading completed, now starting periodic odds checker...');
                        console.log('🔍 DEBUG: Inside .then() callback, about to call startOddsUpdateChecker...');
                        

                        
                        // Start periodic odds update checker AFTER preloading is complete
                        if (typeof startOddsUpdateChecker === 'function') {
                            console.log('✅ startOddsUpdateChecker function found, calling it...');
                            startOddsUpdateChecker();
                        } else {
                            console.error('❌ startOddsUpdateChecker function NOT found!');
                        }
                    }).catch(error => {
                        console.error('Background caching failed:', error);
                        

                        
                        // Even if preloading fails, start the periodic checker
                        if (typeof startOddsUpdateChecker === 'function') {
                            console.log('✅ startOddsUpdateChecker function found (fallback), calling it...');
                            startOddsUpdateChecker();
                        } else {
                            console.error('❌ startOddsUpdateChecker function NOT found in fallback!');
                        }
                    });
                    
                    // Fallback: Start periodic checker after 10 seconds even if preloading is still running
                    setTimeout(() => {
                        console.log('⏰ Fallback timer triggered, checking if we can start periodic checker...');
                        console.log('⏰ startOddsUpdateChecker function exists:', typeof startOddsUpdateChecker === 'function');
                        console.log('⏰ window.oddsUpdateInterval exists:', !!window.oddsUpdateInterval);
                        console.log('⏰ Current time:', new Date().toISOString());
                        

                        
                        if (typeof startOddsUpdateChecker === 'function' && !window.oddsUpdateInterval) {
                            console.log('⏰ Fallback: Starting periodic odds checker after timeout...');
                            startOddsUpdateChecker();
                        } else {
                            console.log('⏰ Fallback: Cannot start periodic checker - function missing or already running');
                        }
                    }, 10000);
                } else {
                    console.error('Failed to load sports - Status:', response.status);
                    const errorText = await response.text();
                    console.error('Error response:', errorText);
                    document.getElementById('sportsContainer').innerHTML = `<div class="loading-text">Error: ${response.status} - ${errorText}</div>`;
                }
            } catch (error) {
                console.error('Error loading sports:', error);
                document.getElementById('sportsContainer').innerHTML = `<div class="loading-text">Network error: ${error.message}</div>`;
                

            } finally {
                // Always clear the loading flag (disabled)
                // loadSportsInProgress = false;
            }
        }

        // PROACTIVE CACHING: Preload events for all sports
        let preloadAllSportsEventsInProgress = false;
        
        async function preloadAllSportsEvents() {
            if (preloadAllSportsEventsInProgress) {
                console.log('🚫 Preloading all sports events already in progress, skipping...');
                return;
            }
            
            preloadAllSportsEventsInProgress = true;
            
            try {
                console.log('🚀 Starting proactive caching for all sports...');
                
                // Get list of all available sports
                let sportsList = [];
                console.log(`🔍 DEBUG: sportsData type:`, typeof sportsData);
                console.log(`🔍 DEBUG: sportsData content:`, sportsData);
                console.log(`🔍 DEBUG: sportsData keys:`, Object.keys(sportsData || {}));
                
                if (Array.isArray(sportsData)) {
                    sportsList = sportsData.map(sport => sport.name);
                    console.log(`🔍 DEBUG: sportsData is array, mapped to:`, sportsList);
                } else if (typeof sportsData === 'object') {
                    sportsList = Object.keys(sportsData);
                    console.log(`🔍 DEBUG: sportsData is object, keys:`, sportsList);
                }
                
                console.log(`📦 Caching events for ${sportsList.length} sports:`, sportsList);
                
                // Load events for all sports in parallel (but limit concurrent requests)
                const batchSize = 3; // Process 3 sports at a time to avoid overwhelming the server
                console.log(`🔍 DEBUG: sportsList before processing:`, sportsList);
                console.log(`🔍 DEBUG: sportsList length:`, sportsList.length);
                
                for (let i = 0; i < sportsList.length; i += batchSize) {
                    const batch = sportsList.slice(i, i + batchSize);
                    console.log(`📦 Processing batch ${Math.floor(i/batchSize) + 1}: ${batch.join(', ')}`);
                    console.log(`🔍 DEBUG: About to call loadEventsForCache for batch:`, batch);
                    const promises = batch.map(sport => loadEventsForCache(sport));
                    
                    console.log(`🔍 DEBUG: Created ${promises.length} promises for batch`);
                    await Promise.allSettled(promises);
                    console.log(`🔍 DEBUG: Completed batch ${Math.floor(i/batchSize) + 1}`);
                    
                    // Small delay between batches to be server-friendly
                    if (i + batchSize < sportsList.length) {
                        await new Promise(resolve => setTimeout(resolve, 200));
                    }
                }
                
                console.log('✅ Proactive caching completed for all sports');
                console.log('🔍 Final window.eventsData state:', Object.keys(window.eventsData || {}));
                console.log('🔍 window.eventsData content:', window.eventsData);
                console.log('🔍 Number of sports with cached data:', Object.keys(window.eventsData || {}).length);
                console.log('🔍 DEBUG: About to resolve preloadAllSportsEvents promise...');
                
            } catch (error) {
                console.error('❌ Error during proactive caching:', error);
            } finally {
                // Always clear the loading flag
                preloadAllSportsEventsInProgress = false;
            }
        }

        // Load events for caching (without displaying)
        let loadEventsForCacheInProgress = {};
        
        async function loadEventsForCache(sport) {
            console.log(`🔍 loadEventsForCache called for sport: ${sport}`);
            if (loadEventsForCacheInProgress[sport]) {
                console.log(`🚫 Already caching events for ${sport}, skipping duplicate request`);
                return;
            }
            
            loadEventsForCacheInProgress[sport] = true;
            
            try {
                console.log(`📦 Caching events for ${sport}...`);
                
                const response = await fetch(`${API_BASE}/api/sports/events/${sport}`, {
                    credentials: 'include' // Include cookies for session
                });
                
                if (response.ok) {
                    const freshEventsData = await response.json();
                    
                    // Cache the data
                    const cacheKey = `events_cache_${sport}`;
                    const now = Date.now();
                    localStorage.setItem(cacheKey, JSON.stringify(freshEventsData));
                    localStorage.setItem(`${cacheKey}_timestamp`, now.toString());
                    
                    console.log(`✅ Cached ${freshEventsData.length} events for ${sport}`);
                    console.log(`🔍 Before storing: window.eventsData keys:`, Object.keys(window.eventsData || {}));
                    
                    // Store in memory cache for instant access
                    if (!window.eventsData) {
                        window.eventsData = {};
                        console.log(`🔍 Initialized window.eventsData as empty object`);
                    }
                    window.eventsData[sport] = freshEventsData;
                    console.log(`🔍 After storing ${sport}: window.eventsData keys:`, Object.keys(window.eventsData || {}));
                } else {
                    console.warn(`⚠️ Failed to cache events for ${sport}: ${response.status}`);
                }
            } catch (error) {
                console.error(`❌ Error caching events for ${sport}:`, error);
            } finally {
                // Always clear the loading flag
                loadEventsForCacheInProgress[sport] = false;
            }
        }

        // Refresh all sports cache in background
        let refreshAllSportsCacheInProgress = false;
        
        async function refreshAllSportsCache() {
            if (refreshAllSportsCacheInProgress) {
                console.log('🚫 Refreshing all sports cache already in progress, skipping...');
                return;
            }
            
            refreshAllSportsCacheInProgress = true;
            
            try {
                console.log('🔄 Refreshing all sports cache in background...');
                
                // Get list of all available sports
                let sportsList = [];
                if (Array.isArray(sportsData)) {
                    sportsList = sportsData.map(sport => sport.name);
                } else if (typeof sportsData === 'object') {
                    sportsList = Object.keys(sportsData);
                }
                
                // Refresh cache for all sports in parallel (but limit concurrent requests)
                const batchSize = 3; // Process 3 sports at a time
                for (let i = 0; i < sportsList.length; i += batchSize) {
                    const batch = sportsList.slice(i, i + batchSize);
                    const promises = batch.map(sport => loadEventsForCache(sport));
                    
                    await Promise.allSettled(promises);
                    
                    // Small delay between batches to be server-friendly
                    if (i + batchSize < sportsList.length) {
                        await new Promise(resolve => setTimeout(resolve, 150));
                    }
                }
                
                console.log('✅ Background cache refresh completed for all sports');
                
            } catch (error) {
                console.error('❌ Error during background cache refresh:', error);
            } finally {
                // Always clear the loading flag
                refreshAllSportsCacheInProgress = false;
            }
        }

        function displaySports() {
            console.log('🎯 Displaying sports...');
            const container = document.getElementById('sportsContainer');
            console.log('Container found:', !!container);
            
            if (!container) {
                console.error('Sports container not found!');
                return;
            }
            
            // Check if we have sports data
            if (!sportsData || (Array.isArray(sportsData) && sportsData.length === 0) || (typeof sportsData === 'object' && Object.keys(sportsData).length === 0)) {
                console.warn('No sports data available');
                container.innerHTML = '<div class="loading-text">No sports available</div>';
                return;
            }
            
            const sportsIcons = {
                'soccer': '⚽',
                'basketball': '🏀',
                'tennis': '🎾',
                'baseball': '⚾',
                'hockey': '🏒',
                'volleyball': '🏐',
                'football': '🏈',
                'cricket': '🏏',
                'rugby': '🏉',
                'boxing': '🥊'
            };
            
            console.log('Sports data type:', typeof sportsData);
            console.log('Sports data:', sportsData);
            
            try {
                // Handle both array and object formats
                const sportsArray = Array.isArray(sportsData) ? sportsData : (Object.entries ? Object.entries(sportsData).map(([name, data]) => ({ 
                    name, 
                    event_count: typeof data === 'object' ? data.count : data,
                    display_name: typeof data === 'object' ? data.display_name : name.charAt(0).toUpperCase() + name.slice(1),
                    icon: typeof data === 'object' ? data.icon : sportsIcons[name] || '🏆',
                    has_draw: typeof data === 'object' ? data.has_draw : false
                })) : []);
                
                console.log('Processed sports array:', sportsArray);
                

                const html = sportsArray.map(sport => {
                    const isActive = sport.name === currentSport;
                    console.log(`🎯 Sport: ${sport.name}, Current: ${currentSport}, Active: ${isActive}`);
                    return `
                        <div class="sport-item ${isActive ? 'active' : ''}" onclick="selectSport('${sport.name}')">
                            <div class="sport-info">
                                <span class="sport-icon">${sport.icon}</span>
                                <span class="sport-name">${sport.display_name}</span>
                            </div>
                            <span class="event-count">${sport.event_count || 0}</span>
                        </div>
                    `;
                }).join('');
                
                console.log('Generated HTML length:', html.length);
                container.innerHTML = html;
                console.log('✅ Sports displayed successfully');
                
                // Ensure the active state is properly set after displaying
                if (currentSport) {
                    updateSportsActiveState(currentSport);
                }
            } catch (error) {
                console.error('Error displaying sports:', error);
                container.innerHTML = '<div class="loading-text">Error loading sports</div>';
            }
        }

        function selectSport(sport) {
            console.log(`🎯 Selecting sport: ${sport}`);
            console.log(`🔍 Available sports in sportsData:`, Object.keys(sportsData));
            console.log(`🔍 Available sports in eventsData:`, Object.keys(eventsData));
            console.log(`🔍 Sport type:`, typeof sport);
            console.log(`🔍 Sport value:`, sport);
            

            
            currentSport = sport;
            console.log(`Current sport set to: ${currentSport}`);
            
            // Update the breadcrumb display
            const currentSportElement = document.getElementById('currentSport');
            if (currentSportElement) {
                currentSportElement.textContent = sport.charAt(0).toUpperCase() + sport.slice(1);
            }
            
            // Update sports display to show active state
            updateSportsActiveState(sport);
            
            // Update betting markets for the new sport
            updateBettingMarkets();
            
            // Load events for the selected sport
            loadEvents(sport);
        }
        
        // Optimized function to update only the active state of sports
        function updateSportsActiveState(activeSport) {
            const sportItems = document.querySelectorAll('.sport-item');
            sportItems.forEach(item => {
                // Check if this sport item corresponds to the active sport
                if (item.onclick.toString().includes(`'${activeSport}'`)) {
                    item.classList.add('active');
                } else {
                    item.classList.remove('active');
                }
            });
        }

        // Events loading functions - ENHANCED FOR LIVE PRE-MARKET ODDS
        let loadingEvents = {}; // Guard against multiple simultaneous loads
        
        async function loadEvents(sport, forceRefresh = false, retryCount = 0) {
            console.log(`🔍 DEBUG loadEvents called: sport=${sport}, forceRefresh=${forceRefresh}, retryCount=${retryCount}`);
            
            // Temporarily disable the guard to fix the issue
            // // Prevent multiple simultaneous loads for the same sport
            // if (loadingEvents[sport]) {
            //     console.log(`🚫 Already loading events for ${sport}, skipping duplicate request`);
            //     return;
            // }
            
            // loadingEvents[sport] = true;
            
            try {
                // Show loading state
                document.getElementById('eventsContent').innerHTML = '<div class="loading-text">Loading events...</div>';
                
                // Check if we have cached data and it's recent (less than 30 minutes old for better performance)
                const cacheKey = `events_cache_${sport}`;
                const cachedData = localStorage.getItem(cacheKey);
                const cacheTimestamp = localStorage.getItem(`${cacheKey}_timestamp`);
                const now = Date.now();
                const cacheAge = now - (parseInt(cacheTimestamp) || 0);
                const cacheValid = cacheAge < 1800000; // 30 minutes cache (increased from 5 minutes)
                
                if (!forceRefresh && cachedData && cacheValid) {
                    console.log(`📦 Using cached events for ${sport} (age: ${Math.round(cacheAge/1000)}s)`);
                                    eventsData[sport] = JSON.parse(cachedData);
                window.eventsData[sport] = eventsData[sport]; // Sync with global
                console.log(`🔍 DEBUG: eventsData[${sport}] set from cache to:`, eventsData[sport]);
                    console.log(`🔍 DEBUG: eventsData keys after cache:`, Object.keys(eventsData));
                    displayEvents();
                    updateBettingMarkets();
                    
                    // Hide loading indicator since we're using cached data
                    hideLoadingIndicator();
                    
                    // INTELLIGENT LIVE UPDATE: Check odds status first, then fetch if updated
                    // This ensures we only fetch when there are actual updates
                    setTimeout(async () => {
                        try {
                            console.log(`🔍 INTELLIGENT UPDATE: Checking odds status for ${sport}...`);
                            console.log(`🔍 INTELLIGENT UPDATE: This should call /api/sports/odds-status/${sport}`);
                            
                            // First check if odds have been updated
                            console.log(`🔍 INTELLIGENT UPDATE: Calling /api/sports/odds-status/${sport}`);
                            const statusResponse = await fetch(`${API_BASE}/api/sports/odds-status/${sport}`, {
                                credentials: 'include'
                            });
                            console.log(`🔍 INTELLIGENT UPDATE: Status response received:`, statusResponse.status);
                            
                            if (statusResponse.ok) {
                                const statusData = await statusResponse.json();
                                console.log(`Odds status for ${sport}:`, statusData);
                                
                                if (statusData.has_data && statusData.last_updated) {
                                    // Check if our cache is older than the backend update
                                    const backendTimestamp = new Date(statusData.last_updated).getTime();
                                    const localCacheTimestamp = parseInt(cacheTimestamp) || 0;
                                    
                                    if (backendTimestamp > localCacheTimestamp) {
                                        console.log(`🎯 New odds detected for ${sport}! Backend updated at ${statusData.last_updated}, cache is from ${new Date(localCacheTimestamp).toISOString()}`);
                                        
                                        // Fetch fresh data
                                        const liveResponse = await fetch(`${API_BASE}/api/sports/events/${sport}`, {
                                            credentials: 'include'
                                        });
                                        
                                        if (liveResponse.ok) {
                                            const liveData = await liveResponse.json();
                                            
                                            if (liveData && liveData.length > 0) {
                                                console.log(`🎯 Live pre-market odds fetched for ${sport}! Updating frontend immediately...`);
                                                
                                                // Update cache with fresh data
                                                localStorage.setItem(cacheKey, JSON.stringify(liveData));
                                                localStorage.setItem(`${cacheKey}_timestamp`, Date.now().toString());
                                                
                                                // Update memory cache
                                                eventsData[sport] = liveData;
                                                window.eventsData[sport] = liveData; // Sync with global
                                                
                                                // IMMEDIATE FRONTEND UPDATE for live odds
                                                displayEvents();
                                                updateBettingMarkets();
                                                
                                                console.log(`✅ Frontend updated with live pre-market odds for ${sport}`);
                                            }
                                        }
                                    } else {
                                        console.log(`ℹ️ Cache is up-to-date for ${sport} (backend: ${statusData.last_updated}, cache: ${new Date(localCacheTimestamp).toISOString()})`);
                                    }
                                } else {
                                    console.log(`ℹ️ No odds data available for ${sport}`);
                                }
                            }
                        } catch (error) {
                            console.log(`Background odds status check failed for ${sport}:`, error);
                        }
                    }, 2000); // Check after 2 seconds for immediate responsiveness
                    
                    return;
                }
                
                console.log(`🔄 Loading events for ${sport}...`);
                const response = await fetch(`${API_BASE}/api/sports/events/${sport}`, {
                    credentials: 'include' // Include cookies for session
                });
                
                console.log('Events response status:', response.status);
                
                if (response.ok) {
                    const freshData = await response.json();
                    console.log(`Events data for ${sport}:`, freshData);
                    console.log(`🔍 DEBUG loadEvents: sport=${sport}, dataLength=${freshData ? freshData.length : 'undefined'}`);
                    
                    // Check if we got valid data
                    if (!freshData || freshData.length === 0) {
                        // If no data and this is a retry, show a more helpful message
                        if (retryCount > 0) {
                            document.getElementById('eventsContent').innerHTML = '<div class="loading-text">No events available for this sport at the moment. Please try again later.</div>';
                            hideLoadingIndicator();
                            return;
                        }
                        
                        // First attempt with no data - retry after a short delay (backend might still be initializing)
                        console.log(`⚠️ No events data received for ${sport}, retrying in 2 seconds... (attempt ${retryCount + 1})`);
                        setTimeout(() => {
                            loadEvents(sport, forceRefresh, retryCount + 1);
                        }, 2000);
                        return;
                    }
                    
                    // IMMEDIATE FRONTEND UPDATE: Show data as soon as it's parsed
                    eventsData[sport] = freshData;
                    window.eventsData[sport] = freshData; // Sync with global
                    console.log(`🔍 DEBUG: eventsData[${sport}] set to:`, eventsData[sport]);
                    console.log(`🔍 DEBUG: eventsData keys after setting:`, Object.keys(eventsData));
                    displayEvents();
                    updateBettingMarkets();
                    
                    // Cache the data for persistence across manual refreshes
                    localStorage.setItem(cacheKey, JSON.stringify(freshData));
                    localStorage.setItem(`${cacheKey}_timestamp`, now.toString());
                    
                    // Check if events have odds
                    if (freshData && freshData.length > 0) {
                        const firstEvent = freshData[0];
                        console.log('First event structure:', firstEvent);
                        if (firstEvent.odds) {
                            console.log('Available odds markets:', Object.keys(firstEvent.odds));
                            
                            // IMMEDIATE NOTIFICATION: Pre-market odds successfully loaded
                            console.log(`🎯 Pre-market odds successfully parsed for ${sport}! Frontend updated immediately.`);
                        } else {
                            console.log('❌ No odds object found in events');
                        }
                    }
                    
                    // Hide loading indicator
                    hideLoadingIndicator();
                    
                } else {
                    // HTTP error - retry if this is the first attempt
                    if (retryCount === 0) {
                        console.log(`⚠️ HTTP ${response.status} error for ${sport}, retrying in 2 seconds...`);
                        setTimeout(() => {
                            loadEvents(sport, forceRefresh, retryCount + 1);
                        }, 2000);
                        return;
                    }
                    
                    // Max retries reached, show error
                    console.error(`Failed to load events for ${sport} after ${retryCount + 1} attempts:`, response.status);
                    document.getElementById('eventsContent').innerHTML = `<div class="loading-text">Error loading events: ${response.status}. Please refresh the page.</div>`;
                    hideLoadingIndicator();
                }
                
            } catch (error) {
                console.error(`Error loading events for ${sport}:`, error);
                
                // Retry on network errors if this is the first attempt
                if (retryCount === 0) {
                    console.log(`⚠️ Network error for ${sport}, retrying in 2 seconds...`);
                    setTimeout(() => {
                        loadEvents(sport, forceRefresh, retryCount + 1);
                    }, 2000);
                    return;
                }
                
                // Max retries reached, show error
                document.getElementById('eventsContent').innerHTML = `<div class="loading-text">Network error: ${error.message}. Please check your connection and refresh.</div>`;
                hideLoadingIndicator();
            } finally {
                // Always clear the loading flag (disabled)
                // loadingEvents[sport] = false;
            }
        }
        
        // Convert GoalServe odds structure to frontend format
        function convertGoalServeOdds(oddsArray) {
            const convertedOdds = {};
            
            if (!Array.isArray(oddsArray)) {
                console.warn('Odds array is not an array:', oddsArray);
                return convertedOdds;
            }
            
            oddsArray.forEach(oddsGroup => {
                // Handle 3Way Result (Home, Draw, Away) - most sports
                if (oddsGroup.value === '3Way Result' || oddsGroup.value === 'Match Winner') {
                    if (oddsGroup.bookmakers && oddsGroup.bookmakers.length > 0) {
                        const bookmaker = oddsGroup.bookmakers[0]; // Use first bookmaker
                        if (bookmaker.odds && bookmaker.odds.length >= 3) {
                            // Find Home, Draw, Away odds
                            let homeOdds = 0, drawOdds = 0, awayOdds = 0;
                            
                            bookmaker.odds.forEach(odd => {
                                if (odd.name === 'Home') homeOdds = parseFloat(odd.value) || 0;
                                else if (odd.name === 'Draw') drawOdds = parseFloat(odd.value) || 0;
                                else if (odd.name === 'Away') awayOdds = parseFloat(odd.value) || 0;
                            });
                            
                            convertedOdds['match_result'] = {
                                '1': homeOdds,
                                'X': drawOdds,  // Note: Using 'X' (capital) to match the frontend logic
                                '2': awayOdds
                            };
                        }
                    }
                }
                // Handle Home/Away (2-way) - for sports like tennis that don't have draws
                else if (oddsGroup.value === 'Home/Away') {
                    if (oddsGroup.bookmakers && oddsGroup.bookmakers.length > 0) {
                        const bookmaker = oddsGroup.bookmakers[0]; // Use first bookmaker
                        if (bookmaker.odds && bookmaker.odds.length >= 2) {
                            convertedOdds['match_result'] = {
                                '1': parseFloat(bookmaker.odds[0].value) || 0,
                                'X': 0, // Draw not applicable for 2-way sports
                                '2': parseFloat(bookmaker.odds[1].value) || 0
                            };
                        }
                    }
                }
                // Add more market conversions as needed
            });
            
            console.log('Converted odds:', convertedOdds);
            return convertedOdds;
        }

        // Helper function to safely convert odds to numbers and prevent NaN
        function toNum(x) {
            if (x == null || x === '') return null;
            const s = String(x).trim().replace(',', '.');
            const n = Number.parseFloat(s);
            return Number.isFinite(n) ? n : null;
        }

        // Enhanced odds parsing that's resilient to NaN
        function parseOddsSafely(rawOdds) {
            if (!rawOdds) return [];
            if (Array.isArray(rawOdds)) {
                return rawOdds.map(toNum).filter(v => v != null);
            }
            if (typeof rawOdds === 'object') {
                const home = toNum(rawOdds.home ?? rawOdds.H ?? rawOdds['1']);
                const draw = toNum(rawOdds.draw ?? rawOdds.D ?? rawOdds['X'] ?? rawOdds.tie);
                const away = toNum(rawOdds.away ?? rawOdds.A ?? rawOdds['2']);
                return [home, draw, away].filter(v => v != null);
            }
            return [];
        }
        


        async function loadLiveOddsForEvents(liveEvents) {
            // Use JSON data instead of fetching live odds
            console.log('Using JSON data for odds');
            try {
                // Reload events from JSON data
                await loadEvents(currentSport);
                console.log('Events loaded from JSON successfully');
                displayEvents();
            } catch (error) {
                console.error('Error loading events from JSON:', error);
                displayEvents();
            }
        }

        // --- More tolerant date parser for GoalServe formats ---
        // - Accepts "DD.MM.YYYY", "DD.MM" (assume current year, roll to next year if already passed)
        // - Accepts "YYYY-MM-DD"
        // - Accepts time "HH:MM" or missing (defaults to 00:00)
        function parseFlexibleEventDateTime(dateStr, timeStr) {
            if (!dateStr) return null;

            const now = new Date();
            const ds = String(dateStr).trim();

            let dd, mm, yyyy;

            if (/^\d{2}\.\d{2}\.\d{4}$/.test(ds)) {
                const [d, m, y] = ds.split('.').map(Number);
                dd = d; mm = m; yyyy = y;
                console.log(`🔍 Date parsed as DD.MM.YYYY: ${dd}.${mm}.${yyyy}`);
            } else if (/^\d{2}\.\d{2}$/.test(ds)) {
                const [d, m] = ds.split('.').map(Number);
                dd = d; mm = m; yyyy = now.getFullYear();
                console.log(`🔍 Date parsed as DD.MM (assumed year): ${dd}.${mm}.${yyyy}`);
            } else if (/^\d{4}-\d{2}-\d{2}$/.test(ds)) {
                const [y, m, d] = ds.split('-').map(Number);
                yyyy = y; mm = m; dd = d;
                console.log(`🔍 Date parsed as YYYY-MM-DD: ${yyyy}-${mm}-${dd}`);
            } else {
                // Unknown format — let other code paths handle or drop it
                console.warn(`⚠️ Unknown date format: "${ds}"`);
                return null;
            }

            let HH = 0, MM = 0;
            if (typeof timeStr === 'string') {
                const m = timeStr.match(/^(\d{1,2}):(\d{2})/);
                if (m) { HH = Number(m[1]); MM = Number(m[2]); }
            }
            console.log(`🔍 Time parsed: ${HH}:${MM} (from "${timeStr}")`);

            const dt = new Date(yyyy, (mm - 1), dd, HH, MM, 0, 0);
            if (Number.isNaN(dt.getTime())) return null;

            // If no year was provided (DD.MM) and we landed in the past, assume next year.
            if (/^\d{2}\.\d{2}$/.test(ds) && dt.getTime() < now.getTime() - 24 * 60 * 60 * 1000) {
                dt.setFullYear(yyyy + 1);
                console.log(`🔍 Adjusted to next year: ${dt.toISOString()}`);
            }
            console.log(`🔍 Final parsed date: ${dt.toISOString()}`);
            return dt;
        }

        // Keep the old function name for backward compatibility
        function parseEventDateTime(dateStr, timeStr) {
            return parseFlexibleEventDateTime(dateStr, timeStr);
        }

        let displayEventsInProgress = false;
        
        function displayEvents() {
            // Temporarily disable the guard to fix the issue
            // if (displayEventsInProgress) {
            //     console.log('🚫 Display events already in progress, skipping...');
            //     return;
            // }
            
            // displayEventsInProgress = true;
            
            console.log('🔍 DEBUG displayEvents:', {
                currentSport: currentSport,
                eventsDataKeys: Object.keys(eventsData),
                eventsDataCurrentSport: eventsData[currentSport],
                eventsDataLength: eventsData[currentSport] ? eventsData[currentSport].length : 'undefined'
            });
            
            const events = eventsData[currentSport] || [];
            const container = document.getElementById('eventsContent');
            
            // Filter out completed and cancelled matches
            let activeEvents = events.filter(event => !event.is_completed && !event.is_cancelled);
            
            // Tolerant future filter — accept DD.MM (assume year), allow missing time
            const now = new Date();
            console.log(`🔍 Filtering ${activeEvents.length} events for future dates (now: ${now.toISOString()})`);
            
            activeEvents = activeEvents.filter(event => {
                if (!event?.date) {
                    console.log(`⚠️ Event skipped - no date:`, event);
                    return false; // need a date at least
                }
                try {
                    const dt = parseFlexibleEventDateTime(event.date, event.time);
                    const isFuture = dt && dt.getTime() > now.getTime();
                    if (!isFuture) {
                        console.log(`⚠️ Event skipped - not in future: ${event.date} ${event.time} -> ${dt?.toISOString()}`);
                    }
                    return isFuture;
                } catch (e) {
                    console.warn('Date parse failed for event:', event, e);
                    return false;
                }
            });
            console.log(`🔍 After future filter: ${activeEvents.length} events remaining`);
            
            // Apply current search filter if exists
            if (currentSearchTerm && currentSearchTerm.trim() !== '') {
                const searchTerm = currentSearchTerm.toLowerCase().trim();
                activeEvents = activeEvents.filter(event => {
                    const homeTeam = event.home_team?.toLowerCase() || '';
                    const awayTeam = event.away_team?.toLowerCase() || '';
                    const league = event.league?.toLowerCase() || '';
                    const venue = event.venue?.toLowerCase() || '';
                    
                    return homeTeam.includes(searchTerm) ||
                           awayTeam.includes(searchTerm) ||
                           league.includes(searchTerm) ||
                           venue.includes(searchTerm) ||
                           `${homeTeam} ${awayTeam}`.includes(searchTerm) ||
                           `${awayTeam} ${homeTeam}`.includes(searchTerm);
                });
            }
            
            if (activeEvents.length === 0) {
                if (currentSearchTerm && currentSearchTerm.trim() !== '') {
                    container.innerHTML = `<div class="loading-text">No future events found for "${currentSearchTerm}"</div>`;
                } else {
                    container.innerHTML = '<div class="loading-text">No future events found for this sport</div>';
                }
                return;
            }
            
            // Sort events chronologically (live matches first, then by date/time)
            const sortedEvents = activeEvents.sort((a, b) => {
                // Live matches come first
                if (a.is_live && !b.is_live) return -1;
                if (!a.is_live && b.is_live) return 1;
                
                // Then sort by date and time using proper parsing
                const dateA = parseEventDateTime(a.date, a.time);
                const dateB = parseEventDateTime(b.date, b.time);
                
                if (!dateA && !dateB) return 0;
                if (!dateA) return 1;
                if (!dateB) return -1;
                
                return dateA.getTime() - dateB.getTime();
            });
            
            // Store current events globally for market filtering
            window.currentEvents = sortedEvents;
            
            // Update filter counts
            updateFilterCounts(sortedEvents);
            
            // Restore search input state
            restoreSearchState();
            
            // Use atomic table swapping to prevent empty table flashing
            console.log(`🔍 DEBUG: About to render table with ${sortedEvents.length} events, currentView: ${currentView}`);
            if (currentView === 'list') {
                console.log(`🔍 DEBUG: Calling swapTableAtomically with displayListView`);
                swapTableAtomically((buffer) => {
                    console.log(`🔍 DEBUG: Inside swapTableAtomically callback, calling displayListView`);
                    displayListView(sortedEvents, buffer);
                    console.log(`🔍 DEBUG: displayListView completed`);
                });
            } else {
                console.log(`🔍 DEBUG: Calling swapTableAtomically with displayCouponView`);
                swapTableAtomically((buffer) => {
                    console.log(`🔍 DEBUG: Inside swapTableAtomically callback, calling displayCouponView`);
                    displayCouponView(sortedEvents, buffer);
                    console.log(`🔍 DEBUG: displayCouponView completed`);
                });
            }
            
            // Clear the progress flag (disabled)
            // displayEventsInProgress = false;
        }

        function updateFilterCounts(events) {
            // Filter out completed and cancelled events for counts
            const activeEvents = events.filter(event => !event.is_completed && !event.is_cancelled);
            
            console.log('🔍 DEBUG: updateFilterCounts called with', activeEvents.length, 'active events');
            if (activeEvents.length > 0) {
                console.log('🔍 DEBUG: Sample event date format:', activeEvents[0].date, 'Type:', typeof activeEvents[0].date);
            }
            
            const liveEvents = activeEvents.filter(event => event.is_live);
            const todayEvents = activeEvents.filter(event => {
                try {
                    // Handle different date formats from GoalServe API
                    let eventDate;
                    const currentYear = new Date().getFullYear();
                    
                    if (event.date && event.date.includes('.')) {
                        // Format: "07.08.2025" or "07.08"
                        const dateParts = event.date.split('.');
                        if (dateParts.length === 3) {
                            // Full date: "07.08.2025"
                            const day = parseInt(dateParts[0]);
                            const month = parseInt(dateParts[1]) - 1; // Month is 0-indexed
                            const year = parseInt(dateParts[2]);
                            eventDate = new Date(year, month, day);
                        } else if (dateParts.length === 2) {
                            // Partial date: "07.08" - assume current year
                            const day = parseInt(dateParts[0]);
                            const month = parseInt(dateParts[1]) - 1;
                            eventDate = new Date(currentYear, month, day);
                        }
                    } else if (event.date) {
                        // Try other formats like "Aug 05"
                        const dateTimeStr = `${event.date} ${currentYear}`;
                        eventDate = new Date(dateTimeStr);
                        
                        // If the event date is in the past, it might be next year
                        if (!isNaN(eventDate.getTime())) {
                            const now = new Date();
                            if (eventDate < now) {
                                eventDate.setFullYear(currentYear + 1);
                            }
                        }
                    }
                    
                    if (!eventDate || isNaN(eventDate.getTime())) {
                        console.warn('Could not parse date for event:', event.date, event);
                        return false;
                    }
                    
                    const today = new Date();
                    return eventDate.toDateString() === today.toDateString();
                } catch (error) {
                    console.error('Error parsing date for event:', event.date, error);
                    return false;
                }
            });
            const tomorrowEvents = activeEvents.filter(event => {
                try {
                    // Handle different date formats from GoalServe API
                    let eventDate;
                    const currentYear = new Date().getFullYear();
                    
                    if (event.date && event.date.includes('.')) {
                        // Format: "07.08.2025" or "07.08"
                        const dateParts = event.date.split('.');
                        if (dateParts.length === 3) {
                            // Full date: "07.08.2025"
                            const day = parseInt(dateParts[0]);
                            const month = parseInt(dateParts[1]) - 1; // Month is 0-indexed
                            const year = parseInt(dateParts[2]);
                            eventDate = new Date(year, month, day);
                        } else if (dateParts.length === 2) {
                            // Partial date: "07.08" - assume current year
                            const day = parseInt(dateParts[0]);
                            const month = parseInt(dateParts[1]) - 1;
                            eventDate = new Date(currentYear, month, day);
                        }
                    } else if (event.date) {
                        // Try other formats like "Aug 05"
                        const dateTimeStr = `${event.date} ${currentYear}`;
                        eventDate = new Date(dateTimeStr);
                        
                        // If the event date is in the past, it might be next year
                        if (!isNaN(eventDate.getTime())) {
                            const now = new Date();
                            if (eventDate < now) {
                                eventDate.setFullYear(currentYear + 1);
                            }
                        }
                    }
                    
                    if (!eventDate || isNaN(eventDate.getTime())) {
                        console.warn('Could not parse date for event:', event.date, event);
                        return false;
                    }
                    
                    const tomorrow = new Date();
                    tomorrow.setDate(tomorrow.getDate() + 1);
                    return eventDate.toDateString() === tomorrow.toDateString();
                } catch (error) {
                    console.error('Error parsing date for event:', event.date, error);
                    return false;
                }
            });

            document.getElementById('liveCount').textContent = liveEvents.length;
            document.getElementById('todayCount').textContent = todayEvents.length;
            document.getElementById('tomorrowCount').textContent = tomorrowEvents.length;
        }

        function filterLiveEvents() {
            const events = eventsData[currentSport] || [];
            const activeEvents = events.filter(event => !event.is_completed && !event.is_cancelled);
            const liveEvents = activeEvents.filter(event => event.is_live);
            
            // Sort live events by time
            const sortedLiveEvents = liveEvents.sort((a, b) => {
                const dateA = new Date(a.date + ' ' + new Date().getFullYear() + ' ' + a.time);
                const dateB = new Date(b.date + ' ' + new Date().getFullYear() + ' ' + b.time);
                return dateA - dateB;
            });
            
            displayListView(sortedLiveEvents, document.getElementById('eventsContent'));
        }

        function filterTodayEvents() {
            const events = eventsData[currentSport] || [];
            const activeEvents = events.filter(event => !event.is_completed && !event.is_cancelled);
            const todayEvents = activeEvents.filter(event => {
                try {
                    // Handle different date formats from GoalServe API
                    let eventDate;
                    const currentYear = new Date().getFullYear();
                    
                    if (event.date && event.date.includes('.')) {
                        // Format: "07.08.2025" or "07.08"
                        const dateParts = event.date.split('.');
                        if (dateParts.length === 3) {
                            // Full date: "07.08.2025"
                            const day = parseInt(dateParts[0]);
                            const month = parseInt(dateParts[1]) - 1; // Month is 0-indexed
                            const year = parseInt(dateParts[2]);
                            eventDate = new Date(year, month, day);
                        } else if (dateParts.length === 2) {
                            // Partial date: "07.08" - assume current year
                            const day = parseInt(dateParts[0]);
                            const month = parseInt(dateParts[1]) - 1;
                            eventDate = new Date(currentYear, month, day);
                        }
                    } else if (event.date) {
                        // Try other formats like "Aug 05"
                        const dateTimeStr = `${event.date} ${currentYear}`;
                        eventDate = new Date(dateTimeStr);
                        
                        // If the event date is in the past, it might be next year
                        if (!isNaN(eventDate.getTime())) {
                            const now = new Date();
                            if (eventDate < now) {
                                eventDate.setFullYear(currentYear + 1);
                            }
                        }
                    }
                    
                    if (!eventDate || isNaN(eventDate.getTime())) {
                        console.warn('Could not parse date for event:', event.date, event);
                        return false;
                    }
                    
                    const today = new Date();
                    return eventDate.toDateString() === today.toDateString();
                } catch (error) {
                    console.error('Error parsing date for event:', event.date, error);
                    return false;
                }
            });
            
            // Sort today's events chronologically
            const sortedTodayEvents = todayEvents.sort((a, b) => {
                try {
                    const dateA = new Date(a.date + ' ' + new Date().getFullYear() + ' ' + a.time);
                    const dateB = new Date(b.date + ' ' + new Date().getFullYear() + ' ' + b.time);
                    return dateA - dateB;
                } catch (error) {
                    console.error('Error sorting today events:', error);
                    return 0;
                }
            });
            
            displayListView(sortedTodayEvents, document.getElementById('eventsContent'));
        }

        function filterTomorrowEvents() {
            const events = eventsData[currentSport] || [];
            const activeEvents = events.filter(event => !event.is_completed && !event.is_cancelled);
            const tomorrowEvents = activeEvents.filter(event => {
                try {
                    // Handle different date formats from GoalServe API
                    let eventDate;
                    const currentYear = new Date().getFullYear();
                    
                    if (event.date && event.date.includes('.')) {
                        // Format: "07.08.2025" or "07.08"
                        const dateParts = event.date.split('.');
                        if (dateParts.length === 3) {
                            // Full date: "07.08.2025"
                            const day = parseInt(dateParts[0]);
                            const month = parseInt(dateParts[1]) - 1; // Month is 0-indexed
                            const year = parseInt(dateParts[2]);
                            eventDate = new Date(year, month, day);
                        } else if (dateParts.length === 2) {
                            // Partial date: "07.08" - assume current year
                            const day = parseInt(dateParts[0]);
                            const month = parseInt(dateParts[1]) - 1;
                            eventDate = new Date(currentYear, month, day);
                        }
                    } else if (event.date) {
                        // Try other formats like "Aug 05"
                        const dateTimeStr = `${event.date} ${currentYear}`;
                        eventDate = new Date(dateTimeStr);
                        
                        // If the event date is in the past, it might be next year
                        if (!isNaN(eventDate.getTime())) {
                            const now = new Date();
                            if (eventDate < now) {
                                eventDate.setFullYear(currentYear + 1);
                            }
                        }
                    }
                    
                    if (!eventDate || isNaN(eventDate.getTime())) {
                        console.warn('Could not parse date for event:', event.date, event);
                        return false;
                    }
                    
                    const tomorrow = new Date();
                    tomorrow.setDate(tomorrow.getDate() + 1);
                    return eventDate.toDateString() === tomorrow.toDateString();
                } catch (error) {
                    console.error('Error parsing date for event:', event.date, error);
                    return false;
                }
            });
            
            // Sort tomorrow's events chronologically
            const sortedTomorrowEvents = tomorrowEvents.sort((a, b) => {
                try {
                    const dateA = new Date(a.date + ' ' + new Date().getFullYear() + ' ' + a.time);
                    const dateB = new Date(b.date + ' ' + new Date().getFullYear() + ' ' + b.time);
                    return dateA - dateB;
                } catch (error) {
                    console.error('Error sorting tomorrow events:', error);
                    return 0;
                }
            });
            
            displayListView(sortedTomorrowEvents, document.getElementById('eventsContent'));
        }

        // Performance optimization: Debounced search
        let searchTimeout;
        function debouncedSearch(searchTerm) {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => {
                performSearch(searchTerm);
            }, 300); // 300ms delay
        }

        // Optimized search function
        function performSearch(searchTerm) {
            currentSearchTerm = searchTerm;
            if (currentView === 'list') {
                displayEvents(); // This will apply the search filter
            }
        }

        // Performance optimization: Cache for formatted times
        const timeFormatCache = new Map();
        
        // Optimized time formatting with caching
        function formatEventTime(event) {
            const cacheKey = `${event.date}_${event.time}`;
            if (timeFormatCache.has(cacheKey)) {
                return timeFormatCache.get(cacheKey);
            }
            
            // Handle the specific format from GoalServe API
            if (event.date && event.time) {
                try {
                    // Handle different date formats
                    let eventDate;
                    const currentYear = new Date().getFullYear();
                    
                    // Check if date is in "DD.MM.YYYY" format (like "07.08.2025")
                    if (event.date.includes('.')) {
                        const dateParts = event.date.split('.');
                        if (dateParts.length === 3) {
                            const day = parseInt(dateParts[0]);
                            const month = parseInt(dateParts[1]) - 1; // Month is 0-indexed
                            const year = parseInt(dateParts[2]);
                            eventDate = new Date(year, month, day);
                        }
                    } else {
                        // Handle "Aug 05" format
                        const dateTimeStr = `${event.date} ${currentYear} ${event.time}`;
                        eventDate = new Date(dateTimeStr);
                        
                        // If the event date is in the past, it might be next year
                        if (!isNaN(eventDate.getTime())) {
                            const now = new Date();
                            if (eventDate < now) {
                                eventDate.setFullYear(currentYear + 1);
                            }
                        }
                    }
                    
                    // Check if it's a valid date
                    if (!isNaN(eventDate.getTime())) {
                        // JSON time is always UTC - convert to local time
                        const timeParts = event.time.split(':');
                        const utcHour = parseInt(timeParts[0]);
                        const utcMinute = parseInt(timeParts[1]);
                        
                        // Create UTC date object
                        const utcDate = new Date(Date.UTC(
                            eventDate.getFullYear(),
                            eventDate.getMonth(),
                            eventDate.getDate(),
                            utcHour,
                            utcMinute
                        ));
                        
                        // Convert to user's local timezone using toLocaleString
                        const localTimeString = utcDate.toLocaleString('en-US', {
                            month: 'short',
                            day: 'numeric',
                            hour: '2-digit',
                            minute: '2-digit',
                            hour12: true,
                            timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone
                        });
                        
                        // Cache the result
                        timeFormatCache.set(cacheKey, localTimeString);
                        return localTimeString;
                    }
                } catch (e) {
                    console.log('Error parsing event time:', e);
                }
            }
            
            // Enhanced fallback for darts and other sports with formatted_date
            if (event.formatted_date && event.time) {
                try {
                    // Handle "DD.MM.YYYY" format from formatted_date
                    const dateParts = event.formatted_date.split('.');
                    if (dateParts.length === 3) {
                        const day = parseInt(dateParts[0]);
                        const month = parseInt(dateParts[1]) - 1; // Month is 0-indexed
                        const year = parseInt(dateParts[2]);
                        const eventDate = new Date(year, month, day);
                        
                        if (!isNaN(eventDate.getTime())) {
                            // Parse time as UTC and convert to local
                            const timeParts = event.time.split(':');
                            const utcHour = parseInt(timeParts[0]);
                            const utcMinute = parseInt(timeParts[1]);
                            
                            // Create UTC date object
                            const utcDate = new Date(Date.UTC(
                                eventDate.getFullYear(),
                                eventDate.getMonth(),
                                eventDate.getDate(),
                                utcHour,
                                utcMinute
                            ));
                            
                            // Convert to local time
                            const localTimeString = utcDate.toLocaleString('en-US', {
                                month: 'short',
                                day: 'numeric',
                                hour: '2-digit',
                                minute: '2-digit',
                                hour12: true,
                                timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone
                            });
                            
                            // Cache the result
                            timeFormatCache.set(cacheKey, localTimeString);
                            return localTimeString;
                        }
                    }
                } catch (e) {
                    console.log('Error parsing formatted_date:', e);
                }
            }
            
            // Fallback to original time or date
            let fallbackResult;
            if (event.date && event.time) {
                // Try to parse the time as UTC and convert to local
                try {
                    const timeParts = event.time.split(':');
                    const utcHour = parseInt(timeParts[0]);
                    const utcMinute = parseInt(timeParts[1]);
                    
                    // Create a simple date object for today with the time
                    const today = new Date();
                    const utcDate = new Date(Date.UTC(
                        today.getFullYear(),
                        today.getMonth(),
                        today.getDate(),
                        utcHour,
                        utcMinute
                    ));
                    
                    // Convert to local time
                    const localTimeString = utcDate.toLocaleString('en-US', {
                        month: 'short',
                        day: 'numeric',
                        hour: '2-digit',
                        minute: '2-digit',
                        hour12: true,
                        timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone
                    });
                    
                    fallbackResult = localTimeString;
                } catch (e) {
                    // If all else fails, just show the date
                    fallbackResult = event.date;
                }
            } else if (event.time) {
                fallbackResult = event.time;
            } else if (event.date) {
                fallbackResult = event.date;
            } else {
                fallbackResult = 'TBD';
            }
            
            // Cache the fallback result too
            timeFormatCache.set(cacheKey, fallbackResult);
            return fallbackResult;
        }

        // Performance optimization: Batch DOM updates
        function batchDOMUpdates(updates) {
            // Use requestAnimationFrame for smooth updates
            requestAnimationFrame(() => {
                updates.forEach(update => update());
            });
        }

        // Performance optimization: Lazy loading for events
        const EVENTS_PER_PAGE = 50;
        let currentPage = 0;
        let allEvents = [];

        function loadMoreEvents() {
            const startIndex = currentPage * EVENTS_PER_PAGE;
            const endIndex = startIndex + EVENTS_PER_PAGE;
            const eventsToShow = allEvents.slice(0, endIndex);
            
            displayEvents(eventsToShow);
            
            if (endIndex < allEvents.length) {
                // Show load more button
                const loadMoreBtn = document.createElement('button');
                loadMoreBtn.className = 'load-more-btn';
                loadMoreBtn.textContent = 'Load More Events';
                loadMoreBtn.onclick = () => {
                    currentPage++;
                    loadMoreEvents();
                };
                
                const container = document.getElementById('eventsContent');
                const existingBtn = container.querySelector('.load-more-btn');
                if (existingBtn) {
                    existingBtn.remove();
                }
                container.appendChild(loadMoreBtn);
            }
        }

        // Optimized displayEvents function
        let displayEventsOptimizedInProgress = false;
        
        function displayEvents(eventsToDisplay = null) {
            // Temporarily disable the guard to fix the issue
            // if (displayEventsOptimizedInProgress) {
            //     console.log('🚫 Display events (optimized) already in progress, skipping...');
            //     return;
            // }
            
            // displayEventsOptimizedInProgress = true;
            

            
            const events = eventsToDisplay || eventsData[currentSport] || [];
            const container = document.getElementById('eventsContent');
            
            // Debug: Log event structure for darts
            if (currentSport === 'darts' && events.length > 0) {
                console.log('🔍 Darts event structure:', events[0]);
                console.log('🔍 Darts event fields:', Object.keys(events[0]));
            }
            
            // Filter out completed, cancelled, and live matches (only show pre-match odds)
            let activeEvents = events.filter(event => {
                // Skip completed and cancelled matches
                if (event.is_completed || event.is_cancelled) return false;
                
                // Skip live matches - we only want pre-match odds
                if (event.status === 'Live' || event.status === 'LIVE' || 
                    event.status === 'HT' || event.status === 'FT' ||
                    event.status === 'Finished' || event.status === 'Final' ||
                    event.status === 'Ended' || event.status === 'Completed') {
                    return false;
                }
                
                return true;
            });
            
            // Tolerant future filter — accept DD.MM (assume year), allow missing time
            // FIXED: Convert local time to UTC for proper comparison with API event times
            const now = new Date();
            const nowUTC = new Date(now.getTime() + (now.getTimezoneOffset() * 60000));
            console.log(`🔍 [OPTIMIZED] Filtering ${activeEvents.length} events for future dates (local: ${now.toISOString()}, UTC: ${nowUTC.toISOString()})`);
            
            activeEvents = activeEvents.filter(event => {
                if (!event?.date) {
                    console.log(`⚠️ [OPTIMIZED] Event skipped - no date:`, event);
                    return false; // need a date at least
                }
                try {
                    const dt = parseFlexibleEventDateTime(event.date, event.time);
                    const isFuture = dt && dt.getTime() > nowUTC.getTime();
                    if (!isFuture) {
                        console.log(`⚠️ [OPTIMIZED] Event skipped - not in future: ${event.date} ${event.time} -> ${dt?.toISOString()} (UTC now: ${nowUTC.toISOString()})`);
                    }
                    return isFuture;
                } catch (e) {
                    console.warn('[OPTIMIZED] Date parse failed for event:', event, e);
                    return false;
                }
            });
            console.log(`🔍 [OPTIMIZED] After future filter: ${activeEvents.length} events remaining`);
            
            // Apply current search filter if exists
            if (currentSearchTerm && currentSearchTerm.trim() !== '') {
                const searchTerm = currentSearchTerm.toLowerCase().trim();
                activeEvents = activeEvents.filter(event => {
                    const homeTeam = event.home_team?.toLowerCase() || '';
                    const awayTeam = event.away_team?.toLowerCase() || '';
                    const league = event.league?.toLowerCase() || '';
                    const venue = event.venue?.toLowerCase() || '';
                    
                    return homeTeam.includes(searchTerm) ||
                           awayTeam.includes(searchTerm) ||
                           league.includes(searchTerm) ||
                           venue.includes(searchTerm) ||
                           `${homeTeam} ${awayTeam}`.includes(searchTerm) ||
                           `${awayTeam} ${homeTeam}`.includes(searchTerm);
                });
            }
            
            if (activeEvents.length === 0) {
                if (currentSearchTerm && currentSearchTerm.trim() !== '') {
                    container.innerHTML = `<div class="loading-text">No events found for "${currentSearchTerm}"</div>`;
                } else {
                    container.innerHTML = '<div class="loading-text">No active events found for this sport</div>';
                }
                return;
            }
            
            // Sort events chronologically by date/time (no live matches to prioritize)
            const sortedEvents = activeEvents.sort((a, b) => {
                // Sort by date and time using proper parsing
                const dateA = parseEventDateTime(a.date, a.time);
                const dateB = parseEventDateTime(b.date, b.time);
                
                if (!dateA && !dateB) return 0;
                if (!dateA) return 1;
                if (!dateB) return -1;
                
                return dateA.getTime() - dateB.getTime();
            });
            
            // Store current events globally for market filtering
            window.currentEvents = sortedEvents;
            allEvents = sortedEvents; // Store for lazy loading
            currentPage = 0; // Reset pagination
            
            // Update filter counts
            updateFilterCounts(sortedEvents);
            
            // Restore search input state
            restoreSearchState();
            
            // Use lazy loading for large lists
            if (sortedEvents.length > EVENTS_PER_PAGE) {
                loadMoreEvents();
            } else {
                // Use atomic table swapping to prevent empty table flashing
                if (currentView === 'list') {
                    swapTableAtomically((buffer) => {
                        displayListView(sortedEvents, buffer);
                    });
                } else {
                    swapTableAtomically((buffer) => {
                        displayCouponView(sortedEvents, buffer);
                    });
                }
            }
            
            // Clear the progress flag (disabled)
            // displayEventsOptimizedInProgress = false;
        }

        // Helper function to get sport-specific column headers
        function getOddsColumns() {
            console.log(`🎯 getOddsColumns called - currentSport: ${currentSport}, currentMarket: ${currentMarket}`);
            
            // Special handling for baseball - only show configured markets
            if (currentSport === 'baseball') {
                switch (currentMarket) {
                    case 'match_result':
                        return getSportSpecificHeaders();
                    case 'correct_score':
                        return '<div>1-0</div><div>2-0</div><div>2-1</div>';
                    case 'odd_even_including_ot':
                        return '<div>Odd</div><div>Even</div>';
                    default:
                        return ''; // Hide invalid markets for baseball
                }
            }
            
            // Special handling for cricket markets
            if (currentSport === 'cricket') {
                switch (currentMarket) {
                    case 'home_away':
                        return '<div>1</div><div>2</div>';
                    case 'most_sixes':
                    case 'most_fours':
                    case 'most_run_outs':
                        return '<div>1</div><div>X</div><div>2</div>';
                    default:
                        return '';
                }
            }
            
            // Special handling for basketball - ensure odd_even_including_ot shows Odd/Even
            if (currentSport === 'basketball' && currentMarket === 'odd_even_including_ot') {
                console.log('🏀 Basketball odd_even_including_ot detected - returning Odd/Even');
                return '<div>Odd</div><div>Even</div>';
            }
            
            // Hardcoded fix for basketball odd/even market - check if it contains "odd" or "even"
            if (currentSport === 'basketball' && (currentMarket.includes('odd') || currentMarket.includes('even'))) {
                console.log('🏀 Basketball odd/even market detected - returning Odd/Even');
                return '<div>Odd</div><div>Even</div>';
            }
            
            // Debug: Log all available markets for basketball
            if (currentSport === 'basketball') {
                console.log('🏀 Basketball detected - checking available markets...');
                console.log('🏀 Current market:', currentMarket);
                console.log('🏀 Current sport:', currentSport);
                if (eventsData[currentSport]) {
                    const events = eventsData[currentSport];
                    events.forEach((event, index) => {
                        if (event.odds) {
                            console.log(`🏀 Event ${index} markets:`, Object.keys(event.odds));
                            if (event.odds[currentMarket]) {
                                console.log(`🏀 Event ${index} odds for ${currentMarket}:`, event.odds[currentMarket]);
                            }
                        }
                    });
                }
            }
            
            // For other sports, use existing logic
            switch (currentMarket) {
                case 'match_result':
                case 'home_away':
                    return getSportSpecificHeaders();
                case 'both_teams_score':
                case 'clean_sheet_home':
                case 'clean_sheet_away':
                case 'win_to_nil_home':
                case 'win_to_nil_away':
                case 'team_to_score_first':
                case 'home_team_score_goal':
                case 'away_team_score_goal':
                case 'odd_even':
                case 'odd_even_first_half':
                case 'odd_even_first_set':
                case 'odd_even_including_ot':
                    console.log(`🎯 General odd_even case hit for ${currentSport} - ${currentMarket}`);
                    return '<div>Odd</div><div>Even</div>';
                case 'to_qualify':
                case 'tie_break_first_set':
                case 'win_one_set_player1':
                case 'win_one_set_player2':
                    return '<div>Yes</div><div>No</div>';
                case 'correct_score':
                case 'correct_score_first_half':
                case 'correct_score_second_half':
                    return '<div>1-0</div><div>2-0</div><div>2-1</div>';
                case 'asian_handicap':
                case 'asian_handicap_first_half':
                case 'asian_handicap_first_quarter':
                case 'asian_handicap_sets':
                case 'asian_handicap_games':
                case 'first_set':
                case 'second_set':
                case 'first_half_winner':
                case 'first_quarter_winner':
                case 'second_half_winner':
                    return '<div>Home</div><div>Away</div>';
                case 'over_under':
                case 'over_under_first_half':
                case 'over_under_first_quarter':
                case 'over_under_first_set':
                case 'games_over_under':
                case 'corners_over_under':
                    return '<div>Over</div><div>Under</div>';
                case 'set_betting':
                    return '<div>2-0</div><div>2-1</div><div>0-2</div>';
                case 'handicap_result':
                    return '<div>Home</div><div>Draw</div><div>Away</div>';
                case 'highest_scoring_half':
                case 'highest_scoring_quarter':
                    return '<div>1st</div><div>2nd</div><div>3rd</div>';
                case 'double_chance':
                case 'double_chance_first_half':
                case 'double_chance_second_half':
                    return '<div>1X</div><div>X2</div><div>12</div>';
                case 'win_both_halves':
                    return '<div>Yes</div><div>No</div>';
                case 'both_teams_score_first_half':
                case 'both_teams_score_second_half':
                    return '<div>Yes</div><div>No</div>';
                case 'results_both_teams_score':
                    return '<div>1/Yes</div><div>X/Yes</div><div>2/Yes</div>';
                case 'result_total_goals':
                    return '<div>1/Over</div><div>X/Over</div><div>2/Over</div>';
                case 'corners_1x2':
                    return '<div>Home</div><div>Draw</div><div>Away</div>';
                case 'ht_ft_double':
                    return '<div>1/1</div><div>1/X</div><div>1/2</div>';
                case 'first_half_3way_result':
                    return '<div>1</div><div>X</div><div>2</div>';
                default:
                    return getSportSpecificHeaders();
            }
        }

        // Optimized displayListView with virtual scrolling concept
        function displayListView(events, container) {
            // Filter out events that don't have odds for the current market
            const eventsWithOdds = events.filter(event => {
                if (!event.odds) return false;
                
                // For match_result (main market), check if event has match_result or home_away odds
                if (currentMarket === 'match_result') {
                    const hasMatchResultOdds = event.odds.match_result && 
                        Array.isArray(event.odds.match_result) && 
                        event.odds.match_result.length > 0;
                    const hasHomeAwayOdds = event.odds.home_away && 
                        Array.isArray(event.odds.home_away) && 
                        event.odds.home_away.length > 0;
                    return hasMatchResultOdds || hasHomeAwayOdds;
                }
                
                // For secondary markets, check if the event has odds for the current market
                const hasOddsForCurrentMarket = event.odds[currentMarket] && 
                    Array.isArray(event.odds[currentMarket]) && 
                    event.odds[currentMarket].length > 0;
                
                // Additional check: ensure the odds actually have valid values
                if (hasOddsForCurrentMarket) {
                    const marketData = event.odds[currentMarket];
                    // Check if any of the odds values are valid (not null, undefined, or empty strings)
                    return marketData.some(oddsValue => 
                        oddsValue !== null && 
                        oddsValue !== undefined && 
                        oddsValue !== '' && 
                        parseFloat(oddsValue) > 0
                    );
                }
                
                return hasOddsForCurrentMarket;
            });
            
            console.log(`Filtered events: ${eventsWithOdds.length} out of ${events.length} have odds for market '${currentMarket}'`);
            
            // Use DocumentFragment for better performance
            const fragment = document.createDocumentFragment();
            
            // Create header
            const header = document.createElement('div');
            header.className = 'table-header';
            const gridTemplate = getSportSpecificGridTemplate();
            header.style.gridTemplateColumns = gridTemplate;
            console.log(`🎯 Table header grid template: ${gridTemplate}`);
            header.innerHTML = `
                <div>Date & Time</div>
                <div>Event</div>
                ${getOddsColumns()}
            `;
            fragment.appendChild(header);
            
            // Create event rows in batches
            const batchSize = 20;
            for (let i = 0; i < eventsWithOdds.length; i += batchSize) {
                const batch = eventsWithOdds.slice(i, i + batchSize);
                
                batch.forEach(event => {
                    const eventRow = document.createElement('div');
                    eventRow.className = `event-row ${event.is_live ? 'live-match' : ''}`;
                    eventRow.style.gridTemplateColumns = getSportSpecificGridTemplate();
                    eventRow.innerHTML = `
                        <div class="event-time">
                            ${formatEventTime(event)}
                            ${event.is_live ? '<span class="live-indicator">🔴 LIVE</span>' : ''}
                            <div class="event-status">
                                ${formatMatchStatus(event.status)}
                            </div>
                        </div>
                        <div class="event-info">
                            <div class="event-teams">
                                ${event.home_team} vs ${event.away_team}
                                ${event.is_live ? `<span class="live-score">${event.home_score} - ${event.away_score}</span>` : ''}
                            </div>
                            <div class="event-league">${event.league || 'Unknown League'}</div>
                        </div>
                        ${generateOddsButtons(event, currentMarket)}
                    `;
                    fragment.appendChild(eventRow);
                });
                
                // Use requestAnimationFrame to prevent blocking
                if (i + batchSize < eventsWithOdds.length) {
                    setTimeout(() => {}, 0);
                }
            }
            
            // Clear container and append fragment
            container.innerHTML = '';
            container.appendChild(fragment);
        }

        function formatMatchStatus(status) {
            if (!status) return '';
            
            // If status is a number (minutes), add "'" to indicate minutes
            if (!isNaN(status) && status.length <= 2) {
                return `${status}'`;
            }
            
            // If status contains ":" it's a scheduled time - hide it
            if (status.includes(':')) {
                return ''; // Don't show scheduled times
            }
            
            // Common status codes - show these
            const statusMap = {
                'HT': 'HT',
                'FT': 'FT',
                '1H': '1H',
                '2H': '2H',
                'Cancl.': '❌ Cancelled',
                'Postp.': '⏸️ Postponed',
                'WO': '❌ Walk Over',
                'Aban.': '🚫 Abandoned',
                'AET': '⚽ AET',
                'Pen.': '🎯 Penalties'
            };
            
            return statusMap[status] || status;
        }

        // Helper function to get sport-specific column headers
            function getSportSpecificHeaders() {
        const sportsWithDraws = ['soccer', 'basketball', 'hockey', 'handball', 'cricket', 'rugby', 'rugbyleague', 'futsal'];
        const sportsWithoutDraws = ['tennis', 'volleyball', 'football', 'table_tennis', 'boxing', 'mma', 'darts', 'esports', 'baseball'];
            
            console.log(`🎯 getSportSpecificHeaders - Sport: ${currentSport}, Sports with draws:`, sportsWithDraws, 'Sports without draws:', sportsWithoutDraws);
            
            // Check if we're using home_away market (2-way) or match_result market (3-way)
            if (currentMarket === 'home_away' || (sportsWithoutDraws.includes(currentSport) && currentMarket === 'match_result')) {
                const headers = '<div>1</div><div>2</div>';
                console.log(`🎯 2-column headers for ${currentSport} (${currentMarket}): ${headers}`);
                return headers;
            } else {
                const headers = '<div>1</div><div>X</div><div>2</div>';
                console.log(`🎯 3-column headers for ${currentSport} (${currentMarket}): ${headers}`);
                return headers;
            }
        }

        // Helper function to get sport-specific grid template
        function getSportSpecificGridTemplate() {
                    const sportsWithDraws = ['soccer', 'basketball', 'hockey', 'handball', 'cricket', 'rugby', 'rugbyleague', 'futsal'];
        const sportsWithoutDraws = ['tennis', 'volleyball', 'football', 'table_tennis', 'boxing', 'mma', 'darts', 'esports', 'baseball'];
            
            console.log(`🎯 getSportSpecificGridTemplate - Sport: ${currentSport}, Market: ${currentMarket}`);
            
            // For match_result market, use sport-specific logic
            if (currentMarket === 'match_result') {
                if (sportsWithoutDraws.includes(currentSport)) {
                    const template = '120px 1fr 120px 120px'; // 4 columns: time, event, 1, 2
                    console.log(`🎯 4-column template for ${currentSport}: ${template}`);
                    return template;
                } else {
                    const template = '120px 1fr 120px 120px 120px'; // 5 columns: time, event, 1, X, 2
                    console.log(`🎯 5-column template for ${currentSport}: ${template}`);
                    return template;
                }
            }
            
            // For home_away market, always use 2-way template
            if (currentMarket === 'home_away') {
                const template = '120px 1fr 120px 120px'; // 4 columns: time, event, 1, 2
                console.log(`🎯 4-column template for home_away market: ${template}`);
                return template;
            }
            
            // For other markets, determine columns based on market type
            switch (currentMarket) {
                case 'goals_over_under':
                case 'both_teams_score':
                case 'asian_handicap':
                case 'over_under':
                case 'games_over_under':
                case 'first_set':
                case 'first_half':
                case 'first_quarter':
                    const template2 = '120px 1fr 120px 120px'; // 2 odds columns
                    console.log(`🎯 2-column template for ${currentMarket}: ${template2}`);
                    return template2;
                case 'correct_score':
                case 'set_betting':
                    const template3 = '120px 1fr 120px 120px 120px'; // 3 odds columns
                    console.log(`🎯 3-column template for ${currentMarket}: ${template3}`);
                    return template3;
                default:
                    const defaultTemplate = '120px 1fr 120px 120px 120px'; // Default 3 columns
                    console.log(`🎯 Default template for ${currentMarket}: ${defaultTemplate}`);
                    return defaultTemplate;
            }
        }

        function displayCouponView(events, container) {
            // Filter out events that don't have odds for the current market
            const eventsWithOdds = events.filter(event => {
                if (!event.odds) {
                    return false;
                }
                
                // Special handling for baseball, darts, and esports match_result market
                let marketOdds = null;
                if ((currentSport === 'baseball' || currentSport === 'darts' || currentSport === 'esports') && currentMarket === 'match_result') {
                    // For baseball, darts, and esports, check both match_result and home_away markets
                    marketOdds = event.odds['match_result'] || event.odds['home_away'];
                } else {
                    marketOdds = event.odds[currentMarket];
                }
                
                if (!marketOdds) {
                    return false;
                }
                
                // Check if the market has valid odds data
                if (Array.isArray(marketOdds)) {
                    return marketOdds.length > 0 && marketOdds.some(odd => odd && odd !== '0');
                } else if (typeof marketOdds === 'object' && marketOdds !== null) {
                    return Object.keys(marketOdds).length > 0 && Object.values(marketOdds).some(odd => odd && odd !== '0');
                }
                
                return false;
            });
            
            console.log(`🎯 Coupon View: Found ${eventsWithOdds.length} events with odds out of ${events.length} total events`);
            console.log(`🎯 Current sport: ${currentSport}, Current market: ${currentMarket}`);
            console.log(`🎯 Events with odds:`, eventsWithOdds);
            
            if (eventsWithOdds.length === 0) {
                container.innerHTML = '<div class="loading-text">No events with odds available for this market</div>';
                return;
            }
            
            container.innerHTML = `
                <div class="coupon-view" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 1rem; padding: 1rem;">
                    ${eventsWithOdds.map(event => `
                        <div style="background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 12px; padding: 1rem; transition: all 0.3s ease;">
                            <div style="text-align: center; margin-bottom: 1rem;">
                                <div style="font-size: 0.9rem; color: #fbbf24; margin-bottom: 0.5rem;">${formatEventTime(event)}</div>
                                <div style="font-weight: 600; margin-bottom: 0.25rem;">${event.home_team} VS ${event.away_team}</div>
                                <div style="font-size: 0.8rem; color: rgba(255, 255, 255, 0.6);">${event.league || 'Unknown League'}</div>
                            </div>
                            <div style="display: flex; justify-content: center; gap: 0.5rem; flex-wrap: wrap;">
                                ${generateOddsButtons(event, currentMarket)}
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
            

        }

        function getDisabledReason(event) {
            if (event.status === 'Aban.') return 'Abandoned';
            if (event.status === 'Cancl.') return 'Cancelled';
            if (event.status === 'FT' || event.is_completed) return 'Finished';
            
            // For live matches without live odds
            if (event.is_live && (!event.live_odds || Object.keys(event.live_odds).length === 0)) {
                return 'No Live Odds';
            }
            
            return 'Unavailable';
        }

        function generateOddsButtons(event, market) {
            console.log(`🎯 Generating odds buttons for ${event.home_team} vs ${event.away_team} - Market: ${market}`);
            console.log('Event odds:', event.odds);
            
                        // Check if match is available for betting
            const isAvailableForBetting = () => {
                // Don't allow betting on abandoned, cancelled, or completed matches
                if (event.status === 'Aban.' || event.status === 'Cancl.' || event.status === 'FT' || event.is_completed) {
                    return false;
                }
                
                // For live matches, only allow if we have live odds
                if (event.is_live) {
                    return event.live_odds && Object.keys(event.live_odds).length > 0;
                }
                
                // For pre-match, allow betting
                return true;
            };

                        const getOdds = () => {
                switch (market) {
                    case 'match_result':
                    case 'match_winner':  // Basketball, Tennis, etc.
                    case 'home_away':     // For 2-way markets (volleyball, tennis, etc.)
                        // Use odds from JSON files (event.odds.match_result or fallback to home_away)
                        if (event.odds && event.odds.match_result) {
                            console.log(`Using JSON odds for ${event.home_team} vs ${event.away_team}:`, event.odds.match_result);
                            const odds_data = event.odds.match_result;
                            
                            // Handle both array format (new) and object format (old)
                            if (Array.isArray(odds_data)) {
                                // New format: odds_data is an array like ['1.07', '7.50'] or ['2.60', '8.00', '1.67']
                                if (odds_data.length >= 2) {
                                    const result = [
                                        { label: '1', odds: parseFloat(odds_data[0]), selection: event.home_team }
                                    ];
                                    
                                    // Add draw option if it's a 3-way market
                                    if (odds_data.length >= 3 && odds_data[1] && odds_data[1] !== '0') {
                                        result.push({ label: 'X', odds: parseFloat(odds_data[1]), selection: 'Draw' });
                                    }
                                    
                                    result.push({ label: '2', odds: parseFloat(odds_data[odds_data.length >= 3 ? 2 : 1]), selection: event.away_team });
                                    
                                    console.log('Generated odds result from array:', result);
                                    return result;
                                }
                            } else {
                                // Old format: odds_data is an object with keys '1', 'X', '2'
                                // Special handling for cricket - only show 1 and 2 (no draw)
                                if (currentSport === 'cricket') {
                                    const result = [
                                        { label: '1', odds: parseFloat(odds_data['1']), selection: event.home_team },
                                        { label: '2', odds: parseFloat(odds_data['2']), selection: event.away_team }
                                    ];
                                    console.log('Generated cricket odds result (1-2 only):', result);
                                    return result;
                                }
                                
                                // For other sports, include draw option if available
                                const result = [
                                    { label: '1', odds: parseFloat(odds_data['1']), selection: event.home_team }
                                ];
                                
                                // Add draw option if available
                                if (odds_data['X']) {
                                    result.push({ label: 'X', odds: parseFloat(odds_data['X']), selection: 'Draw' });
                                }
                                
                                result.push({ label: '2', odds: parseFloat(odds_data['2']), selection: event.away_team });
                                
                                console.log('Generated odds result from object:', result);
                                return result;
                            }
                        } else if (event.odds && event.odds.home_away) {
                            // Use home_away for 2-way markets (volleyball, tennis, etc.)
                            console.log(`Using home_away odds for ${event.home_team} vs ${event.away_team}:`, event.odds.home_away);
                            const odds_data = event.odds.home_away;
                            
                            if (odds_data.length >= 2) {
                                const result = [
                                    { label: '1', odds: parseFloat(odds_data[0]), selection: event.home_team },
                                    { label: '2', odds: parseFloat(odds_data[1]), selection: event.away_team }
                                ];
                                console.log('Generated home_away odds result (1-2 only):', result);
                                return result;
                            }
                        }
                        
                        console.log(`❌ No match_result or home_away odds found for ${event.home_team} vs ${event.away_team}`);
                        console.log('Available odds markets:', event.odds ? Object.keys(event.odds) : 'No odds object');
                        // No odds available - return null to indicate no betting
                        return null;
                    case 'both_teams_score':
                    case 'clean_sheet_home':
                    case 'clean_sheet_away':
                    case 'win_to_nil_home':
                    case 'win_to_nil_away':
                    case 'team_to_score_first':
                    case 'home_team_score_goal':
                    case 'away_team_score_goal':
                    case 'odd_even':
                    case 'odd_even_first_half':
                    case 'odd_even_first_set':
                    case 'odd_even_including_ot':
                        // Special handling for baseball - odd_even_including_ot still uses match_result odds
                        if (currentSport === 'baseball') {
                            if (event.odds && event.odds.match_result) {
                                console.log(`Using match_result odds for baseball odd_even_including_ot: ${event.home_team} vs ${event.away_team}`);
                                const odds_data = event.odds.match_result;
                                const result = [
                                    { label: '1', odds: parseFloat(odds_data['1']), selection: event.home_team }
                                ];
                                
                                // Add draw option if available
                                if (odds_data['X']) {
                                    result.push({ label: 'X', odds: parseFloat(odds_data['X']), selection: 'Draw' });
                                }
                                
                                result.push({ label: '2', odds: parseFloat(odds_data['2']), selection: event.away_team });
                                
                                console.log('Generated baseball odd_even_including_ot odds result:', result);
                                return result;
                            }
                        }
                        
                        // Special handling for basketball - ensure odd_even_including_ot shows Odd/Even
                        if (currentSport === 'basketball' && market === 'odd_even_including_ot') {
                            if (event.odds && event.odds[market] && event.odds[market].length >= 2) {
                                return [
                                    { label: 'Odd', odds: parseFloat(event.odds[market][0]), selection: 'Odd' },
                                    { label: 'Even', odds: parseFloat(event.odds[market][1]), selection: 'Even' }
                                ];
                            }
                            return null;
                        }
                        // Handle Odd/Even markets specifically
                        if (market.includes('odd_even')) {
                            if (event.odds && event.odds[market] && event.odds[market].length >= 2) {
                                return [
                                    { label: 'Odd', odds: parseFloat(event.odds[market][0]), selection: 'Odd' },
                                    { label: 'Even', odds: parseFloat(event.odds[market][1]), selection: 'Even' }
                                ];
                            }
                            return null;
                        }
                        // For other markets, use Yes/No format
                        const yesNoMarket = market;
                        if (event.odds && event.odds[yesNoMarket] && event.odds[yesNoMarket].length >= 2) {
                            return [
                                { label: 'Yes', odds: parseFloat(event.odds[yesNoMarket][0]), selection: 'Yes' },
                                { label: 'No', odds: parseFloat(event.odds[yesNoMarket][1]), selection: 'No' }
                            ];
                        }
                        return null;
                    case 'to_qualify':
                    case 'tie_break_first_set':
                    case 'win_one_set_player1':
                    case 'win_one_set_player2':
                    case 'win_both_halves':
                    case 'both_teams_score_first_half':
                    case 'both_teams_score_second_half':
                        const yesNoMarket2 = market;
                        if (event.odds && event.odds[yesNoMarket2] && event.odds[yesNoMarket2].length >= 2) {
                            return [
                                { label: 'Yes', odds: parseFloat(event.odds[yesNoMarket2][0]), selection: 'Yes' },
                                { label: 'No', odds: parseFloat(event.odds[yesNoMarket2][1]), selection: 'No' }
                            ];
                        }
                        return null;
                    case 'correct_score':
                    case 'correct_score_first_half':
                    case 'correct_score_second_half':
                        const correctScoreMarket = market;
                        if (event.odds && event.odds[correctScoreMarket] && event.odds[correctScoreMarket].length >= 3) {
                            return [
                                { label: '1-0', odds: parseFloat(event.odds[correctScoreMarket][0]), selection: 'Correct Score 1-0' },
                                { label: '2-0', odds: parseFloat(event.odds[correctScoreMarket][1]), selection: 'Correct Score 2-0' },
                                { label: '2-1', odds: parseFloat(event.odds[correctScoreMarket][2]), selection: 'Correct Score 2-1' }
                            ];
                        }
                        return null;
                    case 'asian_handicap':
                        // For soccer, use actual markets from JSON
                        if (event.odds && event.odds.first_half_winner) {
                            console.log(`Found first_half_winner for ${event.home_team} vs ${event.away_team}:`, event.odds.first_half_winner);
                            const oddsData = event.odds.first_half_winner;
                            if (Array.isArray(oddsData) && oddsData.length >= 2) {
                                return [
                                    { label: 'Home', odds: parseFloat(oddsData[0]), selection: 'Home Win 1st Half' },
                                    { label: 'Away', odds: parseFloat(oddsData[1]), selection: 'Away Win 1st Half' }
                                ];
                            }
                        }
                        console.log(`No first_half_winner odds found for ${event.home_team} vs ${event.away_team}`);
                        console.log(`Available odds markets:`, event.odds ? Object.keys(event.odds) : 'No odds');
                        return null;
                    case 'asian_handicap_first_half':
                    case 'asian_handicap_first_quarter':
                    case 'asian_handicap_sets':
                    case 'asian_handicap_games':
                    case 'first_set':
                    case 'second_set':
                    case 'first_half_winner':
                    case 'first_quarter_winner':
                    case 'second_half_winner':
                        const homeAwayMarket = market;
                        if (event.odds && event.odds[homeAwayMarket] && event.odds[homeAwayMarket].length >= 2) {
                            return [
                                { label: 'Home', odds: parseFloat(event.odds[homeAwayMarket][0]), selection: 'Home Win' },
                                { label: 'Away', odds: parseFloat(event.odds[homeAwayMarket][1]), selection: 'Away Win' }
                            ];
                        }
                        return null;
                    case 'over_under':
                    case 'over_under_first_half':
                    case 'over_under_first_quarter':
                    case 'over_under_first_set':
                    case 'games_over_under':
                    case 'corners_over_under':
                        const overUnderMarket = market;
                        if (event.odds && event.odds[overUnderMarket] && event.odds[overUnderMarket].length >= 2) {
                            return [
                                { label: 'Over', odds: parseFloat(event.odds[overUnderMarket][0]), selection: 'Over' },
                                { label: 'Under', odds: parseFloat(event.odds[overUnderMarket][1]), selection: 'Under' }
                            ];
                        }
                        return null;
                    case 'handicap_result':
                    case 'handicap_result_first_half':
                    case 'handicap_result_first_quarter':
                    case 'handicap_result_first_set':
                    case 'handicap_result_games':
                    case 'handicap_result_corners':
                        const handicapMarket = market;
                        if (event.odds && event.odds[handicapMarket] && event.odds[handicapMarket].length >= 3) {
                            return [
                                { label: 'Home', odds: parseFloat(event.odds[handicapMarket][0]), selection: 'Home' },
                                { label: 'Draw', odds: parseFloat(event.odds[handicapMarket][1]), selection: 'Draw' },
                                { label: 'Away', odds: parseFloat(event.odds[handicapMarket][2]), selection: 'Away' }
                            ];
                        }
                        return null;
                    case 'three_way_result':
                    case 'three_way_result_first_half':
                    case 'three_way_result_first_quarter':
                    case 'three_way_result_first_set':
                    case 'three_way_result_games':
                    case 'three_way_result_corners':
                        const threeWayMarket = market;
                        if (event.odds && event.odds[threeWayMarket] && event.odds[threeWayMarket].length >= 3) {
                            return [
                                { label: 'Home', odds: parseFloat(event.odds[threeWayMarket][0]), selection: 'Home' },
                                { label: 'Draw', odds: parseFloat(event.odds[threeWayMarket][1]), selection: 'Draw' },
                                { label: 'Away', odds: parseFloat(event.odds[threeWayMarket][2]), selection: 'Away' }
                            ];
                        }
                        return null;
                    case 'highest_scoring_half':
                    case 'highest_scoring_quarter':
                        const scoringMarket = market;
                        if (event.odds && event.odds[scoringMarket] && event.odds[scoringMarket].length >= 3) {
                            return [
                                { label: '1st', odds: parseFloat(event.odds[scoringMarket][0]), selection: '1st' },
                                { label: '2nd', odds: parseFloat(event.odds[scoringMarket][1]), selection: '2nd' },
                                { label: '3rd', odds: parseFloat(event.odds[scoringMarket][2]), selection: '3rd' }
                            ];
                        }
                        return null;
                    case 'double_chance':
                    case 'double_chance_first_half':
                    case 'double_chance_second_half':
                        const doubleChanceMarket = market;
                        if (event.odds && event.odds[doubleChanceMarket] && event.odds[doubleChanceMarket].length >= 3) {
                            return [
                                { label: '1X', odds: parseFloat(event.odds[doubleChanceMarket][0]), selection: '1X' },
                                { label: 'X2', odds: parseFloat(event.odds[doubleChanceMarket][1]), selection: 'X2' },
                                { label: '12', odds: parseFloat(event.odds[doubleChanceMarket][2]), selection: '12' }
                            ];
                        }
                        return null;
                    case 'results_both_teams_score':
                        if (event.odds && event.odds.results_both_teams_score && event.odds.results_both_teams_score.length >= 3) {
                            return [
                                { label: '1/Yes', odds: parseFloat(event.odds.results_both_teams_score[0]), selection: '1/Yes' },
                                { label: 'X/Yes', odds: parseFloat(event.odds.results_both_teams_score[1]), selection: 'X/Yes' },
                                { label: '2/Yes', odds: parseFloat(event.odds.results_both_teams_score[2]), selection: '2/Yes' }
                            ];
                        }
                        return null;
                    case 'result_total_goals':
                        if (event.odds && event.odds.result_total_goals && event.odds.result_total_goals.length >= 3) {
                            return [
                                { label: '1/Over', odds: parseFloat(event.odds.result_total_goals[0]), selection: '1/Over' },
                                { label: 'X/Over', odds: parseFloat(event.odds.result_total_goals[1]), selection: 'X/Over' },
                                { label: '2/Over', odds: parseFloat(event.odds.result_total_goals[2]), selection: '2/Over' }
                            ];
                        }
                        return null;
                    case 'ht_ft_double':
                        if (event.odds && event.odds.ht_ft_double && event.odds.ht_ft_double.length >= 3) {
                            return [
                                { label: '1/1', odds: parseFloat(event.odds.ht_ft_double[0]), selection: '1/1' },
                                { label: '1/X', odds: parseFloat(event.odds.ht_ft_double[1]), selection: '1/X' },
                                { label: '1/2', odds: parseFloat(event.odds.ht_ft_double[2]), selection: '1/2' }
                            ];
                        }
                        return null;
                    // Cricket-specific markets
                    case 'most_sixes':
                    case 'most_fours':
                    case 'most_run_outs':
                        const cricketMarket = market;
                        if (event.odds && event.odds[cricketMarket] && event.odds[cricketMarket].length >= 3) {
                            // For cricket markets, we have 3 options: Home, Away, Draw
                            return [
                                { label: '1', odds: parseFloat(event.odds[cricketMarket][0]), selection: event.home_team },
                                { label: 'X', odds: parseFloat(event.odds[cricketMarket][1]), selection: 'Draw' },
                                { label: '2', odds: parseFloat(event.odds[cricketMarket][2]), selection: event.away_team }
                            ];
                        }
                        return null;
                    default:
                        return null; // No odds available
                }
            };;

            const odds = getOdds();
            
            // If no odds are available, don't show any betting buttons
            if (!odds) {
                return '';
            }
            
            // If match is not available for betting, show disabled buttons
            if (!isAvailableForBetting()) {
                return odds.map(odd => `
                    <button class="odds-btn disabled" disabled style="opacity: 0.5; cursor: not-allowed;">
                        <div style="font-weight: 600; font-size: 1.1rem;">${odd.odds}</div>
                        <div style="font-size: 0.7rem; color: #ef4444; margin-top: 0.25rem;">${getDisabledReason(event)}</div>
                    </button>
                `).join('');
            }
            
            return odds.map(odd => {
                // Find the actual market ID from the event's odds data
                let marketId = 'unknown';
                if (event && event.odds) {
                    // Look for the market with this display name and get its ID
                    if (Object.entries) {
                        for (var i = 0; i < Object.keys(event.odds).length; i++) {
                            var marketKey = Object.keys(event.odds)[i];
                            var marketData = event.odds[marketKey];
                            if (marketKey === market || marketData === market) {
                                // This is the market we're looking for, get its ID
                                const marketIdKey = `${marketKey}_market_id`;
                                if (event.odds[marketIdKey]) {
                                    marketId = event.odds[marketIdKey];
                                }
                                break;
                            }
                        }
                    } else {
                        // Fallback for older browsers
                        for (const marketKey in event.odds) {
                            if (event.odds.hasOwnProperty(marketKey)) {
                                const marketData = event.odds[marketKey];
                                if (marketKey === market || marketData === market) {
                                    // This is the market we're looking for, get its ID
                                    const marketIdKey = `${marketKey}_market_id`;
                                    if (event.odds[marketIdKey]) {
                                        marketId = event.odds[marketIdKey];
                                    }
                                    break;
                                }
                            }
                        }
                    }
                }
                
                console.log(`🎯 Market: ${market}, Market ID: ${marketId}, Event odds:`, event.odds);
                return `
                    <button class="odds-btn" onclick="addToBetSlip('${event.id || Math.random()}', '${event.home_team} vs ${event.away_team}', '${odd.selection}', ${odd.odds}, '${marketId}')">
                        <div style="font-weight: 600; font-size: 1.1rem;">${odd.odds}</div>
                    </button>
                `;
            }).join('');
        }

        // Market switching
        function switchMarket(market) {
            currentMarket = market;
            document.querySelectorAll('.market-tab').forEach(tab => tab.classList.remove('active'));
            event.target.classList.add('active');
            displayEvents();
        }

        // View switching
        function switchView(view) {
            currentView = view;
            document.querySelectorAll('.view-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            displayEvents();
        }

        // Bet slip functions
        let betMode = 'single'; // 'single' or 'combo'
        let maxComboBets = 5;
        
        function addToBetSlip(eventId, matchName, selection, odds, marketId) {
            console.log(`🎯 Adding to bet slip: ${eventId}, ${matchName}, ${selection}, ${odds}, market: ${marketId}`);
            
            // Check if we're in combo mode and have reached the limit
            if (betMode === 'combo' && betSlip.length >= maxComboBets) {
                showWarningAlert('Too Many Bets', `Maximum ${maxComboBets} bets allowed in combo mode.`, 3000);
                return;
            }
            
            const existingBet = betSlip.find(bet => bet.eventId === eventId && bet.selection === selection);
            if (existingBet) {
                return; // Already in bet slip
            }

            // Find the actual event to get the real match ID, time, sport, and timing
            const currentEvents = window.currentEvents || eventsData[currentSport] || [];
            const actualEvent = currentEvents.find(e => e.id === eventId);
            const matchId = actualEvent ? actualEvent.id : eventId; // Use actual GoalServe match ID
            const matchTime = actualEvent ? actualEvent.time : '';
            const sport = actualEvent ? actualEvent.sport : currentSport; // Get sport from event data
            const betTiming = 'pregame'; // Default to pregame for now, can be enhanced later
            
            // Calculate event_time in UTC format
            let eventTime = null;
            if (actualEvent && actualEvent.date && actualEvent.time) {
                try {
                    // Parse the event date and time to create a proper UTC datetime
                    const eventDateTime = parseFlexibleEventDateTime(actualEvent.date, actualEvent.time);
                    if (eventDateTime) {
                        eventTime = eventDateTime.toISOString(); // Convert to UTC ISO string
                    }
                } catch (e) {
                    console.warn('Failed to parse event time:', e);
                }
            }

            betSlip.push({
                eventId,
                matchId: matchId, // Store actual GoalServe match ID for settlement
                matchName,
                matchTime: matchTime, // Store match time for validation
                eventTime: eventTime, // Store UTC event time for database
                selection,
                odds,
                stake: 10,
                sport: sport, // Store sport information for combo bets
                bet_timing: betTiming, // Store bet timing for combo bets
                marketId: marketId // Store market ID for admin liability calculation
            });
            
            // Start real-time updates if this is the first bet
            if (betSlip.length === 1) {
                startBetSlipUpdates();
            }
            
            updateBetSlip();
        }
        
        function toggleBetMode() {
            const newMode = (betMode === 'single') ? 'combo' : 'single';

            // If there are selections, confirm before switching
            if (Array.isArray(betSlip) && betSlip.length > 0) {
                const title = 'Switch Bet Mode';
                const msg = 'Switching bet modes will clear your current selections. Continue?';

                if (typeof showCustomConfirm === 'function') {
                    showCustomConfirm(
                        title,
                        msg,
                        function onConfirm() {
                            betMode = newMode;
                            betSlip = [];
                            comboTotalStake = (betMode === 'combo') ? 10 : 0;
                            stopBetSlipUpdates();
                            updateBetSlip();
                            updateBetModeDisplay();
                        },
                        function onCancel() {
                            // Do nothing; keep current mode
                        }
                    );
                    return; // wait for user action
                } else {
                    // Fallback to native confirm
                    if (!window.confirm(msg)) return;
                    betMode = newMode;
                    betSlip = [];
                    comboTotalStake = (betMode === 'combo') ? 10 : 0;
                    stopBetSlipUpdates();
                    updateBetSlip();
                    updateBetModeDisplay();
                    return;
                }
            }

            // No selections — switch immediately
            betMode = newMode;
            comboTotalStake = (betMode === 'combo') ? 10 : 0;
            updateBetSlip();
            updateBetModeDisplay();
        }

        
        function updateBetModeDisplay() {
            const modeButton = document.getElementById('betModeToggle');
            const sliderLabel = modeButton.querySelector('.slider-label');
            
            if (modeButton) {
                if (betMode === 'combo') {
                    modeButton.classList.add('active');
                    sliderLabel.textContent = 'Combo';
                } else {
                    modeButton.classList.remove('active');
                    sliderLabel.textContent = 'Single';
                }
            }
        }

        function updateBetSlip() {
            const container = document.getElementById('betSlipContent');
            const countElement = document.getElementById('betCount');
            
            countElement.textContent = betSlip.length;
            
            if (betSlip.length === 0) {
                container.innerHTML = `
                    <p>Your bet slip is empty</p>
                    <p>Click on odds to add selections</p>
                    ${betMode === 'combo' ? `<p style="font-size: 0.8rem; color: #4ade80;">Combo Mode: Up to ${maxComboBets} bets</p>` : ''}
                `;
                return;
            }
            
            // Update odds for each bet in the slip
            updateBetSlipOdds();
            
            // Calculate total stake based on bet mode
            let totalStake;
            if (betMode === 'combo') {
                totalStake = comboTotalStake; // Use the combo total stake
            } else {
                totalStake = betSlip.reduce((sum, bet) => sum + bet.stake, 0); // Sum individual stakes
            }
            
            // Calculate potential return based on bet mode
            let potentialReturn, totalOdds;
            if (betMode === 'combo') {
                // Combo bet: multiply all odds together
                totalOdds = betSlip.reduce((product, bet) => product * bet.odds, 1);
                potentialReturn = totalStake * totalOdds;
            } else {
                // Single bets: sum of individual returns
                potentialReturn = betSlip.reduce((sum, bet) => sum + (bet.stake * bet.odds), 0);
                totalOdds = 0; // Not applicable for single bets
            }

            container.innerHTML = `
                ${betMode === 'combo' ? `
                    <div style="background: linear-gradient(135deg, #4ade80, #22c55e); border-radius: 8px; padding: 0.75rem; margin-bottom: 1rem; text-align: center;">
                        <div style="font-weight: 600; color: #000;">🎯 COMBO BET</div>
                        <div style="font-size: 0.8rem; color: #000; margin-top: 0.25rem;">
                            ${betSlip.length}/${maxComboBets} selections • Total Odds: ${totalOdds.toFixed(2)}x
                        </div>
                    </div>
                ` : ''}
                ${betSlip.map((bet, index) => `
                    <div style="background: rgba(255, 255, 255, 0.05); border-radius: 8px; padding: 1rem; margin-bottom: 1rem;">
                        <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 0.5rem;">
                            <div style="flex: 1;">
                                <div style="font-weight: 600; font-size: 0.9rem; margin-bottom: 0.25rem;">${bet.matchName}</div>
                                <div style="color: #4ade80; font-size: 0.8rem; margin-bottom: 0.25rem;">${bet.selection}</div>
                                <div style="font-weight: 600;">@ ${parseFloat(bet.odds).toFixed(2)}</div>
                            </div>
                            <button onclick="removeFromBetSlip(${index})" style="background: #ef4444; border: none; border-radius: 4px; color: white; padding: 0.25rem 0.5rem; cursor: pointer;">&times;</button>
                        </div>
                        ${betMode === 'single' ? `
                            <div style="display: flex; align-items: center; gap: 0.5rem;">
                                <label style="font-size: 0.8rem; color: rgba(255, 255, 255, 0.7);">Stake:</label>
                                <input type="number" value="${bet.stake}" onchange="updateStake(${index}, this.value)" 
                                       style="background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 4px; padding: 0.25rem; color: white; width: 60px;">
                            </div>
                            <div style="margin-top: 0.5rem; font-size: 0.8rem; color: rgba(255, 255, 255, 0.7);">
                                Return: $${(bet.stake * parseFloat(bet.odds)).toFixed(2)}
                            </div>
                        ` : `
                            <div style="font-size: 0.8rem; color: rgba(255, 255, 255, 0.7); font-style: italic;">
                                Part of combo bet
                            </div>
                        `}
                    </div>
                `).join('')}
                <div style="border-top: 1px solid rgba(255, 255, 255, 0.1); padding-top: 1rem; margin-top: 1rem;">
                    ${betMode === 'combo' ? `
                        <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 1rem;">
                            <label style="font-size: 0.8rem; color: rgba(255, 255, 255, 0.7);">Total Stake:</label>
                            <input type="number" value="${totalStake}" onchange="updateComboStake(this.value)" 
                                   style="background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 4px; padding: 0.25rem; color: white; width: 80px;">
                        </div>
                    ` : ''}
                    <div style="display: flex; justify-content: space-between; margin-bottom: 0.5rem;">
                        <span>Total Stake:</span>
                        <span style="font-weight: 600;">$${totalStake.toFixed(2)}</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin-bottom: 1rem;">
                        <span>${betMode === 'combo' ? 'Combo Return:' : 'Potential Return:'}</span>
                        <span style="font-weight: 600; color: #4ade80;">$${potentialReturn.toFixed(2)}</span>
                    </div>
                    <button onclick="placeBets()" style="width: 100%; background: linear-gradient(135deg, #4ade80, #22c55e); border: none; border-radius: 8px; color: #000; font-weight: 600; padding: 0.75rem; cursor: pointer; transition: all 0.3s ease;">
                        Place ${betMode === 'combo' ? 'Combo ' : ''}Bet
                    </button>
                </div>
            `;
        }

        function removeFromBetSlip(index) {
            betSlip.splice(index, 1);
            
            // Stop updates if no bets left
            if (betSlip.length === 0) {
                stopBetSlipUpdates();
            }
            
            updateBetSlip();
        }

        function updateStake(index, newStake) {
            betSlip[index].stake = parseFloat(newStake) || 0;
            updateBetSlip();
        }
        
        function updateComboStake(totalStake) {
            comboTotalStake = parseFloat(totalStake) || 0;
            updateBetSlip();
        }
        
        // Real-time bet slip odds updates
        let betSlipUpdateInterval = null;
        
        function startBetSlipUpdates() {
            // Clear existing interval
            if (betSlipUpdateInterval) {
                clearInterval(betSlipUpdateInterval);
            }
            
            console.log('Starting bet slip updates every 0.5 seconds...');
            
            // Show live indicator
            const statusElement = document.getElementById('betSlipStatus');
            if (statusElement) {
                statusElement.style.display = 'block';
            }
            
            // Update bet slip odds every 5 seconds (increased from 0.5 seconds to reduce flickering)
            betSlipUpdateInterval = setInterval(() => {
                if (betSlip.length > 0) {
                    console.log('Updating bet slip odds...');
                    updateBetSlipOdds();
                }
            }, 5000); // Changed from 500 (0.5 seconds) to 5000 (5 seconds)
        }
        
        function stopBetSlipUpdates() {
            if (betSlipUpdateInterval) {
                clearInterval(betSlipUpdateInterval);
                betSlipUpdateInterval = null;
            }
            
            // Hide live indicator
            const statusElement = document.getElementById('betSlipStatus');
            if (statusElement) {
                statusElement.style.display = 'none';
            }
        }
        
        function updateBetSlipOdds() {
            if (betSlip.length === 0) return;
            
            console.log(`Updating odds for ${betSlip.length} bets in slip...`);
            
            // Get current live odds for all matches in bet slip
            const matchesInSlip = betSlip.map(bet => bet.matchName);
            
            // Find corresponding events with live odds
            const events = eventsData[currentSport] || [];
            
            let oddsUpdated = false;
            
            betSlip.forEach((bet, index) => {
                const matchingEvent = events.find(event => 
                    `${event.home_team} vs ${event.away_team}` === bet.matchName
                );
                
                if (matchingEvent && matchingEvent.live_odds) {
                    // Update odds based on current market
                    let newOdds = bet.odds;
                    let oddsChanged = false;
                    
                    if (currentMarket === 'match_result') {
                        if (bet.selection === matchingEvent.home_team && matchingEvent.live_odds['1x2']) {
                            newOdds = parseFloat(matchingEvent.live_odds['1x2']['1']);
                            oddsChanged = newOdds !== bet.odds;
                        } else if (bet.selection === matchingEvent.away_team && matchingEvent.live_odds['1x2']) {
                            newOdds = parseFloat(matchingEvent.live_odds['1x2']['2']);
                            oddsChanged = newOdds !== bet.odds;
                        } else if (bet.selection === 'Draw' && matchingEvent.live_odds['1x2']) {
                            newOdds = parseFloat(matchingEvent.live_odds['1x2']['x']);
                            oddsChanged = newOdds !== bet.odds;
                        }
                    }
                    
                    // Update bet if odds changed
                    if (oddsChanged) {
                        console.log(`Odds changed for ${bet.matchName} - ${bet.selection}: ${bet.odds} → ${newOdds}`);
                        betSlip[index].odds = newOdds;
                        betSlip[index].oddsChanged = true; // Flag for visual indication
                        oddsUpdated = true;
                        
                        // Show odds change notification
                        showOddsChangeNotification(bet.matchName, bet.selection, newOdds);
                    }
                }
            });
            
            // Re-render bet slip with updated odds
            if (oddsUpdated) {
                console.log('Rendering updated bet slip...');
                renderBetSlip();
            }
        }
        
        function renderBetSlip() {
            const container = document.getElementById('betSlipContent');
            const countElement = document.getElementById('betCount');
            
            countElement.textContent = betSlip.length;
            
            if (betSlip.length === 0) {
                container.innerHTML = `
                    <p>Your bet slip is empty</p>
                    <p>Click on odds to add selections</p>
                `;
                return;
            }
            
            const totalStake = betSlip.reduce((sum, bet) => sum + bet.stake, 0);
            const totalOdds = betSlip.reduce((product, bet) => product * bet.odds, 1);
            const potentialReturn = totalStake * totalOdds;
            
            container.innerHTML = `
                ${betSlip.map((bet, index) => `
                    <div style="background: rgba(255, 255, 255, 0.05); border-radius: 8px; padding: 1rem; margin-bottom: 1rem; ${bet.oddsChanged ? 'border: 2px solid #4ade80; animation: pulse 1s;' : ''}">
                        <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 0.5rem;">
                            <div style="flex: 1;">
                                <div style="font-weight: 600; font-size: 0.9rem; margin-bottom: 0.25rem;">${bet.matchName}</div>
                                <div style="color: #4ade80; font-size: 0.8rem; margin-bottom: 0.25rem;">${bet.selection}</div>
                                <div style="font-weight: 600; ${bet.oddsChanged ? 'color: #4ade80;' : ''}">@ ${bet.odds.toFixed(2)}</div>
                            </div>
                            <button onclick="removeFromBetSlip(${index})" style="background: #ef4444; border: none; border-radius: 4px; color: white; padding: 0.25rem 0.5rem; cursor: pointer;">&times;</button>
                        </div>
                        <div style="display: flex; align-items: center; gap: 0.5rem;">
                            <label style="font-size: 0.8rem; color: rgba(255, 255, 255, 0.7);">Stake:</label>
                            <input type="number" value="${bet.stake}" onchange="updateStake(${index}, this.value)"
                                   style="background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 4px; padding: 0.25rem; color: white; width: 60px;">
                        </div>
                        <div style="margin-top: 0.5rem; font-size: 0.8rem; color: rgba(255, 255, 255, 0.7);">
                            Return: $${(bet.stake * bet.odds).toFixed(2)}
                        </div>
                    </div>
                `).join('')}
                <div style="border-top: 1px solid rgba(255, 255, 255, 0.1); padding-top: 1rem; margin-top: 1rem;">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 0.5rem;">
                        <span>Total Stake:</span>
                        <span style="font-weight: 600;">$${totalStake.toFixed(2)}</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin-bottom: 1rem;">
                        <span>Potential Return:</span>
                        <span style="font-weight: 600; color: #4ade80;">$${potentialReturn.toFixed(2)}</span>
                    </div>
                    <button onclick="placeBets()" style="width: 100%; background: linear-gradient(135deg, #4ade80, #22c55e); border: none; border-radius: 8px; color: #000; font-weight: 600; padding: 0.75rem; cursor: pointer; transition: all 0.3s ease;">
                        Place Bet
                    </button>
                </div>
            `;
            
            // Clear odds changed flag after rendering
            betSlip.forEach(bet => bet.oddsChanged = false);
        }
        
        function showOddsChangeNotification(matchName, selection, newOdds) {
            // Create a temporary notification
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #4ade80;
                color: #000;
                padding: 0.75rem 1rem;
                border-radius: 8px;
                font-weight: 600;
                z-index: 10000;
                animation: slideIn 0.3s ease;
                max-width: 300px;
            `;
            notification.innerHTML = `
                <div style="font-size: 0.9rem;">📈 Odds Updated</div>
                <div style="font-size: 0.8rem; margin-top: 0.25rem;">${matchName} - ${selection}</div>
                <div style="font-size: 0.8rem;">New odds: ${newOdds.toFixed(2)}</div>
            `;
            
            document.body.appendChild(notification);
            
            // Remove notification after 3 seconds
            setTimeout(() => {
                notification.style.animation = 'slideOut 0.3s ease';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, 3000);
        }

        async function placeBets() {
            if (betSlip.length === 0) return;

            try {
                if (betMode === 'combo') {
                    // Place combo bet as a single bet with combined odds
                    const totalOdds = betSlip.reduce((product, bet) => product * bet.odds, 1);
                    const totalStake = comboTotalStake;
                    
                    if (totalStake <= 0) {
                        showWarningAlert('Invalid Stake', 'Please enter a valid stake amount for your combo bet.', 3000);
                        return;
                    }
                    
                    // Create combo bet data
                    const comboBetData = {
                        bet_type: 'combo',
                        selections: betSlip.map(bet => ({
                            match_id: bet.matchId || bet.eventId,
                            match_name: bet.matchName,
                            match_time: bet.matchTime,
                            event_time: bet.eventTime, // Include UTC event time
                            selection: bet.selection,
                            odds: parseFloat(bet.odds.toFixed(2)),
                            sport_name: bet.sport || currentSport,  // Include sport from event data
                            bet_timing: bet.bet_timing || 'pregame'  // Include bet timing from event data
                        })),
                        total_odds: parseFloat(totalOdds.toFixed(2)),
                        total_stake: totalStake,
                        event_time: betSlip[0]?.eventTime // Use first bet's event time for combo
                    };
                    
                    const response = await fetch(`${API_BASE}/api/betting/place-combo`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(comboBetData)
                    });
                    
                    const data = await response.json();
                    
                    if (!response.ok) {
                        alert(data.message || 'Failed to place combo bet');
                        return;
                    }
                    
                    showSuccessAlert('Bet Placed! 🎉', 'Your combo bet has been placed successfully!', 4000);
                    
                    // Update balance from response
                    if (data.new_balance !== undefined) {
                        document.getElementById('userBalance').textContent = `$${data.new_balance.toFixed(2)}`;
                    }
                } else {
                    // Place each bet individually
                    for (const bet of betSlip) {
                        const response = await fetch(`${API_BASE}/api/betting/place`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                match_id: bet.matchId || bet.eventId,
                                match_name: bet.matchName,
                                match_time: bet.matchTime,
                                event_time: bet.eventTime, // Include UTC event time
                                selection: bet.selection,
                                odds: parseFloat(bet.odds.toFixed(2)),
                                stake: bet.stake,
                                sport_name: bet.sport || currentSport,  // Include sport from event data
                                bet_timing: bet.bet_timing || 'pregame',  // Include bet timing from event data
                                market_id: bet.marketId || 'unknown'  // Include market ID for admin liability calculation
                            })
                        });
                        
                        const data = await response.json();
                        
                        if (!response.ok) {
                            alert(data.message || 'Failed to place bet');
                            return;
                        }
                        
                        // Update balance from response
                        if (data.new_balance !== undefined) {
                            document.getElementById('userBalance').textContent = `$${data.new_balance.toFixed(2)}`;
                        }
                    }
                    
                    showSuccessAlert('Bets Placed! 🎉', 'All your bets have been placed successfully!', 4000);
                }
                
                betSlip = [];
                comboTotalStake = 0; // Reset combo stake
                stopBetSlipUpdates();
                updateBetSlip();
                
            } catch (error) {
                console.error('Error placing bets:', error);
                alert('Error placing bets. Please try again.');
            }
        }

        // User menu functions
        function toggleUserMenu() {
            const dropdown = document.getElementById('userDropdown');
            if (dropdown.style.display === 'none') {
                dropdown.style.display = 'block';
                // Close dropdown when clicking outside
                setTimeout(() => {
                    document.addEventListener('click', closeUserMenu);
                }, 0);
            } else {
                dropdown.style.display = 'none';
            }
        }

        function closeUserMenu(event) {
            const userMenu = document.getElementById('userMenu');
            const dropdown = document.getElementById('userDropdown');
            if (!userMenu.contains(event.target) && !dropdown.contains(event.target)) {
                dropdown.style.display = 'none';
                document.removeEventListener('click', closeUserMenu);
            }
        }

        function logout() {
            localStorage.removeItem('token');
            localStorage.removeItem('user');
            // Redirect to logout which will clear session and redirect to login
            const tenant = getTenant();
            window.location.href = `/${tenant}/logout`;
        }

        // Page navigation functions
        async function showBetHistory() {
            // Check if user is authenticated
            if (!window.__AUTH_OK) {
                alert('Please sign in to view your bet history');
                return;
            }
            
            try {
                const response = await fetch(`${API_BASE}/api/betting/bets`, {
                    credentials: 'include' // Include cookies for session
                });
                
                if (response.ok) {
                const data = await response.json();
                    displayBetHistory(data.bets);
                } else {
                    alert('Failed to load bet history');
                }
            } catch (error) {
                console.error('Error loading bet history:', error);
                alert('Error loading bet history');
            }
        }

        function displayBetHistory(bets) {
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.8);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 10000;
            `;

            const modalContent = document.createElement('div');
            modalContent.style.cssText = `
                background: #1a1a2e;
                border-radius: 12px;
                padding: 2rem;
                max-width: 90%;
                max-height: 80%;
                overflow-y: auto;
                border: 1px solid rgba(255, 255, 255, 0.1);
            `;

            const header = document.createElement('div');
            header.style.cssText = `
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 1.5rem;
                border-bottom: 1px solid rgba(255, 255, 255, 0.1);
                padding-bottom: 1rem;
            `;
            header.innerHTML = `
                <h2 style="color: #ffffff; margin: 0;">Bet History</h2>
                <button onclick="this.closest('.modal').remove()" style="background: #ef4444; border: none; border-radius: 4px; color: white; padding: 0.5rem 1rem; cursor: pointer;">&times;</button>
            `;

            modalContent.appendChild(header);

            if (bets.length === 0) {
                const noBets = document.createElement('div');
                noBets.style.cssText = `
                    text-align: center;
                    color: rgba(255, 255, 255, 0.7);
                    padding: 2rem;
                `;
                noBets.innerHTML = `
                    <div style="font-size: 3rem; margin-bottom: 1rem;">📊</div>
                    <h3>No bets found</h3>
                    <p>You haven't placed any bets yet.</p>
                `;
                modalContent.appendChild(noBets);
            } else {
                const table = document.createElement('table');
                table.style.cssText = `
                    width: 100%;
                    border-collapse: collapse;
                    color: #ffffff;
                `;

                const thead = document.createElement('thead');
                thead.innerHTML = `
                    <tr style="border-bottom: 1px solid rgba(255, 255, 255, 0.1);">
                        <th style="padding: 0.75rem; text-align: left; font-weight: 600;">Date & Time</th>
                        <th style="padding: 0.75rem; text-align: left; font-weight: 600;">Match</th>
                        <th style="padding: 0.75rem; text-align: left; font-weight: 600;">Bet Selection</th>
                        <th style="padding: 0.75rem; text-align: center; font-weight: 600;">Odds</th>
                        <th style="padding: 0.75rem; text-align: center; font-weight: 600;">Stake</th>
                        <th style="padding: 0.75rem; text-align: center; font-weight: 600;">Potential Return</th>
                        <th style="padding: 0.75rem; text-align: center; font-weight: 600;">Status</th>
                    </tr>
                `;
                table.appendChild(thead);

                const tbody = document.createElement('tbody');
                bets.forEach(bet => {
                    const row = document.createElement('tr');
                    row.style.cssText = `
                        border-bottom: 1px solid rgba(255, 255, 255, 0.05);
                        transition: background-color 0.2s;
                    `;
                    row.onmouseover = () => row.style.backgroundColor = 'rgba(255, 255, 255, 0.05)';
                    row.onmouseout = () => row.style.backgroundColor = 'transparent';

                    const statusColor = {
                        'pending': '#f59e0b',
                        'won': '#10b981',
                        'lost': '#ef4444',
                        'void': '#6b7280',
                        'voided': '#8b5cf6',
                        'cashed_out': '#8b5cf6'
                    };

                    const statusText = {
                        'pending': 'Pending',
                        'won': 'Won',
                        'lost': 'Lost',
                        'void': 'Void',
                        'voided': 'Cancelled',
                        'cashed_out': 'Cashed Out'
                    };

                    // Format UTC ISO-8601 timestamp to user's local timezone (bulletproof)
                    function formatLocalDateTime(isoUtcString) {
                        // relies on browser TZ; `Z` ensures Date parses as UTC then converts locally
                        const dt = new Date(isoUtcString); // e.g. "2025-09-08T15:57:00Z"
                        // Use the user's locale and timezone automatically
                        return new Intl.DateTimeFormat(undefined, {
                            dateStyle: "medium",
                            timeStyle: "short"
                        }).format(dt);
                    }
                    
                    // Guardrail for legacy data (no `Z`)
                    function coerceToISOZ(s) {
                        // If it looks like "YYYY-MM-DD HH:MM:SS" without timezone, assume UTC and add Z
                        if (/^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}$/.test(s)) {
                            return s.replace(" ", "T") + "Z";
                        }
                        return s;
                    }
                    
                    const raw = bet.created_at_iso || bet.created_at; // prefer the new field
                    const safe = raw ? coerceToISOZ(raw) : null;
                    let localTime = 'N/A';
                    if (safe) {
                        localTime = formatLocalDateTime(safe);
                    }

                    // Get proper match name (prefer match_name over match_id)
                    const matchName = bet.match_name || bet.match_id || 'N/A';

                    row.innerHTML = `
                        <td style="padding: 0.75rem; font-size: 0.9rem;">${localTime}</td>
                        <td style="padding: 0.75rem; font-weight: 500;">${matchName}</td>
                        <td style="padding: 0.75rem; color: #4ade80;">${bet.selection || 'N/A'}</td>
                        <td style="padding: 0.75rem; text-align: center;">${bet.odds || 'N/A'}</td>
                        <td style="padding: 0.75rem; text-align: center;">$${bet.stake?.toFixed(2) || 'N/A'}</td>
                        <td style="padding: 0.75rem; text-align: center;">$${bet.potential_return?.toFixed(2) || 'N/A'}</td>
                        <td style="padding: 0.75rem; text-align: center;">
                            <span style="
                                background: ${statusColor[bet.status] || '#6b7280'};
                                color: white;
                                padding: 0.25rem 0.5rem;
                                border-radius: 4px;
                                font-size: 0.8rem;
                                font-weight: 500;
                            ">${statusText[bet.status] || bet.status}</span>
                        </td>
                    `;
                    tbody.appendChild(row);
                });
                table.appendChild(tbody);
                modalContent.appendChild(table);
            }

            modal.appendChild(modalContent);
            document.body.appendChild(modal);

            // Close modal when clicking outside
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            });
        }

        function showAdminPanel() {
            // Implementation for admin panel
            alert('Admin Panel feature coming soon!');
        }

        function loadLiveOdds(liveEvents) {
            if (liveEvents.length === 0) return;
            
            fetch(`${API_BASE}/api/sports/${currentSport}/odds`)
                .then(response => response.json())
                .then(liveOddsData => {
                    console.log('Live odds data:', liveOddsData);
                    displayLiveOdds(liveOddsData);
                    
                    // Auto-refresh live odds every 30 seconds
                    setTimeout(() => {
                        if (liveEvents.length > 0) {
                            loadLiveOdds(liveEvents);
                        }
                    }, 30000);
                })
                .catch(error => {
                    console.error('Error loading live odds:', error);
                });
        }

        function displayLiveOdds(liveOddsData) {
            const container = document.getElementById('liveOddsContainer');
            if (!container) return;
            
            if (liveOddsData.length === 0) {
                container.innerHTML = '<div class="no-live-odds">No live odds available</div>';
                return;
            }
            
            container.innerHTML = `
                <div class="live-odds-header">
                    <h3>🔴 LIVE ODDS</h3>
                    <div class="live-odds-timer">Updated: ${new Date().toLocaleTimeString()}</div>
                </div>
                <div class="live-odds-grid">
                    ${liveOddsData.map(match => `
                        <div class="live-odds-card">
                            <div class="match-header">
                                <div class="match-teams">
                                    <span class="home-team">${match.home_team}</span>
                                    <span class="vs">vs</span>
                                    <span class="away-team">${match.away_team}</span>
                                </div>
                                <div class="live-score">
                                    ${match.home_score} - ${match.away_score}
                                </div>
                                <div class="match-status">
                                    ${match.status} ${match.time_remaining ? `(${match.time_remaining}' remaining)` : ''}
                                </div>
                            </div>
                            <div class="odds-markets">
                                <div class="market-section">
                                    <h4>Match Result</h4>
                                    <div class="odds-row">
                                        <span class="selection">1</span>
                                        <span class="odds">${match.live_odds['1x2']['1']}</span>
                                        <span class="selection">X</span>
                                        <span class="odds">${match.live_odds['1x2']['x']}</span>
                                        <span class="selection">2</span>
                                        <span class="odds">${match.live_odds['1x2']['2']}</span>
                                    </div>
                                </div>
                                <div class="market-section">
                                    <h4>Total Goals</h4>
                                    <div class="odds-row">
                                        <span class="selection">Over 2.5</span>
                                        <span class="odds">${match.live_odds['total_goals']['over_2_5']}</span>
                                        <span class="selection">Under 2.5</span>
                                        <span class="odds">${match.live_odds['total_goals']['under_2_5']}</span>
                                    </div>
                                </div>
                                <div class="market-section">
                                    <h4>Next Goal</h4>
                                    <div class="odds-row">
                                        <span class="selection">${match.home_team}</span>
                                        <span class="odds">${match.live_odds['next_goal']['home']}</span>
                                        <span class="selection">${match.away_team}</span>
                                        <span class="odds">${match.live_odds['next_goal']['away']}</span>
                                    </div>
                                </div>
                                <div class="market-section">
                                    <h4>Both Teams Score</h4>
                                    <div class="odds-row">
                                        <span class="selection">Yes</span>
                                        <span class="odds">${match.live_odds['both_teams_score']['yes']}</span>
                                        <span class="selection">No</span>
                                        <span class="odds">${match.live_odds['both_teams_score']['no']}</span>
                                    </div>
                                </div>
                            </div>
                            <div class="match-progress">
                                <div class="progress-bar">
                                    <div class="progress-fill" style="width: ${match.live_odds.match_progress * 100}%"></div>
                                </div>
                                <span class="progress-text">${Math.round(match.live_odds.match_progress * 100)}% Complete</span>
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        // WebSocket functions
        let webSocketInitialized = false;
        
        function initWebSocket() {
            if (webSocketInitialized) {
                console.log('🚫 WebSocket already initialized, skipping...');
                return;
            }
            
            try {
                socket = io({
                    transports: ['websocket'],      // avoid long-poll behind LBs
                    reconnection: true,
                    reconnectionAttempts: Infinity,
                    reconnectionDelay: 500,
                    reconnectionDelayMax: 10000,
                    withCredentials: true,
                    path: '/socket.io/',
                });
                
                // Handle transport errors and force reconnection
                socket.on('transport error', () => {
                    console.log('[WS] Transport error, forcing reconnection');
                    if (socket.io.engine) socket.io.engine.close();
                });
                
                socket.on('connect', function() {
                    console.log('WebSocket connected');
                    websocketConnected = true;
                    updateWebSocketStatus(true);
                    
                    // Subscribe to live odds updates
                    socket.emit('subscribe_live_odds', { sport: currentSport });
                    
                    // DISABLED: Auto-refresh is no longer needed since we have intelligent live odds updates
                    // startAutoRefresh();
                });
                
                socket.on('disconnect', function() {
                    console.log('WebSocket disconnected');
                    websocketConnected = false;
                    updateWebSocketStatus(false);
                    
                    // DISABLED: Auto-refresh is no longer needed since we have intelligent live odds updates
                    // startAutoRefresh();
                });
                
                socket.on('live_odds_update', function(data) {
                    console.log('Received live odds update:', data);
                    handleLiveOddsUpdate(data);
                });
                
                socket.on('match_odds_update', function(data) {
                    console.log('Received specific match update:', data);
                    handleSpecificMatchUpdate(data);
                });
                
                socket.on('connection_status', function(data) {
                    console.log('Connection status:', data);
                });
                
                socket.on('subscription_confirmed', function(data) {
                    console.log('Subscription confirmed:', data);
                });
                
                socket.on('error', function(data) {
                    console.error('WebSocket error:', data);
                    // If we get a 400 error, it might be a stale session ID
                    if (data && data.message && data.message.includes('400')) {
                        console.log('[WS] Stale session ID detected, forcing reconnection');
                        socket.disconnect();
                        setTimeout(() => socket.connect(), 1000);
                    }
                });
                
                socket.on('live_odds_response', function(data) {
                    console.log('Received immediate live odds response:', data);
                    handleLiveOddsUpdate(data);
                });
                
                // Balance update listeners
                socket.on('balance:update', function(data) {
                    console.log('[BAL] WebSocket balance update:', data);
                    updateBalanceUI(data.balance);
                });
                
                socket.on('bet:placed', function(data) {
                    console.log('[BAL] Bet placed, refreshing balance');
                    refreshUserBalance();
                });
                
                socket.on('bet:settled', function(data) {
                    console.log('[BAL] Bet settled, refreshing balance');
                    refreshUserBalance();
                });
                
            } catch (error) {
                console.error('Failed to initialize WebSocket:', error);
            } finally {
                webSocketInitialized = true;
            }
        }
        
        function handleLiveOddsUpdate(data) {
            console.log('🎯 Received live odds update:', data);
            
            if (data.sport === currentSport && data.odds) {
                // Check if this is a pre-market odds update (full events data)
                if (Array.isArray(data.odds) && data.odds.length > 0 && data.odds[0].odds) {
                    console.log(`✅ Pre-market odds update received for ${currentSport} - ${data.odds.length} events`);
                    
                    // Update the events data with new odds
                    eventsData[currentSport] = data.odds;
                    
                    // Refresh the display immediately
                    displayEvents();
                    
                    // Update bet slip if there are bets
                    if (betSlip.length > 0) {
                        updateBetSlipOdds();
                    }
                    
                    // Show notification to user
                    showLiveOddsNotification(`${currentSport} odds updated!`);
                    
                } else if (data.odds.live_odds) {
                    // This is a live odds update (during match)
                    console.log(`🔴 Live odds update received for ${currentSport}`);
                    
                    // Update events data with new live odds
                    data.odds.forEach(liveOdd => {
                        const matchingEvent = eventsData[currentSport]?.find(event => 
                            event.home_team === liveOdd.home_team && 
                            event.away_team === liveOdd.away_team
                        );
                        if (matchingEvent) {
                            matchingEvent.live_odds = liveOdd.live_odds;
                            console.log(`Updated live odds for ${liveOdd.home_team} vs ${liveOdd.away_team}`);
                        }
                    });
                    
                    // Refresh the display
                    displayEvents();
                    
                    // Update bet slip if there are bets
                    if (betSlip.length > 0) {
                        updateBetSlipOdds();
                    }
                }
            }
        }
        
        function handleSpecificMatchUpdate(data) {
            // Handle updates for specific matches
            const matchingEvent = eventsData[currentSport]?.find(event => 
                event.match_id === data.match_id
            );
            if (matchingEvent) {
                matchingEvent.live_odds = data.odds;
                displayEvents();
            }
        }
        
        function requestImmediateLiveOdds() {
            console.log('Requesting immediate live odds...');
            
            // Show loading state
            const refreshBtn = document.querySelector('.refresh-btn');
            const originalText = refreshBtn.textContent;
            refreshBtn.textContent = '⏳ Loading...';
            refreshBtn.disabled = true;
            
            if (socket && websocketConnected) {
                socket.emit('request_live_odds', { sport: currentSport });
            } else {
                console.log('WebSocket not connected, trying direct API call...');
                // Fallback to direct API call
                fetch(`${API_BASE}/api/sports/events/${currentSport}`)
                    .then(response => response.json())
                    .then(data => {
                        console.log('Direct API response:', data);
                        handleLiveOddsUpdate({ sport: currentSport, odds: data });
                    })
                    .catch(error => {
                        console.error('Error fetching live odds:', error);
                    });
            }
            
            // Reset button after 2 seconds
            setTimeout(() => {
                refreshBtn.textContent = originalText;
                refreshBtn.disabled = false;
            }, 2000);
        }
        
        function forceRefreshLiveOdds() {
            console.log('Force refreshing from JSON data...');
            
            // Reload events from JSON data
            loadEvents(currentSport)
                .then(() => {
                    console.log('Events reloaded from JSON successfully');
                    // Also trigger bet slip update
                    if (betSlip.length > 0) {
                        updateBetSlipOdds();
                    }
                })
                .catch(error => {
                    console.error('Error force refreshing from JSON:', error);
                });
        }
        

        
        function updateWebSocketStatus(connected) {
            const statusElement = document.getElementById('websocketStatus');
            if (statusElement) {
                if (connected) {
                    statusElement.textContent = '🟢 Connected';
                    statusElement.className = 'status-indicator connected';
                } else {
                    statusElement.textContent = '🔴 Disconnected';
                    statusElement.className = 'status-indicator disconnected';
                }
            }
        }
        
        // DISABLED: This function is no longer needed since we have intelligent live odds updates
        // that only refresh the UI when there are actual odds changes
        function startAutoRefresh() {
            // Clear existing interval
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
            }
            
            // DISABLED: Auto-refresh from JSON data every 30 seconds
            // This was causing constant UI refreshes even when no data changed
            // Now replaced with intelligent live odds system that only updates when needed
            console.log('🚫 Auto-refresh disabled - using intelligent live odds system instead');
            /*
            autoRefreshInterval = setInterval(() => {
                console.log('Auto-refreshing from JSON data...');
                // Only refresh events data without changing sport selection
                const currentSportBeforeRefresh = currentSport;
                loadEvents(currentSport).then(() => {
                    console.log('Events refreshed from JSON successfully');
                    // Ensure sport selection didn't change
                    if (currentSport !== currentSportBeforeRefresh) {
                        currentSport = currentSportBeforeRefresh;
                        console.log('Restored sport selection to:', currentSport);
                    }
                    // Update markets for the current sport
                    updateBettingMarkets();
                    // Update bet slip if there are bets
                    if (betSlip.length > 0) {
                        updateBetSlipOdds();
                    }
                }).catch(error => {
                        console.error('Auto-refresh error:', error);
                    });
            }, 30000); // Changed from 5000 (5 seconds) to 30000 (30 seconds)
            */
        }
        

        
        // DISABLED: This function is no longer needed since auto-refresh is disabled
        function stopAutoRefresh() {
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
                autoRefreshInterval = null;
            }
            console.log('🚫 Auto-refresh already disabled');
        }
        
        // Search functionality
        
        function handleSearch(query) {
            // Clear previous timeout
            if (searchTimeout) {
                clearTimeout(searchTimeout);
            }
            
            // Debounce search to avoid too many calls
            searchTimeout = setTimeout(() => {
                performSearch(query);
            }, 300); // 300ms delay
        }
        
        function showSearchSuggestions(searchTerm, allEvents) {
            // Get unique teams and leagues for suggestions
            const teams = new Set();
            const leagues = new Set();
            
            allEvents.forEach(event => {
                if (event.home_team) teams.add(event.home_team);
                if (event.away_team) teams.add(event.away_team);
                if (event.league) leagues.add(event.league);
            });
            
            // Find similar terms
            const similarTeams = Array.from(teams).filter(team => 
                team.toLowerCase().includes(searchTerm.substring(0, 3))
            ).slice(0, 3);
            
            const similarLeagues = Array.from(leagues).filter(league => 
                league.toLowerCase().includes(searchTerm.substring(0, 3))
            ).slice(0, 2);
            
            if (similarTeams.length > 0 || similarLeagues.length > 0) {
                const container = document.getElementById('eventsContent');
                container.innerHTML = `
                    <div class="loading-text">
                        <div style="margin-bottom: 1rem;">🔍</div>
                        <div>No events found for "${searchTerm}"</div>
                        <div style="font-size: 0.9rem; color: rgba(255, 255, 255, 0.6); margin-top: 0.5rem;">
                            Try searching for different teams, leagues, or venues
                        </div>
                        ${similarTeams.length > 0 ? `
                            <div style="margin-top: 1rem; padding: 1rem; background: rgba(255, 255, 255, 0.05); border-radius: 8px;">
                                <div style="font-weight: 600; margin-bottom: 0.5rem;">Similar teams:</div>
                                <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                                    ${similarTeams.map(team => `
                                        <span style="background: #4ade80; color: #000; padding: 0.25rem 0.5rem; border-radius: 4px; cursor: pointer; font-size: 0.8rem;" onclick="searchFor('${team}')">${team}</span>
                                    `).join('')}
                                </div>
                            </div>
                        ` : ''}
                        ${similarLeagues.length > 0 ? `
                            <div style="margin-top: 0.5rem; padding: 1rem; background: rgba(255, 255, 255, 0.05); border-radius: 8px;">
                                <div style="font-weight: 600; margin-bottom: 0.5rem;">Similar leagues:</div>
                                <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                                    ${similarLeagues.map(league => `
                                        <span style="background: #4ade80; color: #000; padding: 0.25rem 0.5rem; border-radius: 4px; cursor: pointer; font-size: 0.8rem;" onclick="searchFor('${league}')">${league}</span>
                                    `).join('')}
                                </div>
                            </div>
                        ` : ''}
                    </div>
                `;
            }
        }
        
        function searchFor(term) {
            const searchInput = document.querySelector('.search-input');
            searchInput.value = term;
            performSearch(term);
        }
        
        function displaySearchResults(events, searchTerm) {
            const container = document.getElementById('eventsContent');
            
            if (events.length === 0) {
                container.innerHTML = `
                    <div class="loading-text">
                        <div style="margin-bottom: 1rem;">🔍</div>
                        <div>No events found for "${searchTerm}"</div>
                        <div style="font-size: 0.9rem; color: rgba(255, 255, 255, 0.6); margin-top: 0.5rem;">
                            Try searching for different teams, leagues, or venues
                        </div>
                    </div>
                `;
                return;
            }
            
            // Sort events (live first, then by relevance)
            const sortedEvents = events.sort((a, b) => {
                // Live matches come first
                if (a.is_live && !b.is_live) return -1;
                if (!a.is_live && b.is_live) return 1;
                
                // Then sort by date and time
                const dateA = new Date(a.date + ' ' + new Date().getFullYear() + ' ' + a.time);
                const dateB = new Date(b.date + ' ' + new Date().getFullYear() + ' ' + b.time);
                return dateA - dateB;
            });
            
            // Display with search highlighting
            if (currentView === 'list') {
                displayListViewWithHighlight(sortedEvents, container, searchTerm);
            } else {
                displayCouponViewWithHighlight(sortedEvents, container, searchTerm);
            }
        }
        
        function displayListViewWithHighlight(events, container, searchTerm) {
            // Filter out events that don't have odds for the current market (same logic as displayListView)
            const eventsWithOdds = events.filter(event => {
                if (!event.odds) return false;
                
                // For match_result (main market), check if event has match_result or home_away odds
                if (currentMarket === 'match_result') {
                    const hasMatchResultOdds = event.odds.match_result && 
                        Array.isArray(event.odds.match_result) && 
                        event.odds.match_result.length > 0;
                    const hasHomeAwayOdds = event.odds.home_away && 
                        Array.isArray(event.odds.home_away) && 
                        event.odds.home_away.length > 0;
                    return hasMatchResultOdds || hasHomeAwayOdds;
                }
                
                // For secondary markets, check if the event has odds for the current market
                const hasOddsForCurrentMarket = event.odds[currentMarket] && 
                    Array.isArray(event.odds[currentMarket]) && 
                    event.odds[currentMarket].length > 0;
                
                // Additional check: ensure the odds actually have valid values
                if (hasOddsForCurrentMarket) {
                    const marketData = event.odds[currentMarket];
                    // Check if any of the odds values are valid (not null, undefined, or empty strings)
                    return marketData.some(oddsValue => 
                        oddsValue !== null && 
                        oddsValue !== undefined && 
                        oddsValue !== '' && 
                        parseFloat(oddsValue) > 0
                    );
                }
                
                return hasOddsForCurrentMarket;
            });
            
            container.innerHTML = `
                <div class="table-header" style="grid-template-columns: ${getSportSpecificGridTemplate()};">
                    <div>Date & Time</div>
                    <div>Event</div>
                    ${getOddsColumns()}
                </div>
                ${eventsWithOdds.map(event => `
                    <div class="event-row ${event.is_live ? 'live-match' : ''}" style="grid-template-columns: ${getSportSpecificGridTemplate()};">
                        <div class="event-time">
                            ${formatEventTime(event)}
                            ${event.is_live ? '<span class="live-indicator">🔴 LIVE</span>' : ''}
                            <div class="match-status">
                                ${formatMatchStatus(event.status)}
                            </div>
                        </div>
                        <div class="event-info">
                            <div class="event-teams">
                                ${highlightSearchTerm(`${event.home_team} vs ${event.away_team}`, searchTerm)}
                                ${event.is_live ? `<span class="live-score">${event.home_score} - ${event.away_score}</span>` : ''}
                            </div>
                            <div class="event-league">${highlightSearchTerm(event.league || 'Unknown League', searchTerm)}</div>
                        </div>
                        ${generateOddsButtons(event, currentMarket)}
                    </div>
                `).join('')}
            `;
        }
        
        function displayCouponViewWithHighlight(events, container, searchTerm) {
            // Filter out events that don't have odds for the current market (same logic as displayListView)
            const eventsWithOdds = events.filter(event => {
                if (!event.odds) return false;
                
                // For match_result (main market), check if event has match_result or home_away odds
                if (currentMarket === 'match_result') {
                    const hasMatchResultOdds = event.odds.match_result && 
                        Array.isArray(event.odds.match_result) && 
                        event.odds.match_result.length > 0;
                    const hasHomeAwayOdds = event.odds.home_away && 
                        Array.isArray(event.odds.home_away) && 
                        event.odds.home_away.length > 0;
                    return hasMatchResultOdds || hasHomeAwayOdds;
                }
                
                // For secondary markets, check if the event has odds for the current market
                const hasOddsForCurrentMarket = event.odds[currentMarket] && 
                    Array.isArray(event.odds[currentMarket]) && 
                    event.odds[currentMarket].length > 0;
                
                // Additional check: ensure the odds actually have valid values
                if (hasOddsForCurrentMarket) {
                    const marketData = event.odds[currentMarket];
                    // Check if any of the odds values are valid (not null, undefined, or empty strings)
                    return marketData.some(oddsValue => 
                        oddsValue !== null && 
                        oddsValue !== undefined && 
                        oddsValue !== '' && 
                        parseFloat(oddsValue) > 0
                    );
                }
                
                return hasOddsForCurrentMarket;
            });
            
            container.innerHTML = `
                <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 1rem; padding: 1rem;">
                    ${eventsWithOdds.map(event => `
                        <div style="background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 12px; padding: 1rem; transition: all 0.3s ease;">
                            <div style="text-align: center; margin-bottom: 1rem;">
                                <div style="font-size: 0.9rem; color: #fbbf24; margin-bottom: 0.5rem;">${formatEventTime(event)}</div>
                                <div style="font-weight: 600; margin-bottom: 0.25rem;">${highlightSearchTerm(`${event.home_team} VS ${event.away_team}`, searchTerm)}</div>
                                <div style="font-size: 0.8rem; color: rgba(255, 255, 255, 0.6);">${highlightSearchTerm(event.league || 'Unknown League', searchTerm)}</div>
                            </div>
                            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.5rem;">
                                ${generateOddsButtons(event, currentMarket)}
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
        }
        
        function highlightSearchTerm(text, searchTerm) {
            if (!searchTerm || !text) return text;
            
            const regex = new RegExp(`(${searchTerm})`, 'gi');
            return text.replace(regex, '<mark style="background: #4ade80; color: #000; padding: 0.1rem 0.2rem; border-radius: 3px;">$1</mark>');
        }
        
        function toggleClearButton(input) {
            const clearButton = input.parentElement.querySelector('.search-clear');
            if (input.value.length > 0) {
                clearButton.classList.add('visible');
            } else {
                clearButton.classList.remove('visible');
            }
        }
        
        function clearSearch() {
            const searchInput = document.querySelector('.search-input');
            searchInput.value = '';
            currentSearchTerm = '';
            document.querySelector('.search-clear').classList.remove('visible');
            displayEvents(); // Show all events
        }
        
        function restoreSearchState() {
            const searchInput = document.querySelector('.search-input');
            if (currentSearchTerm && currentSearchTerm.trim() !== '') {
                searchInput.value = currentSearchTerm;
                document.querySelector('.search-clear').classList.add('visible');
            }
        }

        // Handle Google OAuth redirect: token may be provided in URL hash
        if (window.location.hash && window.location.hash.startsWith('#token=')) {
            const tokenFromHash = decodeURIComponent(window.location.hash.substring('#token='.length + 0));
            if (tokenFromHash) {
                localStorage.setItem('token', tokenFromHash);
                // Clean hash from URL without reloading
                history.replaceState(null, document.title, window.location.pathname + window.location.search);
            }
        }
        
        // Fallback: if server set a cookie with token, migrate it into localStorage and clear the cookie
        try {
            const cookies = document.cookie ? document.cookie.split(';').map(s => s.trim()) : [];
            const cookiePair = cookies.find(c => c.startsWith('app_token='));
            if (cookiePair) {
                const tokenFromCookie = decodeURIComponent(cookiePair.split('=')[1] || '');
                if (tokenFromCookie) {
                    localStorage.setItem('token', tokenFromCookie);
                    // Clear the cookie
                    document.cookie = 'app_token=; Max-Age=0; path=/; samesite=Lax';
                }
            }
        } catch (e) { /* ignore */ }
        
        // Authentication is now handled by the bootstrapAuth function above
        console.log('🔒 Authentication handled by bootstrapAuth function');
        
        // Set a flag to indicate that auth is being handled
        window.AUTH_BEING_HANDLED = true;

        // Update the search input event listener to use debounced search
        const searchInput = document.getElementById('searchInput');
        if (searchInput) {
            searchInput.addEventListener('input', function(e) {
                const searchTerm = e.target.value;
                debouncedSearch(searchTerm);
            });
        }

        // Performance optimization: Clear time cache when switching sports
        function clearTimeCache() {
            timeFormatCache.clear();
        }

        // Update selectSport to use cached data
        function selectSport(sport) {
            console.log(`🎯 Selecting sport: ${sport}`);
            currentSport = sport;
            console.log(`Current sport set to: ${currentSport}`);
            document.getElementById('currentSport').textContent = sport.charAt(0).toUpperCase() + sport.slice(1);
            
            // Clear time cache for new sport
            clearTimeCache();
            
            // Update sports display to show active state
            updateSportsActiveState(sport);
            
            // Update betting markets for the new sport
            updateBettingMarkets();
            
            // Load events for the selected sport (now from cache - instant!)
            loadEvents(sport);
            
            // Restart odds update checker for the new sport
            if (typeof startOddsUpdateChecker === 'function') {
                startOddsUpdateChecker();
            }
        }
        
        // Loading indicator functions
        function showLoadingIndicator() {
            const indicator = document.getElementById('loadingIndicator');
            if (indicator) {
                indicator.style.display = 'flex';
            }
        }
        
        function hideLoadingIndicator() {
            const indicator = document.getElementById('loadingIndicator');
            if (indicator) {
                indicator.style.display = 'none';
            }
        }

        // Periodic odds update checker for live pre-match odds
        let oddsUpdateInterval = null;
        
        function startOddsUpdateChecker() {
            console.log('🚀 startOddsUpdateChecker FUNCTION CALLED!');
            
            // Check if already running
            if (oddsUpdateInterval || window.oddsUpdateInterval) {
                console.log('🔄 Periodic odds checker already running, restarting...');
                if (oddsUpdateInterval) clearInterval(oddsUpdateInterval);
                if (window.oddsUpdateInterval) clearInterval(window.oddsUpdateInterval);
            }
            
            // Check for odds updates every 30 seconds for ALL SPORTS
            oddsUpdateInterval = setInterval(async () => {
                const now = new Date().toISOString();
                console.log(`🔍 PERIODIC CHECK [${now}]: Starting periodic check...`);
                
                // Get all available sports from window.eventsData (global cache)
                let allSports = Object.keys(window.eventsData || {});
                
                console.log('🔍 PERIODIC CHECK: window.eventsData keys:', Object.keys(window.eventsData || {}));
                console.log('🔍 PERIODIC CHECK: window.eventsData content:', window.eventsData);
                console.log('🔍 PERIODIC CHECK: allSports array:', allSports);
                console.log('🔍 PERIODIC CHECK: allSports length:', allSports.length);
                
                // If no sports in memory cache, get them from backend
                if (allSports.length === 0) {
                    console.log('🔍 PERIODIC CHECK: No sports in memory cache, fetching from backend...');
                    try {
                        const sportsResponse = await fetch(`${API_BASE}/api/sports`, { credentials: 'include' });
                        if (sportsResponse.ok) {
                            const sportsData = await sportsResponse.json();
                            allSports = Object.keys(sportsData);
                            console.log('🔍 PERIODIC CHECK: Fetched sports from backend:', allSports);
                        } else {
                            console.log('🔍 PERIODIC CHECK: Failed to fetch sports from backend, skipping...');
                            return;
                        }
                    } catch (error) {
                        console.log('🔍 PERIODIC CHECK: Error fetching sports from backend:', error);
                        return;
                    }
                }
                
                if (allSports.length === 0) {
                    // Last resort: check current sport if available
                    if (currentSport) {
                        console.log(`🔍 PERIODIC CHECK: No sports data available, checking current sport: ${currentSport}`);
                        allSports = [currentSport];
                    } else {
                        console.log('🔍 PERIODIC CHECK: No sports data available and no current sport, skipping...');
                        return;
                    }
                }
                
                console.log(`🔍 PERIODIC CHECK: Checking odds updates for ${allSports.length} sports: ${allSports.join(', ')}`);
                
                let processedCount = 0;
                console.log(`🔍 PERIODIC CHECK: About to start loop with allSports:`, allSports);
                console.log(`🔍 PERIODIC CHECK: allSports.length:`, allSports.length);
                console.log(`🔍 PERIODIC CHECK: allSports type:`, typeof allSports);
                console.log(`🔍 PERIODIC CHECK: allSports is Array:`, Array.isArray(allSports));
                // Check each sport for updates
                for (const sport of allSports) {
                    try {
                        console.log(`🔍 PERIODIC CHECK: ===== STARTING CHECK FOR ${sport.toUpperCase()} =====`);
                        console.log(`🔍 PERIODIC CHECK: Checking for ${sport} odds updates...`);
                        console.log(`🔍 PERIODIC CHECK: This should call /api/sports/odds-status/${sport}`);
                        console.log(`🔍 PERIODIC CHECK: Loop iteration ${processedCount + 1} of ${allSports.length}`);
                        
                        console.log(`🔍 PERIODIC CHECK: Calling /api/sports/odds-status/${sport}`);
                        const statusResponse = await fetch(`${API_BASE}/api/sports/odds-status/${sport}`, {
                            credentials: 'include'
                        });
                        console.log(`🔍 PERIODIC CHECK: Status response received for ${sport}:`, statusResponse.status);
                        
                        if (statusResponse.ok) {
                            const statusData = await statusResponse.json();
                            
                            if (statusData.has_data && statusData.last_updated) {
                                // Check if our cache is older than the backend update
                                const cacheKey = `events_cache_${sport}`;
                                const cacheTimestamp = localStorage.getItem(`${cacheKey}_timestamp`);
                                const backendTimestamp = new Date(statusData.last_updated).getTime();
                                const localTimestamp = parseInt(cacheTimestamp) || 0;
                                
                                if (backendTimestamp > localTimestamp) {
                                    console.log(`🎯 Periodic check detected new odds for ${sport}! Updating...`);
                                    
                                    // Fetch fresh data
                                    const liveResponse = await fetch(`${API_BASE}/api/sports/events/${sport}`, {
                                        credentials: 'include'
                                    });
                                    
                                    if (liveResponse.ok) {
                                        const liveData = await liveResponse.json();
                                        
                                        if (liveData && liveData.length > 0) {
                                            // Update cache with fresh data
                                            localStorage.setItem(cacheKey, JSON.stringify(liveData));
                                            localStorage.setItem(`${cacheKey}_timestamp`, Date.now().toString());
                                            
                                            // Update memory cache
                                            window.eventsData[sport] = liveData;
                                            
                                            // Only update frontend if this is the currently displayed sport
                                            if (sport === currentSport) {
                                                displayEvents();
                                                updateBettingMarkets();
                                                console.log(`✅ Frontend updated with periodic check for ${sport} (current sport)`);
                                            } else {
                                                console.log(`✅ Cache updated for ${sport} (background update)`);
                                            }
                                        }
                                    }
                                } else {
                                    console.log(`ℹ️ PERIODIC CHECK: No new odds for ${sport} (cache is current)`);
                                }
                            } else {
                                console.log(`ℹ️ PERIODIC CHECK: No odds data available for ${sport}`);
                            }
                        } else {
                            console.log(`⚠️ PERIODIC CHECK: Failed to get odds status for ${sport}: ${statusResponse.status}`);
                        }
                        
                        processedCount++;
                        console.log(`🔍 PERIODIC CHECK: ===== COMPLETED CHECK FOR ${sport.toUpperCase()} =====`);
                        console.log(`🔍 PERIODIC CHECK: Progress: ${processedCount}/${allSports.length} sports processed`);
                        
                    } catch (error) {
                        console.log(`❌ Periodic odds check failed for ${sport}:`, error);
                        processedCount++;
                        console.log(`🔍 PERIODIC CHECK: ===== ERROR COMPLETED CHECK FOR ${sport.toUpperCase()} =====`);
                        console.log(`🔍 PERIODIC CHECK: Progress: ${processedCount}/${allSports.length} sports processed`);
                    }
                }
                
                console.log(`🔍 PERIODIC CHECK: Loop finished. Processed ${processedCount} sports out of ${allSports.length}`);
                console.log(`✅ PERIODIC CHECK: Completed checking all ${allSports.length} sports`);
                
            }, 30000); // Check every 30 seconds
            
            // Store in global window object for tracking
            window.oddsUpdateInterval = oddsUpdateInterval;
            
            console.log('✅ Started periodic odds update checker (30s interval) - checking ALL sports');
            console.log('🔍 DEBUG: First periodic check will run in 30 seconds');
            console.log('🔍 DEBUG: Current window.eventsData state:', Object.keys(window.eventsData || {}));
        }
        
        // Debug function to manually test periodic checker
        function testPeriodicChecker() {
            console.log('🧪 MANUAL TEST: Testing periodic checker...');
            console.log('🧪 Current window.eventsData:', window.eventsData);
            console.log('🧪 Current currentSport:', currentSport);
            console.log('🧪 Current oddsUpdateInterval:', !!oddsUpdateInterval);
            console.log('🧪 Current window.oddsUpdateInterval:', !!window.oddsUpdateInterval);
            
            // Force run the periodic check
            if (typeof startOddsUpdateChecker === 'function') {
                console.log('🧪 Restarting periodic checker...');
                startOddsUpdateChecker();
            }
        }
        
        // Make test function available globally
        window.testPeriodicChecker = testPeriodicChecker;
        
        function stopOddsUpdateChecker() {
            if (oddsUpdateInterval) {
                clearInterval(oddsUpdateInterval);
                oddsUpdateInterval = null;
            }
            if (window.oddsUpdateInterval) {
                clearInterval(window.oddsUpdateInterval);
                window.oddsUpdateInterval = null;
            }
            console.log('🛑 Stopped periodic odds update checker');
        }



        function getAvailableMarketsForSport(sport) {
            // Define available markets for each sport
            const sportMarkets = {
                'soccer': ['match_result', 'both_teams_score', 'correct_score', 'over_under'],
                'basketball': ['match_result', 'over_under', 'asian_handicap'],
                'tennis': ['match_result', 'set_betting', 'games_over_under'],
                'baseball': ['match_result', 'correct_score', 'over_under'],
                'hockey': ['match_result', 'both_teams_score', 'over_under'],
                'volleyball': ['match_result', 'set_betting', 'over_under'],
                'cricket': ['match_result', 'most_sixes', 'most_fours', 'most_run_outs'],
                'mma': ['match_result', 'method_of_victory', 'round_betting'],
                'boxing': ['match_result', 'method_of_victory', 'round_betting'],
                'golf': ['match_result', 'top_finisher', 'head_to_head'],
                'darts': ['match_result', 'correct_score', 'over_under'],
                'esports': ['match_result'],  // Esports only shows Match Winners (from home_away)
                'table_tennis': ['match_result', 'set_betting', 'games_over_under'],
                'handball': ['match_result', 'both_teams_score', 'over_under'],
                'rugby': ['match_result', 'handicap_result', 'over_under'],
                'rugbyleague': ['match_result', 'handicap_result', 'over_under'],
                'futsal': ['match_result', 'correct_score', 'over_under']
            };
            
            return sportMarkets[sport] || ['match_result'];
        }

        function formatMarketName(market) {
            const marketNames = {
                'match_result': 'Match Result',
                'both_teams_score': 'Both Teams Score',
                'correct_score': 'Correct Score',
                'over_under': 'Over/Under',
                'asian_handicap': 'Asian Handicap',
                'set_betting': 'Set Betting',
                'games_over_under': 'Games Over/Under',
                'handicap_result': 'Handicap Result',
                'method_of_victory': 'Method of Victory',
                'round_betting': 'Round Betting',
                'top_finisher': 'Top Finisher',
                'head_to_head': 'Head to Head'
            };
            
            return marketNames[market] || market.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
        }







        function formatMatchStatus(status) {
            if (!status) return '';
            
            const statusMap = {
                'live': '🔴 LIVE',
                'finished': '✅ FINISHED',
                'scheduled': '⏰ SCHEDULED',
                'postponed': '⏸️ POSTPONED',
                'cancelled': '❌ CANCELLED',
                'suspended': '⏸️ SUSPENDED'
            };
            
            return statusMap[status.toLowerCase()] || status;
        }

        // Clear all cached data to fix odds mismatch
        function clearAllCache() {
            try {
                console.log('🧹 Clearing all frontend cache...');
                
                // Clear all sports cache
                const keysToRemove = [];
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && (key.startsWith('events_cache_') || key.startsWith('odds_cache_') || key.startsWith('last_force_refresh'))) {
                        keysToRemove.push(key);
                    }
                }
                
                keysToRemove.forEach(key => {
                    localStorage.removeItem(key);
                    console.log(`🗑️ Removed cache key: ${key}`);
                });
                
                // Clear memory cache
                eventsData = {};
                
                console.log('✅ All cache cleared successfully');
                
                // Force refresh current sport if one is selected
                if (currentSport) {
                    console.log(`🔄 Forcing refresh for ${currentSport}...`);
                    loadEvents(currentSport, true);
                }
                
                return true;
            } catch (error) {
                console.error('❌ Error clearing cache:', error);
                return false;
            }
        }

        // Add cache clear button to the UI
        function addCacheClearButton() {
            const topBar = document.querySelector('.top-bar');
            if (topBar && !document.getElementById('clear-cache-btn')) {
                const clearBtn = document.createElement('button');
                clearBtn.id = 'clear-cache-btn';
                clearBtn.innerHTML = '🔄 Clear Cache';
                clearBtn.className = 'cache-clear-btn';
                clearBtn.onclick = clearAllCache;
                clearBtn.style.cssText = `
                    background: #e74c3c;
                    color: white;
                    border: none;
                    padding: 8px 16px;
                    border-radius: 4px;
                    cursor: pointer;
                    margin-left: 10px;
                    font-size: 12px;
                `;
                topBar.appendChild(clearBtn);
            }
        }

        // Add cache clear button
        addCacheClearButton();





        // LIVE PRE-MARKET ODDS: Proactive loading for immediate availability
        async function preloadAllSportsEvents() {
            try {
                console.log('🚀 Starting live pre-market odds preloading...');
                
                if (!sportsData) return;
                
                const sportsList = Array.isArray(sportsData) ? 
                    sportsData.map(sport => sport.name) : 
                    Object.keys(sportsData);
                
                console.log(`📦 Preloading events for ${sportsList.length} sports for immediate odds display...`);
                
                // Load events for all sports in parallel (limited concurrency)
                const batchSize = 2; // Reduced from 3 to 2 for better server performance
                for (let i = 0; i < sportsList.length; i += batchSize) {
                    const batch = sportsList.slice(i, i + batchSize);
                    const promises = batch.map(sport => loadEvents(sport, false));
                    
                    await Promise.allSettled(promises);
                    
                    // Increased delay between batches for server-friendliness
                    if (i + batchSize < sportsList.length) {
                        await new Promise(resolve => setTimeout(resolve, 500));
                    }
                }
                
                console.log('✅ Live pre-market odds preloading completed');
                
            } catch (error) {
                console.error('❌ Error during live odds preloading:', error);
            }
        }

        // LIVE ODDS UPDATE SYSTEM: Connect to backend services for immediate updates
        let liveOddsUpdateInterval = null;
        let lastOddsCheck = {};
        let isUpdatingOdds = false; // Prevent multiple simultaneous updates
        
        // Initialize live odds update system
        let liveOddsSystemInitialized = false;
        
        function initializeLiveOddsSystem() {
            if (liveOddsSystemInitialized) {
                console.log('🚫 Live Odds Update System already initialized, skipping...');
                return;
            }
            
            console.log('🚀 Initializing Live Odds Update System...');
            
            // Start checking for live odds updates every 30 seconds (less aggressive)
            liveOddsUpdateInterval = setInterval(checkForLiveOddsUpdates, 30000);
            
            liveOddsSystemInitialized = true;
            console.log('✅ Live Odds Update System initialized - checking for updates every 30 seconds');
        }
        
        // Check for live odds updates from backend services
        async function checkForLiveOddsUpdates() {
            try {
                if (!currentSport || isUpdatingOdds) return;
                
                console.log(`🔍 Checking for live odds updates for ${currentSport}...`);
                
                // Check if we have a cache timestamp for this sport
                const cacheKey = `events_cache_${currentSport}`;
                const cacheTimestamp = localStorage.getItem(`${cacheKey}_timestamp`);
                
                if (!cacheTimestamp) {
                    console.log(`📭 No cache timestamp found for ${currentSport}, skipping live check`);
                    return;
                }
                
                // Get the last time we checked for this sport
                const lastCheck = lastOddsCheck[currentSport] || 0;
                const now = Date.now();
                
                // Only check if enough time has passed (avoid too frequent checks)
                if (now - lastCheck < 25000) { // 25 seconds minimum between checks (more conservative)
                    return;
                }
                
                lastOddsCheck[currentSport] = now;
                
                // Set flag to prevent concurrent updates
                isUpdatingOdds = true;
                
                try {
                    // Fetch fresh data to check for updates
                    const response = await fetch(`${API_BASE}/api/sports/events/${currentSport}`, {
                        credentials: 'include'
                    });
                    
                    if (response.ok) {
                        const freshData = await response.json();
                        
                        // Check if we have new odds data
                        if (freshData && freshData.length > 0) {
                            const hasNewOdds = freshData.some(event => 
                                event.odds && Object.keys(event.odds).length > 0
                            );
                            
                            if (hasNewOdds) {
                                // Check if this is actually new data by comparing with current cache
                                const currentCacheKey = `events_cache_${currentSport}`;
                                const currentCachedData = localStorage.getItem(currentCacheKey);
                                
                                if (currentCachedData) {
                                    try {
                                        const currentData = JSON.parse(currentCachedData);
                                        
                                        // INTELLIGENT COMPARISON: Only update if odds actually changed
                                        const oddsChanged = hasSignificantOddsChanges(currentData, freshData);
                                        
                                        if (oddsChanged) {
                                            console.log(`🎯 SIGNIFICANT ODDS UPDATE DETECTED for ${currentSport}!`);
                                            
                                            // Update cache with fresh data
                                            localStorage.setItem(currentCacheKey, JSON.stringify(freshData));
                                            localStorage.setItem(`${currentCacheKey}_timestamp`, now.toString());
                                            
                                            // Update memory cache
                                            eventsData[currentSport] = freshData;
                                            
                                            // IMMEDIATE FRONTEND UPDATE
                                            displayEvents();
                                            updateBettingMarkets();
                                            
                                            console.log(`✅ Frontend updated with live odds for ${currentSport}`);
                                            
                                            // Show user notification
                                            showLiveOddsNotification(currentSport);
                                        } else {
                                            console.log(`ℹ️ No significant odds changes for ${currentSport}`);
                                        }
                                    } catch (e) {
                                        console.log(`⚠️ Error comparing odds data for ${currentSport}:`, e);
                                    }
                                } else {
                                    // No current cache, this is new data
                                    console.log(`🎯 NEW ODDS DATA for ${currentSport}!`);
                                    
                                    // Update cache and display
                                    localStorage.setItem(currentCacheKey, JSON.stringify(freshData));
                                    localStorage.setItem(`${currentCacheKey}_timestamp`, now.toString());
                                    eventsData[currentSport] = freshData;
                                    
                                    displayEvents();
                                    updateBettingMarkets();
                                    
                                    showLiveOddsNotification(currentSport);
                                }
                            }
                        }
                    }
                } finally {
                    // Always reset the flag
                    isUpdatingOdds = false;
                }
                
            } catch (error) {
                console.log(`❌ Error checking for live odds updates:`, error);
                isUpdatingOdds = false; // Reset flag on error
            }
        }
        
        // INTELLIGENT ODDS COMPARISON: Only detect meaningful odds changes
        function hasSignificantOddsChanges(oldData, newData) {
            try {
                // If data length is different, it's significant
                if (oldData.length !== newData.length) {
                    return true;
                }
                
                // Compare each event's odds for significant changes
                for (let i = 0; i < oldData.length; i++) {
                    const oldEvent = oldData[i];
                    const newEvent = newData[i];
                    
                    // Skip if event IDs don't match
                    if (oldEvent.id !== newEvent.id) {
                        continue;
                    }
                    
                    // Check if odds have changed significantly
                    if (oldEvent.odds && newEvent.odds) {
                        const oldOddsKeys = Object.keys(oldEvent.odds);
                        const newOddsKeys = Object.keys(newEvent.odds);
                        
                        // If odds structure changed, it's significant
                        if (oldOddsKeys.length !== newOddsKeys.length) {
                            return true;
                        }
                        
                        // Check for significant odds value changes (more than 0.1 difference)
                        for (const key of oldOddsKeys) {
                            if (newEvent.odds[key]) {
                                const oldValue = parseFloat(oldEvent.odds[key]);
                                const newValue = parseFloat(newEvent.odds[key]);
                                
                                if (!isNaN(oldValue) && !isNaN(newValue)) {
                                    const difference = Math.abs(newValue - oldValue);
                                    if (difference > 0.1) { // Only significant changes
                                        return true;
                                    }
                                }
                            }
                        }
                    }
                }
                
                // No significant changes detected
                return false;
                
            } catch (error) {
                console.log('⚠️ Error in odds comparison:', error);
                // If comparison fails, assume no significant changes to avoid unnecessary updates
                return false;
            }
        }
        
        // Show user notification for live odds updates
        function showLiveOddsNotification(sport) {
            try {
                // Create or update notification element
                let notification = document.getElementById('live-odds-notification');
                
                if (!notification) {
                    notification = document.createElement('div');
                    notification.id = 'live-odds-notification';
                    notification.style.cssText = `
                        position: fixed;
                        top: 20px;
                        right: 20px;
                        background: #4CAF50;
                        color: white;
                        padding: 15px 20px;
                        border-radius: 5px;
                        box-shadow: 0 4px 8px rgba(0,0,0,0.2);
                        z-index: 10000;
                        font-family: Arial, sans-serif;
                        font-size: 14px;
                        max-width: 300px;
                        animation: slideIn 0.5s ease-out;
                    `;
                    
                    // Add CSS animation
                    const style = document.createElement('style');
                    style.textContent = `
                        @keyframes slideIn {
                            from { transform: translateX(100%); opacity: 0; }
                            to { transform: translateX(0); opacity: 1; }
                        }
                        @keyframes slideOut {
                            from { transform: translateX(0); opacity: 1; }
                            to { transform: translateX(100%); opacity: 0; }
                        }
                    `;
                    document.head.appendChild(style);
                    
                    document.body.appendChild(notification);
                }
                
                // Update notification content
                notification.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <span style="font-size: 18px;">🎯</span>
                        <div>
                            <strong>Live Odds Update!</strong><br>
                            New odds available for ${sport.charAt(0).toUpperCase() + sport.slice(1)}
                        </div>
                    </div>
                `;
                
                // Auto-hide after 5 seconds
                setTimeout(() => {
                    if (notification) {
                        notification.style.animation = 'slideOut 0.5s ease-in';
                        setTimeout(() => {
                            if (notification && notification.parentNode) {
                                notification.parentNode.removeChild(notification);
                            }
                        }, 500);
                    }
                }, 5000);
                
            } catch (error) {
                console.log('❌ Error showing live odds notification:', error);
            }
        }
        
        // Stop live odds update system
        function stopLiveOddsSystem() {
            if (liveOddsUpdateInterval) {
                clearInterval(liveOddsUpdateInterval);
                liveOddsUpdateInterval = null;
                isUpdatingOdds = false; // Reset flag
                console.log('🛑 Live Odds Update System stopped');
            }
        }
    </script>

    <!-- Authentication handled by /login page -->
    

</body>
</html>

