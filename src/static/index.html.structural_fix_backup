<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GoalServe Sports Betting Platform</title>
    
    <!-- REDIRECT TRAP - Catches any code trying to redirect to login -->
    <script>
      (function() {
        // Tenant helper
        function tenant() {
          const seg = (location.pathname.split("/")[1] || "").trim();
          return seg && !["api","static","superadmin","login"].includes(seg) ? seg : "";
        }
        function escapeRegex(str) {
          return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }
        
        const tenantName = tenant();
        const LOGIN_RX = new RegExp(
        `^/(?:${tenantName ? escapeRegex(tenantName) + '|' : ''})login(?:\\b|/)`
        );
        console.log("LOGIN_RX is", LOGIN_RX);
                // 1) Trap all programmatic navigations
        const _assign = window.location.assign.bind(window.location);
        const _replace = window.location.replace.bind(window.location);

        function logAndMaybeBlock(target, how) {
          try { console.warn(`[NAV] ${how} ->`, target); console.trace(); } catch {}
          // If we've already confirmed auth OK, block any later move to /login
          if (window.__AUTH_OK && typeof target === "string" && LOGIN_RX.test(new URL(target, location.origin).pathname)) {
            console.warn("[NAV] blocked redirect to login after successful auth:", target);
            return true; // blocked
          }
          return false;
        }

        window.location.assign = function(url) {
          if (!logAndMaybeBlock(url, "assign")) _assign(url);
        };
        window.location.replace = function(url) {
          if (!logAndMaybeBlock(url, "replace")) _replace(url);
        };
        
        // No href redefinition - just log that we're monitoring
        console.log("[NAV] Navigation monitoring enabled (assign/replace/click)");

        // 2) Trap user-triggered navigations also
        window.addEventListener('click', (e) => {
          const a = e.target.closest && e.target.closest('a[href]');
          if (!a) return;
          const to = a.getAttribute('href') || '';
          if (LOGIN_RX.test(to) && window.__AUTH_OK) {
            e.preventDefault();
            console.warn("[NAV] blocked <a> to login after auth:", to);
          }
        }, true);

        // Expose tenant globally for other snippets
        window.__TENANT__ = tenant();
      })();
    </script>
    
    <!-- Dynamic Theme CSS -->
    <link id="theme-css" rel="stylesheet" type="text/css" href="/api/theme-css">
    <script>
        // Load theme CSS based on current subdomain
        function loadThemeCSS() {
            const path = window.location.pathname;
            const subdomain = path.split('/')[1]; // Get subdomain from path like /subdomain/...
            
            if (subdomain && subdomain !== 'static' && subdomain !== 'api') {
                const themeCssLink = document.getElementById('theme-css');
                themeCssLink.href = `/api/theme-css/${subdomain}`;
                
                // Also load theme data from database for dynamic updates
                loadThemeFromDatabase(subdomain);
            }
        }
        
        // Load theme data from database (using same logic as theme customizer)
        async function loadThemeFromDatabase(subdomain) {
            console.log('üîç loadThemeFromDatabase called with subdomain:', subdomain);
            try {
                const apiUrl = `/${subdomain}/api/public/load-theme`;
                console.log('üåê Fetching theme from:', apiUrl);
                
                const response = await fetch(apiUrl);
                console.log('üì° Response status:', response.status);
                
                if (response.ok) {
                    const themeData = await response.json();
                    console.log('‚úÖ Theme data loaded from database:', themeData);
                    
                    // Apply theme using same logic as theme customizer
                    applyThemeToPage(themeData);
                } else {
                    console.log('‚ùå Response not ok:', response.status, response.statusText);
                }
            } catch (error) {
                console.error('‚ùå Error loading theme:', error);
                console.log('Database theme not loaded, using CSS file only');
            }
        }
        
        // Apply theme to page (using same logic as theme customizer)
        function applyThemeToPage(theme) {
            console.log('üé® Applying theme to page:', theme);
            
            // Set CSS variables on document root (same as theme customizer)
            const cssVars = {
                '--primary-color': theme.primaryColor || '#22C55E',
                '--secondary-color': theme.secondaryColor || '#3b82f6',
                '--accent-color': theme.accentColor || '#22C55E',
                '--background-color': theme.backgroundColor || '#1A1A1A',
                '--text-color': theme.textColor || '#FFFFFF'
            };
            
            console.log('üé® CSS variables to set:', cssVars);
            
            // Set on document root for global access (same as theme customizer)
            Object.entries(cssVars).forEach(([key, value]) => {
                document.documentElement.style.setProperty(key, value);
                console.log(`üé® Set CSS variable ${key} = ${value}`);
            });
            
            console.log('‚úÖ CSS variables set on document root');
            
            // Apply font family if available
            if (theme.fontFamily) {
                document.body.style.fontFamily = theme.fontFamily;
                console.log('üé® Applied font family:', theme.fontFamily);
            }
            
            // Update logo text if available
            const logoText = document.querySelector('.logo-text');
            if (logoText && theme.sportsbookName) {
                logoText.textContent = theme.sportsbookName;
                console.log('üé® Updated logo text to:', theme.sportsbookName);
            }
            
            // Update logo icon if available
            const logoIcon = document.querySelector('.logo-icon');
            if (logoIcon && theme.logoType && theme.logoType !== 'default') {
                const logoMap = {
                    'crown': 'üëë',
                    'trophy': 'üèÜ',
                    'star': '‚≠ê',
                    'diamond': 'üíé',
                    'fire': 'üî•',
                    'lightning': '‚ö°',
                    'target': 'üéØ',
                    'default': '‚öΩ'
                };
                logoIcon.textContent = logoMap[theme.logoType] || '‚öΩ';
                console.log('üé® Updated logo icon to:', logoMap[theme.logoType] || '‚öΩ');
            }
            
            // Force a repaint to ensure changes are visible (same as theme customizer)
            document.body.style.display = 'none';
            document.body.offsetHeight; // Force reflow
            document.body.style.display = 'block';
            
            console.log('‚úÖ Theme applied successfully to page');
            
            // Debug: Check if CSS variables are actually set
            console.log('üîç Debug: Current CSS variables on document root:');
            console.log('--primary-color:', getComputedStyle(document.documentElement).getPropertyValue('--primary-color'));
            console.log('--background-color:', getComputedStyle(document.documentElement).getPropertyValue('--background-color'));
            console.log('--text-color:', getComputedStyle(document.documentElement).getPropertyValue('--text-color'));
        }
        
        // Load theme CSS immediately
        loadThemeCSS();
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-family, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif);
            background: var(--background-color, linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%));
            color: var(--text-color, #ffffff);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .header {
            background: var(--background-color, #2A2A2A);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding: 1rem 2rem;
            position: sticky;
            top: 0;
            z-index: 1000;
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 1400px;
            margin: 0 auto;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 1.5rem;
            font-weight: bold;
            color: #4ade80;
        }

        .logo-icon {
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, var(--primary-color, #4ade80), var(--secondary-color, #22c55e));
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
        }

        .search-container {
            flex: 1;
            max-width: 400px;
            margin: 0 2rem;
            position: relative;
        }

        .search-input {
            width: 100%;
            padding: 0.75rem 1rem 0.75rem 2.5rem;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 25px;
            color: var(--text-color, #ffffff);
            font-size: 0.9rem;
            outline: none;
            transition: all 0.3s ease;
        }

        .search-input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        .search-input:focus {
            background: rgba(255, 255, 255, 0.15);
            border-color: var(--primary-color, #4ade80);
            box-shadow: 0 0 0 3px rgba(74, 222, 128, 0.1);
        }

        .search-icon {
            position: absolute;
            left: 0.75rem;
            top: 50%;
            transform: translateY(-50%);
            color: rgba(255, 255, 255, 0.6);
            font-size: 1rem;
        }
        
        .search-clear {
            position: absolute;
            right: 0.75rem;
            top: 50%;
            transform: translateY(-50%);
            color: rgba(255, 255, 255, 0.6);
            font-size: 1rem;
            cursor: pointer;
            display: none;
            transition: all 0.3s ease;
        }
        
        .search-clear:hover {
            color: #ef4444;
        }
        
        .search-clear.visible {
            display: block;
        }

        .user-section {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        .loading-indicator {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            color: #4ade80;
            font-size: 1rem;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .balance {
            background: linear-gradient(135deg, var(--primary-color, #4ade80), var(--secondary-color, #22c55e));
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-weight: 600;
            font-size: 1rem;
        }

        .user-menu {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 0.5rem 1rem;
            color: var(--text-color, #ffffff);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .user-menu:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .user-dropdown {
            position: absolute;
            top: 100%;
            right: 0;
            background: var(--background-color, rgba(26, 26, 46, 0.95));
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 0.5rem 0;
            margin-top: 0.5rem;
            min-width: 150px;
            z-index: 1000;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .dropdown-item {
            padding: 0.75rem 1rem;
            color: var(--text-color, #ffffff);
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }

        .dropdown-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .user-section {
            position: relative;
        }

        .main-container {
            display: flex;
            max-width: 1400px;
            margin: 0 auto;
            min-height: calc(100vh - 80px);
        }

        .sidebar {
            width: 280px;
            background: var(--background-color, #1A1A1A);
            backdrop-filter: blur(10px);
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            padding: 1.5rem;
            overflow-y: auto;
        }

        .sidebar-section {
            margin-bottom: 2rem;
        }

        .sidebar-title {
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 1rem;
        }

        .sport-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem 1rem;
            margin-bottom: 0.5rem;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .sport-item:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: var(--primary-color, #4ade80);
        }

        .sport-item.active {
            background: var(--primary-color, #22C55E);
            border-color: var(--primary-color, #22C55E);
            color: white;
        }

        .sport-info {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .sport-icon {
            font-size: 1.2rem;
        }

        .sport-name {
            font-weight: 500;
        }

        .event-count {
            background: rgba(255, 255, 255, 0.2);
            padding: 0.25rem 0.5rem;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .sport-item.active .event-count {
            background: rgba(0, 0, 0, 0.2);
            color: #000;
        }

        .filter-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem 1rem;
            margin-bottom: 0.5rem;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .filter-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .filter-info {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .filter-icon {
            font-size: 1rem;
        }

        .content-area {
            flex: 1;
            padding: 1.5rem;
            background: var(--background-color, #2A2A2A);
        }

        .breadcrumb {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            font-size: 0.9rem;
            color: var(--text-color, rgba(255, 255, 255, 0.7));
        }

        .breadcrumb-separator {
            color: rgba(255, 255, 255, 0.4);
        }

        .content-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }
        
        .live-status {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        .status-indicator {
            font-size: 0.9rem;
            font-weight: 600;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .status-indicator.connected {
            background: rgba(34, 197, 94, 0.2);
            border-color: var(--primary-color, #22C55E);
            color: var(--primary-color, #22C55E);
        }
        
        .status-indicator.disconnected {
            background: rgba(239, 68, 68, 0.2);
            border-color: #ef4444;
            color: #ef4444;
        }
        
        .refresh-btn {
            padding: 0.5rem 1rem;
            background: var(--primary-color, #22C55E);
            border: none;
            border-radius: 6px;
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }
        
        .refresh-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(74, 222, 128, 0.3);
        }
        
        /* Animations for bet slip updates */
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(74, 222, 128, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(74, 222, 128, 0); }
            100% { box-shadow: 0 0 0 0 rgba(74, 222, 128, 0); }
        }
        
        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        @keyframes slideOut {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(100%); opacity: 0; }
        }

        .view-options {
            display: flex;
            gap: 0.5rem;
        }

        .view-btn {
            padding: 0.5rem 1rem;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: #ffffff;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }

        .view-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .view-btn.active {
            background: var(--primary-color, #22C55E);
            border-color: var(--primary-color, #22C55E);
        }

        .bet-slip {
            width: 320px;
            background: var(--background-color, #1A1A1A);
            backdrop-filter: blur(10px);
            border-left: 1px solid rgba(255, 255, 255, 0.1);
            padding: 1.5rem;
            overflow-y: auto;
        }

        .bet-slip-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 1.5rem;
            padding: 1.25rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }
        
        .bet-slip-title {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-color, #ffffff);
        }

        .bet-count {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: white;
            padding: 0.25rem 0.6rem;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
            min-width: 20px;
            text-align: center;
            box-shadow: 0 2px 4px rgba(239, 68, 68, 0.3);
        }

        .bet-slip-controls {
            display: flex;
            align-items: center;
            gap: 1.25rem;
        }

        /* Modern Slider Toggle */
        .slider-toggle {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 30px;
            background: linear-gradient(135deg, #3b82f6, #2563eb);
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border: 1px solid #3b82f6;
        }

        .slider-toggle:hover {
            background: linear-gradient(135deg, #2563eb, #1d4ed8);
            transform: scale(1.05);
        }

        .slider-toggle.active {
            background: linear-gradient(135deg, #4ade80, #22c55e);
            border-color: #4ade80;
            box-shadow: 0 0 0 3px rgba(74, 222, 128, 0.1);
        }

        .slider-toggle.active:hover {
            background: linear-gradient(135deg, #22c55e, #16a34a);
            transform: scale(1.05);
        }

        .slider-toggle .slider-thumb {
            position: absolute;
            top: 2px;
            left: 2px;
            width: 26px;
            height: 26px;
            background: white;
            border-radius: 50%;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .slider-toggle.active .slider-thumb {
            transform: translateX(30px);
        }

        .slider-toggle .slider-label {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            font-size: 0.75rem;
            font-weight: 600;
            pointer-events: none;
            transition: all 0.3s ease;
        }

        .slider-toggle:not(.active) .slider-label {
            right: 8px;
            color: #000;
            font-weight: 700;
            text-shadow: none;
        }

        .slider-toggle.active .slider-label {
            left: 8px;
            color: #000;
            font-weight: 700;
            text-shadow: none;
        }

        .live-indicator {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            font-size: 0.75rem;
            font-weight: 600;
            color: #ef4444;
            animation: pulse 2s infinite;
        }

        .bet-slip-content {
            text-align: center;
            color: rgba(255, 255, 255, 0.6);
            padding: 2rem 0;
        }

        .login-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .login-modal {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 16px;
            padding: 2rem;
            width: 100%;
            max-width: 400px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }

        .login-title {
            text-align: center;
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 1.5rem;
            color: #4ade80;
        }

        .form-group {
            margin-bottom: 1rem;
        }

        .form-label {
            display: block;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
            font-weight: 500;
            color: rgba(255, 255, 255, 0.8);
        }

        .form-input {
            width: 100%;
            padding: 0.75rem;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: #ffffff;
            font-size: 1rem;
            outline: none;
            transition: all 0.3s ease;
        }

        .form-input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .form-input:focus {
            background: rgba(255, 255, 255, 0.15);
            border-color: #4ade80;
            box-shadow: 0 0 0 3px rgba(74, 222, 128, 0.1);
        }

        .login-btn {
            width: 100%;
            padding: 0.75rem;
            background: linear-gradient(135deg, #4ade80, #22c55e);
            border: none;
            border-radius: 8px;
            color: #000;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 1rem;
        }

        .login-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 10px 30px rgba(74, 222, 128, 0.3);
        }

        .login-footer {
            text-align: center;
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.9rem;
        }

        .login-footer a {
            color: #4ade80;
            text-decoration: none;
            font-weight: 500;
        }

        .login-footer a:hover {
            text-decoration: underline;
        }

        .loading-text {
            text-align: center;
            color: rgba(255, 255, 255, 0.6);
            padding: 2rem;
            font-size: 1.1rem;
        }

        .load-more-btn {
            display: block;
            width: 100%;
            padding: 1rem;
            margin: 1rem 0;
            background: linear-gradient(135deg, #4ade80, #22c55e);
            color: #000;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .load-more-btn:hover {
            background: linear-gradient(135deg, #22c55e, #16a34a);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(34, 197, 94, 0.3);
        }

        .events-table {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            overflow: hidden;
        }

        .market-tabs {
            display: flex;
            background: rgba(255, 255, 255, 0.05);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .market-tab {
            flex: 1;
            padding: 1rem;
            text-align: center;
            background: transparent;
            border: none;
            color: rgba(255, 255, 255, 0.7);
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
            font-weight: 500;
        }

        .market-tab:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
        }

        .market-tab.active {
            background: #3b82f6;
            color: #ffffff;
        }

        .no-markets-message {
            color: #fbbf24;
            text-align: center;
            padding: 1rem;
            font-style: italic;
            background: rgba(251, 191, 36, 0.1);
            border-radius: 8px;
            border: 1px solid rgba(251, 191, 36, 0.3);
        }

        .table-header {
            display: grid;
            grid-template-columns: 120px 1fr 120px 120px 120px;
                gap: 1rem;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.05);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            font-weight: 600;
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.8);
        }

        .event-row {
            display: grid;
            grid-template-columns: 120px 1fr 120px 120px 120px;
            gap: 1rem;
            padding: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            transition: all 0.3s ease;
            align-items: center;
        }

        .live-match {
            background: rgba(239, 68, 68, 0.1);
            border-left: 3px solid #ef4444;
        }

        .live-indicator {
            color: #ef4444;
            font-weight: bold;
            font-size: 0.8rem;
            margin-left: 0.5rem;
        }

        .live-score {
            color: #fbbf24;
            font-weight: bold;
            margin-left: 0.5rem;
            white-space: nowrap;
            display: inline-block;
        }

        .event-row:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .event-time {
            font-weight: 600;
            color: #fbbf24;
            font-size: 0.9rem;
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .match-status {
            font-size: 0.8rem;
            color: #4ade80;
            font-weight: 500;
        }

        .event-info {
            display: flex;
            flex-direction: column;
        }

        .event-teams {
            font-weight: 600;
            margin-bottom: 0.25rem;
        }

        .event-league {
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.6);
        }

        .odds-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            padding: 0.5rem;
            color: #ffffff;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            text-align: center;
        }

        .odds-btn:hover {
            background: #4ade80;
            border-color: #4ade80;
            color: #000;
            transform: translateY(-1px);
        }

        .odds-btn.selected {
            background: #4ade80;
            border-color: #4ade80;
            color: #000;
        }

        .live-odds-container {
            margin-top: 2rem;
            padding: 1.5rem;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            overflow-y: auto;
            max-height: 300px; /* Adjust as needed */
        }

        .live-odds-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .live-odds-header h3 {
            color: #4ade80;
            font-size: 1.1rem;
            font-weight: 600;
        }

        .live-odds-timer {
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.6);
        }

        .live-odds-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 1rem;
        }

        .live-odds-card {
            background: var(--background-color, rgba(26, 26, 46, 0.8));
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 1.25rem;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .live-odds-card:hover {
            background: rgba(255, 255, 255, 0.05);
            border-color: #4ade80;
        }

        .match-header {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .bet-slip-title {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-color, #ffffff);
        }

        .match-teams {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-color, #ffffff);
        }

        .vs {
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.9rem;
        }

        .live-score {
            font-size: 1.5rem;
            font-weight: bold;
            color: #fbbf24;
        }

        .match-status {
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.6);
        }

        .odds-markets {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .market-section h4 {
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 0.5rem;
        }

        .odds-row {
            display: flex;
            justify-content: space-around;
            gap: 1rem;
            font-size: 0.9rem;
            color: var(--text-color, #ffffff);
        }

        .odds-row .selection {
            font-weight: 500;
            color: var(--text-color, rgba(255, 255, 255, 0.8));
        }

        .odds-row .odds {
            font-weight: 600;
            color: #4ade80;
        }

        .match-progress {
            margin-top: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.6);
        }

        .progress-bar {
            flex: 1;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(135deg, #4ade80, #22c55e);
            border-radius: 4px;
            transition: width 0.3s ease-in-out;
        }

        .no-live-odds {
            text-align: center;
            color: rgba(255, 255, 255, 0.7);
            padding: 2rem;
        }

        @media (max-width: 1024px) {
            .main-container {
                flex-direction: column;
            }
            
            .sidebar {
                width: 100%;
                order: 2;
            }
            
            .content-area {
                order: 1;
            }
            
            .bet-slip {
                width: 100%;
                order: 3;
            }
            
            .header-content {
                flex-direction: column;
            gap: 1rem;
            }
            
            .search-container {
                margin: 0;
                max-width: 100%;
            }
        }

        @media (max-width: 768px) {
            .header {
                padding: 1rem;
            }
            
            .sidebar, .content-area, .bet-slip {
            padding: 1rem;
        }

            .table-header, .event-row {
                grid-template-columns: 80px 1fr 80px 80px 80px;
                gap: 0.5rem;
                padding: 0.75rem;
                font-size: 0.8rem;
            }
        }

        /* Custom Fancy Alert Styles */
        .custom-alert-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(8px);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            animation: fadeIn 0.3s ease-out;
        }

        .custom-alert {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border: 2px solid rgba(0, 255, 255, 0.3);
            border-radius: 20px;
            padding: 2rem;
            max-width: 400px;
            width: 90%;
            text-align: center;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
            position: relative;
            overflow: hidden;
            animation: slideIn 0.4s ease-out;
        }

        .custom-alert::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, #00ffff, #00ff88, #00ffff);
            animation: shimmer 2s infinite;
        }

        .custom-alert.success::before {
            background: linear-gradient(90deg, #00ff88, #00ffff, #00ff88);
        }

        .custom-alert.error::before {
            background: linear-gradient(90deg, #ff4444, #ff8844, #ff4444);
        }

        .custom-alert.warning::before {
            background: linear-gradient(90deg, #ffaa00, #ffff00, #ffaa00);
        }

        .custom-alert-icon {
            font-size: 4rem;
            margin-bottom: 1rem;
            animation: bounceIn 0.6s ease-out;
        }

        .custom-alert-title {
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 1rem;
            color: #ffffff;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        .custom-alert-message {
            font-size: 1.1rem;
            color: #b8c5d6;
            margin-bottom: 2rem;
            line-height: 1.5;
        }

        .custom-alert-button {
            background: linear-gradient(135deg, #00ffff 0%, #00ff88 100%);
            border: none;
            color: #1a1a2e;
            padding: 12px 32px;
            border-radius: 25px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 255, 255, 0.3);
        }

        .custom-alert-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 255, 255, 0.4);
        }

        .custom-alert-button:active {
            transform: translateY(0);
        }

        .custom-alert.success .custom-alert-button {
            background: linear-gradient(135deg, #00ff88 0%, #00ffff 100%);
            box-shadow: 0 4px 15px rgba(0, 255, 136, 0.3);
        }

        .custom-alert.success .custom-alert-button:hover {
            box-shadow: 0 6px 20px rgba(0, 255, 136, 0.4);
        }

        .custom-alert.error .custom-alert-button {
            background: linear-gradient(135deg, #ff4444 0%, #ff8844 100%);
            box-shadow: 0 4px 15px rgba(255, 68, 68, 0.3);
        }

        .custom-alert.error .custom-alert-button:hover {
            box-shadow: 0 6px 20px rgba(255, 68, 68, 0.4);
        }

        .custom-alert.warning .custom-alert-button {
            background: linear-gradient(135deg, #ffaa00 0%, #ffff00 100%);
            box-shadow: 0 4px 15px rgba(255, 170, 0, 0.3);
        }

        .custom-alert.warning .custom-alert-button:hover {
            box-shadow: 0 6px 20px rgba(255, 170, 0, 0.4);
        }

        /* Animations */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideIn {
            from { 
                opacity: 0;
                transform: translateY(-50px) scale(0.9);
            }
            to { 
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        @keyframes bounceIn {
            0% { 
                opacity: 0;
                transform: scale(0.3);
            }
            50% { 
                opacity: 1;
                transform: scale(1.05);
            }
            70% { 
                transform: scale(0.9);
            }
            100% { 
                opacity: 1;
                transform: scale(1);
            }
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        /* Responsive */
        @media (max-width: 480px) {
            .custom-alert {
                padding: 1.5rem;
                margin: 1rem;
            }
            
            .custom-alert-icon {
                font-size: 3rem;
            }
            
            .custom-alert-title {
                font-size: 1.3rem;
            }
            
            .custom-alert-message {
                font-size: 1rem;
            }
        }
    </style>
</head>
<body>
    <!-- Custom Fancy Alert Component -->
    <div class="custom-alert-overlay" id="customAlertOverlay">
        <div class="custom-alert" id="customAlert">
            <div class="custom-alert-icon" id="customAlertIcon">üéØ</div>
            <div class="custom-alert-title" id="customAlertTitle">Alert</div>
            <div class="custom-alert-message" id="customAlertMessage">This is a custom alert message.</div>
            <button class="custom-alert-button" id="customAlertButton" onclick="hideCustomAlert()">OK</button>
        </div>
    </div>

    <!-- Tenant + redirect helpers - must be defined BEFORE any auth code -->
    <script>
      // --- tenant + redirect helpers ---
      function getTenant() {
        // Use global tenant if available, otherwise parse from path
        return window.__TENANT__ || (() => {
          const seg = (location.pathname.split("/")[1] || "").trim();
          return seg && !["api","static","superadmin","login"].includes(seg) ? seg : "";
        })();
      }
      function redirectToTenantLogin() {
        const t = getTenant();
        // avoid duplicate redirects
        if (window.__redirecting) return;
        window.__redirecting = true;
        window.location.href = t ? `/${t}/login` : `/login`;
      }
      // normalize legacy hooks
      window.showLogin = redirectToTenantLogin;
      window.showRegister = redirectToTenantLogin;
    </script>

    <!-- Authentication check - runs immediately when page loads -->
    <script>
      (async function bootstrapAuth() {
        const meUrl = '/api/auth/me'; // session cookie based

        try {
          const me = await fetch(meUrl, {
            method: 'GET',
            credentials: 'include',
            cache: 'no-store',
            headers: { 'Accept': 'application/json' }
          });

          if (me.status === 200) {
            // Auth OK ‚Äî set global flag and lock redirects
            window.__AUTH_OK = true;
            
            // From now on, don't allow any redirect-to-login code to run
            window.redirectToTenantLogin = function(){ console.warn("redirectToTenantLogin() blocked after auth"); };
            window.showLogin = window.redirectToTenantLogin;
            window.showRegister = window.redirectToTenantLogin;

            // Hydrate UI and show app
            const data = await me.json().catch(() => ({});
            window.AUTH = data;

            // Update user menu if present
            const userMenu = document.getElementById('userMenu');
            if (userMenu && (data.username || data.email)) {
              userMenu.textContent = `${data.username || data.email} ‚ñº`;
            }

            // Unhide main app container
            const root = document.getElementById('mainApp');
            if (root) root.style.display = 'block';

            // Start periodic refreshes
            if (typeof startBalanceAutoRefresh === 'function') {
              startBalanceAutoRefresh();
            }
            return; // ‚úÖ stay on the page
          }

          if (me.status === 401 || me.status === 403) {
            // only here, allow redirect
            const t = window.__TENANT__ || '';
            location.href = t ? `/${t}/login` : `/login`;
            return;
          }

          console.warn("[auth] unexpected status", me.status);
          // do not redirect on 404/5xx/network errors
        } catch (err) {
          console.warn("[auth] probe failed:", err);
          // do not redirect on network hiccups; let user stay
        }
      })();
    </script>

    <!-- Balance Refresh Function -->
    <script>
        // Function to refresh user balance (can be called after bet settlement)
        async function refreshUserBalance() {
            try {
                console.log('Refreshing user balance...');
                const t = getTenant();
                // The API endpoint is at /api/auth/me, not /${t}/api/auth/me
                const meUrl = '/api/auth/me';
                const response = await fetch(meUrl, {
                    credentials: 'include' // Include cookies for session
                });
                
                if (response.ok) {
                    const userData = await response.json();
                    console.log('Balance refresh - new balance:', userData.balance);
                    
                    // Update balance display
                    const balanceElement = document.getElementById('userBalance');
                    if (balanceElement) {
                        balanceElement.textContent = `$${userData.balance.toFixed(2)}`;
                        console.log('‚úÖ Balance updated to:', userData.balance);
                    } else {
                        console.log('‚ùå Balance element not found');
                    }
                } else {
                    console.error('Failed to refresh balance, status:', response.status);
                }
            } catch (error) {
                    console.error('Error refreshing balance:', error);
            }
        }

        // Auto-refresh balance every 30 seconds to catch settlement updates
        let balanceRefreshInterval;
        
        function startBalanceAutoRefresh() {
            if (balanceRefreshInterval) {
                clearInterval(balanceRefreshInterval);
            }
            
            balanceRefreshInterval = setInterval(async () => {
                await refreshUserBalance();
            }, 30000); // Check every 30 seconds
            
            console.log('üîÑ Balance auto-refresh started (every 30 seconds)');
        }
        
        function stopBalanceAutoRefresh() {
            if (balanceRefreshInterval) {
                clearInterval(balanceRefreshInterval);
                balanceRefreshInterval = null;
                console.log('‚èπÔ∏è Balance auto-refresh stopped');
            }
        }
    </script>

    <!-- Custom Alert JavaScript Functions -->
    <script>
        // Custom Alert System
        function showCustomAlert(type, title, message, duration = 0) {
            const overlay = document.getElementById('customAlertOverlay');
            const alert = document.getElementById('customAlert');
            const icon = document.getElementById('customAlertIcon');
            const titleEl = document.getElementById('customAlertTitle');
            const messageEl = document.getElementById('customAlertMessage');
            const button = document.getElementById('customAlertButton');
            
            // Set alert type and styling
            alert.className = `custom-alert ${type}`;
            
            // Set icon based on type
            const iconMap = {
                'success': '‚úÖ',
                'error': '‚ùå',
                'warning': '‚ö†Ô∏è',
                'info': '‚ÑπÔ∏è'
            };
            icon.textContent = iconMap[type] || 'üéØ';
            
            // Set content
            titleEl.textContent = title;
            messageEl.textContent = message;
            
            // Show overlay
            overlay.style.display = 'flex';
            
            // Auto-hide if duration is set
            if (duration > 0) {
                setTimeout(() => {
                    hideCustomAlert();
                }, duration);
            }
        }
        
        function hideCustomAlert() {
            const overlay = document.getElementById('customAlertOverlay');
            overlay.style.display = 'none';
        }
        
        // Convenience functions for different alert types
        function showSuccessAlert(title, message, duration = 0) {
            showCustomAlert('success', title, message, duration);
        }
        
        function showErrorAlert(title, message, duration = 0) {
            showCustomAlert('error', title, message, duration);
        }
        
        function showWarningAlert(title, message, duration = 0) {
            showCustomAlert('warning', title, message, duration);
        }
        
        function showInfoAlert(title, message, duration = 0) {
            showCustomAlert('info', title, message, duration);
        }
        
        // Custom Confirm Dialog
        function showCustomConfirm(title, message, onConfirm, onCancel) {
            const overlay = document.getElementById('customAlertOverlay');
            const alert = document.getElementById('customAlert');
            const icon = document.getElementById('customAlertIcon');
            const titleEl = document.getElementById('customAlertTitle');
            const messageEl = document.getElementById('customAlertMessage');
            const button = document.getElementById('customAlertButton');
            
            // Set alert type and styling
            alert.className = 'custom-alert warning';
            icon.textContent = '‚ùì';
            
            // Set content
            titleEl.textContent = title;
            messageEl.textContent = message;
            button.textContent = 'Confirm';
            
            // Show overlay
            overlay.style.display = 'flex';
            
            // Handle button click
            button.onclick = function() {
                hideCustomAlert();
                if (onConfirm) onConfirm();
            };
            
            // Handle cancel (clicking outside or escape key)
            const handleCancel = function() {
                hideCustomAlert();
                if (onCancel) onCancel();
            };
            
            overlay.onclick = function(e) {
                if (e.target === overlay) {
                    handleCancel();
                }
            };
            
            // Escape key to cancel
            const escapeHandler = function(e) {
                if (e.key === 'Escape') {
                    document.removeEventListener('keydown', escapeHandler);
                    handleCancel();
                }
            };
            document.addEventListener('keydown', escapeHandler);
        }
        
        // Close alert when clicking outside
        document.addEventListener('DOMContentLoaded', function() {
            const overlay = document.getElementById('customAlertOverlay');
            overlay.addEventListener('click', function(e) {
                if (e.target === overlay) {
                    hideCustomAlert();
                }
            });
        });
    </script>

    <!-- Main Application -->
    <div id="mainApp" style="display: none;">
    <!-- Header -->
        <header class="header">
            <div class="header-content">
            <div class="logo">
                <span class="logo-icon">‚öΩ</span>
                <span class="logo-text">megabook</span>
                </div>
                <div class="search-container">
                    <div class="search-icon">üîç</div>
                <input type="text" class="search-input" placeholder="Search teams, leagues, or events..." onkeyup="handleSearch(this.value)" oninput="toggleClearButton(this)">
                    <div class="search-clear" onclick="clearSearch()">‚úï</div>
            </div>
            <div class="user-section">
                    <div id="loadingIndicator" class="loading-indicator" style="display: none;">
                        <i class="fas fa-spinner fa-spin"></i>
                    </div>
                    <div class="balance" id="userBalance">$1000.00</div>
                    <div class="user-menu" id="userMenu" onclick="toggleUserMenu()">Loading... ‚ñº</div>
                <div class="user-dropdown" id="userDropdown" style="display: none;">
                    <div class="dropdown-item" onclick="showBetHistory()">üìä Bet History</div>
                    <div class="dropdown-item" onclick="logout()">üö™ Logout</div>
                </div>
            </div>
        </div>
    </header>

    <!-- Main Container -->
    <div class="main-container">
        <!-- Sidebar -->
        <aside class="sidebar">
                <!-- Sports Section -->
            <div class="sidebar-section">
                    <h3 class="sidebar-title">SPORTS</h3>
                    <div id="sportsContainer">
                        <div class="loading-text">Loading sports...</div>
                    </div>
            </div>
            
                <!-- Quick Filters -->
            <div class="sidebar-section" style="display: none;">
                    <h3 class="sidebar-title">QUICK FILTERS</h3>
                    <div class="filter-item" onclick="filterLiveEvents()">
                        <div class="filter-info">
                            <span class="filter-icon">üî¥</span>
                            <span>Live Now</span>
                        </div>
                        <span class="event-count" id="liveCount">0</span>
                    </div>
                    <div class="filter-item" onclick="filterTodayEvents()" style="display: none;">
                        <div class="filter-info">
                            <span class="filter-icon">üìÖ</span>
                            <span>Today</span>
                        </div>
                        <span class="event-count" id="todayCount">0</span>
                    </div>
                    <div class="filter-item" onclick="filterTomorrowEvents()" style="display: none;">
                        <div class="filter-info">
                            <span class="filter-icon">‚è∞</span>
                            <span>Tomorrow</span>
                        </div>
                        <span class="event-count" id="tomorrowCount">0</span>
                    </div>
            </div>
            
                <!-- Account Section -->
            <div class="sidebar-section">
                    <h3 class="sidebar-title">ACCOUNT</h3>
                    <div class="filter-item" onclick="showBetHistory()">
                        <div class="filter-info">
                            <span class="filter-icon">üìä</span>
                            <span>Bet History</span>
                        </div>
                    </div>
                    <div class="filter-item" onclick="showAdminPanel()" style="display: none;">
                        <div class="filter-info">
                            <span class="filter-icon">‚öôÔ∏è</span>
                            <span>Admin Panel</span>
                        </div>
                    </div>
            </div>
        </aside>

            <!-- Content Area -->
            <main class="content-area">
                <div class="breadcrumb">
                    <span>Home</span>
                    <span class="breadcrumb-separator">></span>
                    <span id="currentSport">Soccer</span>
                    <span class="breadcrumb-separator">></span>
                    <span>All Events</span>
                </div>
                
                <div class="content-header">
                <div class="view-options">
                        <button class="view-btn active" onclick="switchView('list')">üìã List View</button>
                        <button class="view-btn" onclick="switchView('coupon')">üé´ Coupon View</button>
                </div>
                <div class="live-status">
                    <span id="websocketStatus" class="status-indicator">üî¥ Disconnected</span>
                    <!-- Refresh button hidden for UI purposes -->
                <!-- <button onclick="forceRefreshLiveOdds()" class="refresh-btn">üîÑ Refresh Live Odds</button> -->
                </div>
            </div>

                <div id="eventsContainer">
                    <div class="events-table">
                        <div class="market-tabs">
                            <!-- Market tabs will be dynamically generated by JavaScript -->
                        </div>
                        <div id="eventsContent">
                            <div class="loading-text">Loading events...</div>
                        </div>
                        <div id="liveOddsContainer" class="live-odds-container">
                            <!-- Live odds will be loaded here -->
                        </div>
                        

                </div>
            </div>
        </main>

        <!-- Bet Slip -->
        <aside class="bet-slip">
            <div class="bet-slip-header">
                <div class="bet-slip-title">
                    üéØ Bet Slip
                    <span class="bet-count" id="betCount">0</span>
                </div>
                <div class="bet-slip-controls">
                    <div id="betModeToggle" onclick="toggleBetMode()" class="slider-toggle">
                        <div class="slider-thumb"></div>
                        <div class="slider-label">Single</div>
                    </div>
                </div>
            </div>
            <div class="bet-slip-content" id="betSlipContent">
                <p>Your bet slip is empty</p>
                <p>Click on odds to add selections</p>
            </div>
        </aside>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.js"></script>
    <script>
        // Global variables
        let currentUser = null;
        let currentSport = 'soccer';
        let currentMarket = 'match_result';
        let currentView = 'list';
        let betSlip = [];
        let sportsData = {};
        let eventsData = {};
        let socket = null;
        let websocketConnected = false;
        let autoRefreshInterval = null;
        let comboTotalStake = 0; // Track total stake for combo bets
        let currentSearchTerm = ''; // Track current search term

        // API Base URL
        const API_BASE = '';
        
        // Polyfill for Object.entries (for older browser compatibility)
        if (!Object.entries) {
            Object.entries = function(obj) {
                if (obj !== Object(obj)) {
                    throw new TypeError('Object.entries called on non-object');
                }
                var ownProps = Object.keys(obj);
                var i = ownProps.length;
                var resArray = new Array(i);
                while (i--) {
                    resArray[i] = [ownProps[i], obj[ownProps[i]]];
                }
                return resArray;
            };
        }
        
        // Polyfill for Array.from (for older browser compatibility)
        if (!Array.from) {
            Array.from = function(arrayLike) {
                if (arrayLike == null) {
                    throw new TypeError('Array.from requires an array-like object');
                }
                var array = [];
                var length = arrayLike.length;
                for (var i = 0; i < length; i++) {
                    array.push(arrayLike[i]);
                }
                return array;
            };
        }
        
        // Polyfill for Set (for older browser compatibility)
        if (typeof Set === 'undefined') {
            window.Set = function() {
                var items = [];
                this.add = function(value) {
                    if (items.indexOf(value) === -1) {
                        items.push(value);
                    }
                };
                this.has = function(value) {
                    return items.indexOf(value) !== -1;
                };
                this.forEach = function(callback) {
                    for (var i = 0; i < items.length; i++) {
                        callback(items[i], items[i], this);
                    }
                };
                this.size = items.length;
            };
        }
        
        // Polyfill for Promise.allSettled (for older browser compatibility)
        if (!Promise.allSettled) {
            Promise.allSettled = function (promises) {
                return Promise.all(
                    promises.map(function (promise) {
                        return promise
                            .then(function (value) {
                                return { status: 'fulfilled', value: value };
                            })
                            .catch(function (reason) {
                                return { status: 'rejected', reason: reason };
                            });
                    })
                );
            };
        }
        
        // Basic Promise polyfill for very old browsers
        if (typeof Promise === 'undefined') {
            window.Promise = function(executor) {
                var self = this;
                self.state = 'pending';
                self.value = undefined;
                self.reason = undefined;
                self.onFulfilledCallbacks = [];
                self.onRejectedCallbacks = [];
                
                function resolve(value) {
                    if (self.state === 'pending') {
                        self.state = 'fulfilled';
                        self.value = value;
                        self.onFulfilledCallbacks.forEach(function(callback) {
                            callback(value);
                        });
                    }
                }
                
                function reject(reason) {
                    if (self.state === 'pending') {
                        self.state = 'rejected';
                        self.reason = reason;
                        self.onRejectedCallbacks.forEach(function(callback) {
                            callback(reason);
                        });
                    }
                }
                
                try {
                    executor(resolve, reject);
                } catch (e) {
                    reject(e);
                }
            };
            
            Promise.prototype.then = function(onFulfilled, onRejected) {
                var self = this;
                var promise2 = new Promise(function() {});
                
                if (self.state === 'fulfilled') {
                    setTimeout(function() {
                        try {
                            var x = onFulfilled(self.value);
                            promise2.resolve(x);
                        } catch (e) {
                            promise2.reject(e);
                        }
                    }, 0);
                } else if (self.state === 'rejected') {
                    setTimeout(function() {
                        try {
                            var x = onRejected(self.reason);
                            promise2.resolve(x);
                        } catch (e) {
                            promise2.reject(e);
                        }
                    }, 0);
                } else {
                    self.onFulfilledCallbacks.push(function(value) {
                        setTimeout(function() {
                            try {
                                var x = onFulfilled(value);
                                promise2.resolve(x);
                            } catch (e) {
                                promise2.reject(e);
                            }
                        }, 0);
                    });
                    self.onRejectedCallbacks.push(function(reason) {
                        setTimeout(function() {
                            try {
                                var x = onRejected(reason);
                                promise2.resolve(x);
                            } catch (e) {
                                promise2.reject(e);
                            }
                        }, 0);
                    });
                }
                
                return promise2;
            };
            
            Promise.prototype.catch = function(onRejected) {
                return this.then(null, onRejected);
            };
            
            Promise.resolve = function(value) {
                return new Promise(function(resolve) {
                    resolve(value);
                });
            };
            
            Promise.reject = function(reason) {
                return new Promise(function(resolve, reject) {
                    reject(reason);
                });
            };
            
            Promise.all = function(promises) {
                return new Promise(function(resolve, reject) {
                    var results = [];
                    var completed = 0;
                    
                    if (promises.length === 0) {
                        resolve(results);
                        return;
                    }
                    
                    promises.forEach(function(promise, index) {
                        Promise.resolve(promise).then(function(value) {
                            results[index] = value;
                            completed++;
                            if (completed === promises.length) {
                                resolve(results);
                            }
                        }).catch(function(reason) {
                            reject(reason);
                        });
                    });
                });
            };
        }

        // Helper function to inspect odds data structure
        function inspectOddsData(oddsArray, marketKey) {
            console.log(`üîç Inspecting ${marketKey} odds data:`, {
                type: typeof oddsArray,
                isArray: Array.isArray(oddsArray),
                length: Array.isArray(oddsArray) ? oddsArray.length : 'N/A',
                raw: oddsArray,
                firstElement: Array.isArray(oddsArray) && oddsArray.length > 0 ? oddsArray[0] : 'N/A',
                keys: Array.isArray(oddsArray) && oddsArray.length > 0 ? Object.keys(oddsArray[0]) : 'N/A'
            });
        }
        
        // Helper function to validate odds data quality
        function hasValidOddsData(oddsArray, marketKey) {
            if (!Array.isArray(oddsArray) || oddsArray.length === 0) {
                console.log(`‚ùå ${marketKey}: Empty or non-array odds data:`, oddsArray);
                return false;
            }
            
            // Check if the odds array contains actual betting options with valid values
            const hasValidOption = oddsArray.some(option => {
                if (!option || typeof option !== 'object') {
                    console.log(`‚ùå ${marketKey}: Invalid option structure:`, option);
                    return false;
                }
                
                // Check if option has required fields - make this more lenient
                if (!option.value && !option.name && !option.label) {
                    console.log(`‚ùå ${marketKey}: Missing value/name/label field:`, option);
                    return false;
                }
                
                if (option.odds === undefined || option.odds === null) {
                    console.log(`‚ùå ${marketKey}: Missing odds field:`, option);
                    return false;
                }
                
                // Very lenient odds validation - allow any positive number
                const oddsValue = parseFloat(option.odds);
                if (isNaN(oddsValue) || oddsValue <= 0) {
                    console.log(`‚ùå ${marketKey}: Invalid odds value:`, option.odds, 'for option:', option);
                    return false;
                }
                
                console.log(`‚úÖ ${marketKey}: Valid option found:`, option);
                return true;
            });
            
            if (!hasValidOption) {
                console.log(`‚ùå ${marketKey}: No valid options found in odds array:`, oddsArray);
            }
            
            return hasValidOption;
        }
        
        // Sport-specific betting markets - DYNAMIC MARKET DETECTION
        function getBettingMarkets(sport) {
            console.log(`üéØ Getting betting markets for ${sport}`);
            console.log(`üîç eventsData keys:`, Object.keys(eventsData));
            console.log(`üîç eventsData[${sport}]:`, eventsData[sport]);
            
            // Get current events to discover available markets
            const events = eventsData[sport] || [];
            if (!events || events.length === 0) {
                console.log(`No events found for ${sport}`);
                return [];
            }
            
            // Discover all available markets from the actual data
            const availableMarkets = new Set();
            events.forEach((event, index) => {
                console.log(`üîç Event ${index}: ${event.home_team} vs ${event.away_team}`);
                console.log(`üîç Event odds:`, event.odds);
                if (event.odds) {
                    console.log(`üîç Event odds keys:`, Object.keys(event.odds));
                    Object.keys(event.odds).forEach(marketKey => {
                        // Filter out invalid markets for specific sports
                        if (sport === 'darts') {
                            // For darts, only allow 'correct_score' market
                            if (marketKey === 'correct_score') {
                                availableMarkets.add(marketKey);
                            }
                        } else if (sport === 'baseball') {
                            // For baseball, only allow the 3 valid markets
                            if (marketKey === 'correct_score' || 
                                marketKey === 'match_result' || 
                                marketKey === 'odd_even_including_ot') {
                                availableMarkets.add(marketKey);
                            }
                        } else if (sport === 'esports') {
                            // For esports, only allow 'correct_score' market
                            if (marketKey === 'correct_score') {
                                availableMarkets.add(marketKey);
                            }
                        } else if (sport === 'futsal') {
                            // For futsal, only allow 'match_result' and 'ht_ft_double' markets
                            if (marketKey === 'match_result' || marketKey === 'ht_ft_double') {
                                availableMarkets.add(marketKey);
                            }
                        } else {
                            // For other sports, allow all markets
                            availableMarkets.add(marketKey);
                        }
                    });
                }
            });
            
            console.log(`Available markets in data for ${sport}:`, Array.from(availableMarkets));
            
            // Count events with odds for each market
            const marketCounts = {};
            availableMarkets.forEach(marketKey => {
                let count = 0;
                events.forEach(event => {
                    if (event.odds && event.odds[marketKey]) {
                        const marketData = event.odds[marketKey];
                        let hasOdds = false;
                        
                        // Handle different odds data structures
                        if (Array.isArray(marketData)) {
                            // Array structure (e.g., [1.5, 2.1])
                            hasOdds = marketData.length > 0;
                        } else if (typeof marketData === 'object' && marketData !== null) {
                            // Object structure (e.g., {'1': 1.5, 'X': 3.2, '2': 2.1})
                            hasOdds = Object.keys(marketData).length > 0;
                        } else {
                            hasOdds = false;
                        }
                        
                        if (hasOdds) {
                            count++;
                        }
                    }
                });
                marketCounts[marketKey] = count;
            });
            
            console.log(`Market counts for ${sport}:`, marketCounts);
            
            // Always include match_result first
            const finalMarkets = [];
            if (availableMarkets.has('match_result')) {
                finalMarkets.push({
                    id: 'match_result',
                    name: mapMarketKeyToDisplayName('match_result', sport),
                    eventCount: marketCounts['match_result'] || 0
                });
            }
            
            // Get top 4 markets by event count (excluding match_result)
            const otherMarkets = Array.from(availableMarkets)
                .filter(marketKey => marketKey !== 'match_result')
                .map(marketKey => ({
                    id: marketKey,
                    name: mapMarketKeyToDisplayName(marketKey, sport),
                    eventCount: marketCounts[marketKey] || 0
                }))
                .sort((a, b) => b.eventCount - a.eventCount) // Sort by count descending
                .slice(0, 4); // Take top 4
            
            // Combine match_result with top 4 markets
            const topMarkets = [...finalMarkets, ...otherMarkets];
            
            console.log(`Top 5 markets for ${sport}:`, topMarkets);
            return topMarkets;
        }
        
        // Map market keys to display names
        function mapMarketKeyToDisplayName(marketKey, sport) {
            const marketNames = {
                // Soccer markets
                'match_result': 'Match Result',
                'correct_score': 'Correct Score',
                'correct_score_first_half': 'Correct Score 1st Half',
                'both_teams_score': 'Both Teams Score',
                'first_half_winner': '1st Half Winner',
                'double_chance': 'Double Chance',
                'team_to_score_first': 'Team to Score First',
                'over_under': 'Over/Under',
                'asian_handicap': 'Asian Handicap',
                'odd_even': 'Odd/Even',
                'clean_sheet_home': 'Clean Sheet - Home',
                'clean_sheet_away': 'Clean Sheet - Away',
                'win_both_halves': 'Win Both Halves',
                'ht_ft_double': 'HT/FT Double',
                'highest_scoring_half': 'Highest Scoring Half',
                'second_half_winner': '2nd Half Winner',
                'double_chance_first_half': 'Double Chance 1st Half',
                'both_teams_score_first_half': 'Both Teams Score 1st Half',
                'both_teams_score_second_half': 'Both Teams Score 2nd Half',
                'odd_even_first_half': 'Odd/Even 1st Half',
                'to_qualify': 'To Qualify',
                'results_both_teams_score': 'Results + Both Teams Score',
                'corners_1x2': 'Corners 1X2',
                
                // Basketball markets
                'first_quarter_winner': '1st Quarter Winner',
                'highest_scoring_quarter': 'Highest Scoring Quarter',
                'odd_even_including_ot': 'Odd/Even (Including OT)',
                
                // Generic fallback
                'win_to_nil_home': 'Win to Nil - Home',
                'win_to_nil_away': 'Win to Nil - Away'
            };
            
            return marketNames[marketKey] || marketKey.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
        }
        
        function getAllMarketsForSport(sport) {
            switch(sport) {
                case 'soccer':
                    return [
                        { id: 'match_result', name: 'Match Result' },
                        { id: 'asian_handicap', name: '1st Half Winner' },
                        { id: 'over_under', name: 'Both Teams Score' }
                    ];
                case 'basketball':
                    return [
                        { id: 'match_result', name: 'Match Result' },
                        { id: 'first_half_winner', name: 'Home/Away - 1st Half' },
                        { id: 'first_quarter_winner', name: 'Home/Away - 1st Quarter' },
                        { id: 'highest_scoring_quarter', name: 'Highest Scoring Quarter' },
                        { id: 'odd_even_including_ot', name: 'Odd/Even (Including OT)' }
                    ];
                case 'tennis':
                    return [
                        { id: 'match_result', name: 'Match Winner' },
                        { id: 'correct_score_first_half', name: 'Correct Score 1st Half' },
                        { id: 'games_over_under', name: 'Games Over/Under' },
                        { id: 'over_under_first_set', name: 'Over/Under (1st Set)' },
                        { id: 'first_set', name: 'Home/Away (1st Set)' },
                        { id: 'asian_handicap_sets', name: 'Asian Handicap (Sets)' },
                        { id: 'asian_handicap_games', name: 'Asian Handicap (Games)' },
                        { id: 'set_betting', name: 'Set Betting' },
                        { id: 'tie_break_first_set', name: 'Tie-break (1st Set)' },
                        { id: 'second_set', name: 'Home/Away (2nd Set)' },
                        { id: 'win_one_set_player1', name: 'Win at least one set (Player 1)' },
                        { id: 'win_one_set_player2', name: 'Win at least one set (Player 2)' }
                    ];
                case 'table_tennis':
                    return [
                        { id: 'match_result', name: 'Match Winner' },
                        { id: 'first_set', name: 'Home/Away (1st Set)' },
                        { id: 'set_betting', name: 'Set Betting' }
                    ];
                case 'darts':
                    return [
                        { id: 'correct_score', name: 'Correct Score' }
                    ];
                case 'volleyball':
                    return [
                        { id: 'match_result', name: 'Match Winner' },
                        { id: 'correct_score', name: 'Correct Score' },
                        { id: 'odd_even_first_set', name: 'Odd/Even (1st Set)' },
                        { id: 'over_under_first_set', name: 'Over/Under (1st Set)' },
                        { id: 'first_set', name: 'Home/Away (1st Set)' }
                    ];
                case 'handball':
                    return [
                        { id: 'match_result', name: 'Match Result' }
                    ];
                case 'baseball':
                    return [
                        { id: 'match_result', name: 'Match Result' },
                        { id: 'correct_score', name: 'Correct Score' },
                        { id: 'odd_even_including_ot', name: 'Odd/Even (Including OT)' }
                    ];
                case 'hockey':
                    return [
                        { id: 'match_result', name: 'Match Winner' },
                        { id: 'over_under', name: 'Over/Under' },
                        { id: 'first_half_winner', name: '1st Half Winner' }
                    ];
                case 'cricket':
                    return [
                        { id: 'match_result', name: 'Match Result' }
                    ];
                case 'rugby':
                    return [
                        { id: 'match_result', name: 'Match Result' },
                        { id: 'over_under', name: 'Over/Under' },
                        { id: 'asian_handicap', name: 'Asian Handicap' }
                    ];
                case 'rugbyleague':
                    return [
                        { id: 'match_result', name: 'Match Result' },
                        { id: 'over_under', name: 'Over/Under' },
                        { id: 'asian_handicap', name: 'Asian Handicap' },
                        { id: 'over_under_first_half', name: 'Over/Under 1st Half' },
                        { id: 'ht_ft_double', name: 'HT/FT Double' },
                        { id: 'handicap_result', name: 'Handicap Result' },
                        { id: 'first_half_3way_result', name: '1st Half 3Way Result' },
                        { id: 'asian_handicap_first_half', name: 'Asian Handicap First Half' }
                    ];
                case 'futsal':
                    return [
                        { id: 'match_result', name: 'Match Result' },
                        { id: 'over_under', name: 'Over/Under' }
                    ];
                case 'boxing':
                    return [
                        { id: 'match_result', name: 'Match Winner' },
                        { id: 'over_under', name: 'Over/Under' }
                    ];
                case 'mma':
                    return [
                        { id: 'match_result', name: 'Match Winner' },
                        { id: 'over_under', name: 'Over/Under' }
                    ];
                case 'esports':
                    return [
                        { id: 'match_result', name: 'Match Winner' },
                        { id: 'over_under', name: 'Over/Under' },
                        { id: 'asian_handicap', name: 'Asian Handicap' }
                    ];
                default:
                    return [
                        { id: 'match_result', name: 'Match Result' },
                        { id: 'over_under', name: 'Over/Under' },
                        { id: 'asian_handicap', name: 'Asian Handicap' }
                    ];
            }
        }
        
        // Check if any events have odds for a specific market
        function hasOddsForMarket(sport, marketId) {
            console.log(`üîç Checking odds for ${sport} - ${marketId}`);
            
            // Get current events for this sport
            const events = getCurrentEvents(sport);
            console.log(`Events found: ${events ? events.length : 0}`);
            
            if (!events || events.length === 0) {
                console.log('‚ùå No events found');
                return false;
            }
            
            // DEBUG: Show first few events and their odds structure
            console.log('üìä Sample events and their odds:');
            events.slice(0, 3).forEach((event, index) => {
                console.log(`Event ${index + 1}: ${event.home_team} vs ${event.away_team}`);
                console.log(`  Has odds object: ${!!event.odds}`);
                if (event.odds) {
                    console.log(`  Available odds keys:`, Object.keys(event.odds));
                    console.log(`  Full odds object:`, event.odds);
                }
            });
            
            // Special handling for soccer markets
            if (sport === 'soccer') {
                if (marketId === 'asian_handicap') {
                    // Check for first_half_winner market (which is what asian_handicap maps to)
                    return events.some(event => {
                        if (!event.odds) return false;
                        // Check if any event has first_half_winner odds
                        const hasOdds = event.odds.first_half_winner && event.odds.first_half_winner.length > 0;
                        console.log(`Event ${event.home_team} vs ${event.away_team}: first_half_winner = ${hasOdds}`);
                        return hasOdds;
                    });
                } else if (marketId === 'over_under') {
                    // Check for both_teams_score market (which is what over_under maps to)
                    return events.some(event => {
                        if (!event.odds) return false;
                        // Check if any event has both_teams_score odds
                        const hasOdds = event.odds.both_teams_score && event.odds.both_teams_score.length > 0;
                        console.log(`Event ${event.home_team} vs ${event.away_team}: both_teams_score = ${hasOdds}`);
                        return hasOdds;
                    });
                }
            }
            
            // Check if any event has odds for this market
            const hasOdds = events.some(event => {
                if (!event.odds || !event.odds[marketId]) {
                    return false;
                }
                
                const marketData = event.odds[marketId];
                let hasMarketOdds = false;
                
                // Handle different odds data structures
                if (Array.isArray(marketData)) {
                    // Array structure (e.g., [1.5, 2.1])
                    hasMarketOdds = marketData.length > 0;
                } else if (typeof marketData === 'object' && marketData !== null) {
                    // Object structure (e.g., {'1': 1.5, 'X': 3.2, '2': 2.1})
                    hasMarketOdds = Object.keys(marketData).length > 0;
                } else {
                    hasMarketOdds = false;
                }
                
                console.log(`Event ${event.home_team} vs ${event.away_team}: odds[${marketId}] = ${hasMarketOdds}`);
                if (event.odds) {
                    console.log('Available odds markets:', Object.keys(event.odds));
                    console.log(`Checking for market: ${marketId}`);
                    console.log(`Market exists: ${event.odds.hasOwnProperty(marketId)}`);
                    if (event.odds[marketId]) {
                        console.log(`Market data:`, event.odds[marketId]);
                    }
                }
                return hasMarketOdds;
            });
            
            console.log(`‚úÖ Has odds for ${marketId}: ${hasOdds}`);
            return hasOdds;
        }
        
        // Get current events for a sport
        function getCurrentEvents(sport) {
            // If we're checking the current sport, use the stored events
            if (currentSport === sport && window.currentEvents) {
                return window.currentEvents;
            }
            
            // For other sports, we need to fetch the events
            // This is a simplified approach - in a real implementation you might want to cache this
            if (eventsData[sport]) {
                const events = eventsData[sport].filter(event => !event.is_completed && !event.is_cancelled);
                return events;
            }
            
            return [];
        }

        function updateBettingMarkets() {
            const marketTabs = document.querySelector('.market-tabs');
            const markets = getBettingMarkets(currentSport);
            
            marketTabs.innerHTML = '';
            
            // Store current market selection before updating
            const previousMarket = currentMarket;
            
            if (markets.length > 0) {
                // Check if current market is still available
                const currentMarketStillAvailable = markets.some(market => market.id === previousMarket);
                
                markets.forEach((market, index) => {
                    // Skip markets that contain "Market Id" in their name
                    if (market.name && market.name.toLowerCase().includes('market id')) {
                        console.log(`üö´ Hiding market tab: ${market.name}`);
                        return; // Skip this market
                    }
                    
                    const button = document.createElement('button');
                    // Keep current market active if it's still available, otherwise use first market
                    const isActive = currentMarketStillAvailable ? 
                        (market.id === previousMarket) : 
                        (index === 0);
                    button.className = `market-tab ${isActive ? 'active' : ''}`;
                    button.onclick = () => switchMarket(market.id);
                    button.textContent = market.name;
                    marketTabs.appendChild(button);
                });
                
                // Maintain current market if available, otherwise reset to first
                currentMarket = currentMarketStillAvailable ? previousMarket : markets[0].id;
                
                console.log(`‚úÖ Showing ${markets.length} filtered markets for ${currentSport}:`, markets.map(m => m.id));
            } else {
                // If no markets pass validation, try to show at least match_result if available
                console.log(`‚ö†Ô∏è No markets passed validation for ${currentSport}, attempting to show match_result only`);
                
                // Try to get just the match_result market if it exists in the data
                const events = eventsData[currentSport] || [];
                let hasMatchResult = false;
                
                if (events.length > 0) {
                    events.forEach(event => {
                        if (event.odds && event.odds.match_result && 
                            Array.isArray(event.odds.match_result) && 
                            event.odds.match_result.length > 0) {
                            hasMatchResult = true;
                        }
                    });
                }
                
                if (hasMatchResult) {
                    // Show only match_result market
                    const button = document.createElement('button');
                    button.className = 'market-tab active';
                    button.onclick = () => switchMarket('match_result');
                    button.textContent = 'Match Result';
                    marketTabs.appendChild(button);
                    currentMarket = 'match_result';
                    console.log(`‚úÖ Showing only match_result market for ${currentSport}`);
                } else {
                    // Show message that no markets are available
                    const messageDiv = document.createElement('div');
                    messageDiv.className = 'no-markets-message';
                    messageDiv.textContent = 'No betting markets available for this sport at the moment.';
                    messageDiv.style.cssText = 'text-align: center; padding: 20px; color: #666; font-style: italic;';
                    marketTabs.appendChild(messageDiv);
                    currentMarket = null;
                    console.log(`‚ùå No markets available for ${currentSport}`);
                }
            }
        }

        // Authentication functions - REMOVED to prevent conflicts with bootstrapAuth
        // These were overriding our redirectToTenantLogin functions
        // window.showLogin and window.showRegister are now handled by bootstrapAuth
        
        // Ensure functions are also available without window prefix
        function showLogin() { window.showLogin(); }
        function showRegister() { window.showRegister(); }

        // Wait for DOM to be ready before adding event listeners
        document.addEventListener('DOMContentLoaded', function() {
            // Add event listener for auth toggle link
            const authToggleLink = document.getElementById('authToggleLink');
            if (authToggleLink) {
                authToggleLink.addEventListener('click', function(e) {
            e.preventDefault();
                    const currentMode = document.getElementById('authForm').getAttribute('data-mode') || 'login';
            if (currentMode === 'login') {
                // showRegister(); // DISABLED: conflicts with session-based auth
                } else {
                // showLogin(); // DISABLED: conflicts with session-based auth
                    }
                });
                }
            });

        const authForm = document.getElementById('authForm');
        if (authForm) {
        authForm.addEventListener('submit', async function(e) {
            e.preventDefault();
            const mode = this.getAttribute('data-mode');
            const username = document.getElementById('username').value;
            const password = document.getElementById('password').value;
            
            try {
                let response;
                if (mode === 'login') {
                    response = await fetch(`${API_BASE}/api/auth/login`, {
                    method: 'POST',
                    headers: {
                            'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ username, password })
                });
                } else {
                    const email = document.getElementById('email').value;
                    const confirmPassword = document.getElementById('confirmPassword').value;
            
            if (password !== confirmPassword) {
                        alert('Passwords do not match');
                return;
            }
            
                    response = await fetch(`${API_BASE}/api/auth/register`, {
                    method: 'POST',
                    headers: {
                            'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ username, email, password })
                });
                }
                
                const data = await response.json();
                
                if (response.ok) {
                    if (mode === 'register') {
                        alert('Registration successful! You can now login.');
                        // showLogin(); // DISABLED: conflicts with session-based auth
                } else {
                        localStorage.setItem('token', data.token);
                        currentUser = data.user;
                        document.getElementById('loginOverlay').style.display = 'none';
                        document.getElementById('mainApp').style.display = 'block';
                        document.getElementById('userBalance').textContent = `$${data.user.balance.toFixed(2)}`;
                        loadSports();
                        // startOddsAutoRefresh(); // Start 1-minute auto-refresh - DISABLED to prevent constant refresh
                    }
                } else {
                    alert(data.message || 'Authentication failed');
                }
            } catch (error) {
                console.error('Auth error:', error);
                alert('Authentication failed. Please try again.');
            }
        });
        }

        // Auto-refresh odds every 1 minute
        let oddsRefreshInterval;
        
        function startOddsAutoRefresh() {
            // Clear any existing interval
            if (oddsRefreshInterval) {
                clearInterval(oddsRefreshInterval);
            }
            
            // Set up auto-refresh every 5 minutes (changed from 5 seconds to prevent constant loading)
            oddsRefreshInterval = setInterval(() => {
                console.log('üîÑ Auto-refreshing all sports cache...');
                // Only refresh if user is actively viewing
                if (document.visibilityState !== 'hidden') {
                    // Force refresh all sports cache every 5 minutes to get fresh data
                    const now = Date.now();
                    const lastForceRefresh = parseInt(localStorage.getItem('last_force_refresh') || '0');
                    const shouldForceRefresh = (now - lastForceRefresh) > 300000; // 5 minutes
                    
                    if (shouldForceRefresh) {
                        localStorage.setItem('last_force_refresh', now.toString());
                        // Refresh all sports cache in background
                        refreshAllSportsCache();
                        // Also refresh current sport display
                        if (currentSport) {
                            loadEvents(currentSport, true);
                        }
                    } else {
                        // Just refresh current sport display
                        if (currentSport) {
                            loadEvents(currentSport, false);
                        }
                    }
                }
            }, 300000); // Changed from 5000 (5 seconds) to 300000 (5 minutes)
            
            console.log('‚úÖ Auto-refresh enabled: all sports cache will update every 5 minutes');
        }
        


        // Sports loading functions
        async function loadSports() {
            try {
                console.log('üîÑ Loading sports...');
                console.log('üåê API_BASE:', API_BASE);
                console.log('üîó Full URL:', `${API_BASE}/api/sports/sports`);
                
                // Show loading indicator
                showLoadingIndicator();
                
                // Show loading state
                document.getElementById('sportsContainer').innerHTML = '<div class="loading-text">Loading sports...</div>';
                
                console.log('Loading sports with session authentication...');
                
                const response = await fetch(`${API_BASE}/api/sports/sports`, {
                    credentials: 'include' // Include cookies for session
                });
                
                console.log('Response status:', response.status);
                console.log('Response headers:', Object.fromEntries(response.headers.entries()));
                
                if (response.ok) {
                    const responseText = await response.text();
                    console.log('Raw response text:', responseText);
                    
                    try {
                        sportsData = JSON.parse(responseText);
                    } catch (parseError) {
                        console.error('Failed to parse JSON:', parseError);
                        console.error('Response text:', responseText);
                        document.getElementById('sportsContainer').innerHTML = '<div class="loading-text">Invalid response format</div>';
                        return;
                    }
                    
                    console.log('Sports data received:', sportsData);
                    console.log('üîç Sports data keys:', Object.keys(sportsData));
                    console.log('üîç Sports data structure:', {
                        type: typeof sportsData,
                        isArray: Array.isArray(sportsData),
                        length: Array.isArray(sportsData) ? sportsData.length : Object.keys(sportsData).length,
                        sample: Array.isArray(sportsData) ? sportsData[0] : (Object.entries ? Object.entries(sportsData)[0] : 'Object.entries not supported')
                    });
                    
                    // Set default sport to first available sport
                    if (Array.isArray(sportsData) && sportsData.length > 0) {
                        currentSport = sportsData[0].name;
                        console.log('Default sport set to:', currentSport);
                    } else if (typeof sportsData === 'object' && Object.keys(sportsData).length > 0) {
                        currentSport = Object.keys(sportsData)[0];
                        console.log('Default sport set to:', currentSport);
                    }
                    
                    // First display sports so user can see them
                    displaySports();
                    
                    // Then load events for the default sport immediately
                    if (currentSport) {
                        loadEvents(currentSport);
                    }
                    
                    // Finally, cache events for ALL sports in background (non-blocking)
                    preloadAllSportsEvents().catch(error => {
                        console.error('Background caching failed:', error);
                    });
                    
                    // Also warm up cache for the default sport immediately for instant loading
                    if (currentSport) {
                        loadEventsForCache(currentSport).catch(error => {
                            console.error('Default sport cache warming failed:', error);
                        });
                    }
            } else {
                    console.error('Failed to load sports - Status:', response.status);
                    const errorText = await response.text();
                    console.error('Error response:', errorText);
                    document.getElementById('sportsContainer').innerHTML = `<div class="loading-text">Error: ${response.status} - ${errorText}</div>`;
                }
            } catch (error) {
                console.error('Error loading sports:', error);
                document.getElementById('sportsContainer').innerHTML = `<div class="loading-text">Network error: ${error.message}</div>`;
            }
        }

        // PROACTIVE CACHING: Preload events for all sports
        async function preloadAllSportsEvents() {
            try {
                console.log('üöÄ Starting proactive caching for all sports...');
                
                // Get list of all available sports
                let sportsList = [];
                if (Array.isArray(sportsData)) {
                    sportsList = sportsData.map(sport => sport.name);
                } else if (typeof sportsData === 'object') {
                    sportsList = Object.keys(sportsData);
                }
                
                console.log(`üì¶ Caching events for ${sportsList.length} sports:`, sportsList);
                
                // Load events for all sports in parallel (but limit concurrent requests)
                const batchSize = 3; // Process 3 sports at a time to avoid overwhelming the server
                for (let i = 0; i < sportsList.length; i += batchSize) {
                    const batch = sportsList.slice(i, i + batchSize);
                    const promises = batch.map(sport => loadEventsForCache(sport));
                    
                    await Promise.allSettled(promises);
                    
                    // Small delay between batches to be server-friendly
                    if (i + batchSize < sportsList.length) {
                        await new Promise(resolve => setTimeout(resolve, 200));
                    }
                }
                
                console.log('‚úÖ Proactive caching completed for all sports');
                
            } catch (error) {
                console.error('‚ùå Error during proactive caching:', error);
            }
        }

        // Load events for caching (without displaying)
        async function loadEventsForCache(sport) {
            try {
                console.log(`üì¶ Caching events for ${sport}...`);
                
                const response = await fetch(`${API_BASE}/api/sports/events/${sport}`, {
                    credentials: 'include' // Include cookies for session
                });
                
                if (response.ok) {
                    const eventsData = await response.json();
                    
                    // Cache the data
                    const cacheKey = `events_cache_${sport}`;
                    const now = Date.now();
                    localStorage.setItem(cacheKey, JSON.stringify(eventsData));
                    localStorage.setItem(`${cacheKey}_timestamp`, now.toString());
                    
                    console.log(`‚úÖ Cached ${eventsData.length} events for ${sport}`);
                } else {
                    console.warn(`‚ö†Ô∏è Failed to cache events for ${sport}: ${response.status}`);
                }
            } catch (error) {
                console.error(`‚ùå Error caching events for ${sport}:`, error);
            }
        }

        // Refresh all sports cache in background
        async function refreshAllSportsCache() {
            try {
                console.log('üîÑ Refreshing all sports cache in background...');
                
                // Get list of all available sports
                let sportsList = [];
                if (Array.isArray(sportsData)) {
                    sportsList = sportsData.map(sport => sport.name);
                } else if (typeof sportsData === 'object') {
                    sportsList = Object.keys(sportsData);
                }
                
                // Refresh cache for all sports in parallel (but limit concurrent requests)
                const batchSize = 3; // Process 3 sports at a time
                for (let i = 0; i < sportsList.length; i += batchSize) {
                    const batch = sportsList.slice(i, i + batchSize);
                    const promises = batch.map(sport => loadEventsForCache(sport));
                    
                    await Promise.allSettled(promises);
                    
                    // Small delay between batches to be server-friendly
                    if (i + batchSize < sportsList.length) {
                        await new Promise(resolve => setTimeout(resolve, 150));
                    }
                }
                
                console.log('‚úÖ Background cache refresh completed for all sports');
                
            } catch (error) {
                console.error('‚ùå Error during background cache refresh:', error);
            }
        }

        function displaySports() {
            console.log('üéØ Displaying sports...');
            const container = document.getElementById('sportsContainer');
            console.log('Container found:', !!container);
            
            if (!container) {
                console.error('Sports container not found!');
                return;
            }
            
            // Check if we have sports data
            if (!sportsData || (Array.isArray(sportsData) && sportsData.length === 0) || (typeof sportsData === 'object' && Object.keys(sportsData).length === 0)) {
                console.warn('No sports data available');
                container.innerHTML = '<div class="loading-text">No sports available</div>';
                return;
            }
            
            const sportsIcons = {
                'soccer': '‚öΩ',
                'basketball': 'üèÄ',
                'tennis': 'üéæ',
                'baseball': '‚öæ',
                'hockey': 'üèí',
                'volleyball': 'üèê',
                'football': 'üèà',
                'cricket': 'üèè',
                'rugby': 'üèâ',
                'boxing': 'ü•ä'
            };
            
            console.log('Sports data type:', typeof sportsData);
            console.log('Sports data:', sportsData);
            
            try {
                // Handle both array and object formats
                const sportsArray = Array.isArray(sportsData) ? sportsData : (Object.entries ? Object.entries(sportsData).map(([name, data]) => ({ 
                    name, 
                    event_count: typeof data === 'object' ? data.count : data,
                    display_name: typeof data === 'object' ? data.display_name : name.charAt(0).toUpperCase() + name.slice(1),
                    icon: typeof data === 'object' ? data.icon : sportsIcons[name] || 'üèÜ',
                    has_draw: typeof data === 'object' ? data.has_draw : false
                })) : []);
                
                console.log('Processed sports array:', sportsArray);
                
                if (sportsArray.length === 0) {
                    container.innerHTML = '<div class="loading-text">No sports found</div>';
                    return;
                }
                
                const html = sportsArray.map(sport => `
                    <div class="sport-item ${sport.name === currentSport ? 'active' : ''}" onclick="selectSport('${sport.name}')">
                        <div class="sport-info">
                            <span class="sport-icon">${sport.icon}</span>
                            <span class="sport-name">${sport.display_name}</span>
                        </div>
                        <span class="event-count">${sport.event_count || 0}</span>
                    </div>
                `).join('');
                
                console.log('Generated HTML length:', html.length);
                container.innerHTML = html;
                console.log('‚úÖ Sports displayed successfully');
            } catch (error) {
                console.error('Error displaying sports:', error);
                container.innerHTML = '<div class="loading-text">Error loading sports</div>';
            }
        }

        function selectSport(sport) {
            console.log(`üéØ Selecting sport: ${sport}`);
            console.log(`üîç Available sports in sportsData:`, Object.keys(sportsData));
            console.log(`üîç Available sports in eventsData:`, Object.keys(eventsData));
            console.log(`üîç Sport type:`, typeof sport);
            console.log(`üîç Sport value:`, sport);
            
            currentSport = sport;
            console.log(`Current sport set to: ${currentSport}`);
            document.getElementById('currentSport').textContent = sport.charAt(0).toUpperCase() + sport.slice(1);
            
            // Update sports display to show active state
            updateSportsActiveState(sport);
            
            // Update betting markets for the new sport
            updateBettingMarkets();
            
            // Load events for the selected sport
            loadEvents(sport);
        }
        
        // Optimized function to update only the active state of sports
        function updateSportsActiveState(activeSport) {
            const sportItems = document.querySelectorAll('.sport-item');
            sportItems.forEach(item => {
                if (item.onclick.toString().includes(`'${activeSport}'`)) {
                    item.classList.add('active');
                } else {
                    item.classList.remove('active');
                }
            });
        }

        // Events loading functions
        async function loadEvents(sport, forceRefresh = false) {
            try {
                // Show loading state
                document.getElementById('eventsContent').innerHTML = '<div class="loading-text">Loading events...</div>';
                
                // Check if we have cached data and it's recent (less than 30 minutes old for better performance)
                const cacheKey = `events_cache_${sport}`;
                const cachedData = localStorage.getItem(cacheKey);
                const cacheTimestamp = localStorage.getItem(`${cacheKey}_timestamp`);
                const now = Date.now();
                const cacheAge = now - (parseInt(cacheTimestamp) || 0);
                const cacheValid = cacheAge < 1800000; // 30 minutes cache (increased from 5 minutes)
                
                if (!forceRefresh && cachedData && cacheValid) {
                    console.log(`üì¶ Using cached events for ${sport} (age: ${Math.round(cacheAge/1000)}s)`);
                    eventsData[sport] = JSON.parse(cachedData);
                    displayEvents();
                    updateBettingMarkets();
                    

                    
                    // Hide loading indicator since we're using cached data
                    hideLoadingIndicator();
                    
                    // Refresh data in background to keep cache fresh
                    setTimeout(() => {
                        loadEvents(sport, true).catch(error => {
                            console.log('Background refresh failed:', error);
                        });
                    }, 1000);
                    
                    return;
                }
                
                console.log(`üîÑ Loading events for ${sport}...`);
                const response = await fetch(`${API_BASE}/api/sports/events/${sport}`, {
                    credentials: 'include' // Include cookies for session
                });
                
                console.log('Events response status:', response.status);
                
                if (response.ok) {
                    eventsData[sport] = await response.json();
                    console.log(`Events data for ${sport}:`, eventsData[sport]);
                    
                    // Cache the data
                    localStorage.setItem(cacheKey, JSON.stringify(eventsData[sport]));
                    localStorage.setItem(`${cacheKey}_timestamp`, now.toString());
                    
                    // Check if events have odds
                    if (eventsData[sport] && eventsData[sport].length > 0) {
                        const firstEvent = eventsData[sport][0];
                        console.log('First event structure:', firstEvent);
                        if (firstEvent.odds) {
                            console.log('Available odds markets:', Object.keys(firstEvent.odds));
                        } else {
                            console.log('‚ùå No odds object found in events');
                        }
                    }
                    
                    // Events now come with odds from JSON files - no need for separate odds loading
                    displayEvents();
                    // Update markets after events are displayed
                    updateBettingMarkets();
                    
                    // Hide loading indicator
                    hideLoadingIndicator();
                } else {
                    console.error('Failed to load events for', sport);
                    document.getElementById('eventsContent').innerHTML = '<div class="loading-text">No events found for this sport</div>';
                    
                    // Hide loading indicator
                    hideLoadingIndicator();
                }
            } catch (error) {
                console.error('Error loading events:', error);
                document.getElementById('eventsContent').innerHTML = '<div class="loading-text">Error loading events</div>';
                
                // Hide loading indicator
                hideLoadingIndicator();
            }
        }
        
        // Convert GoalServe odds structure to frontend format
        function convertGoalServeOdds(oddsArray) {
            const convertedOdds = {};
            
            if (!Array.isArray(oddsArray)) {
                console.warn('Odds array is not an array:', oddsArray);
                return convertedOdds;
            }
            
            oddsArray.forEach(oddsGroup => {
                if (oddsGroup.value === 'Home/Away') {
                    // This is the main match winner odds
                    if (oddsGroup.bookmakers && oddsGroup.bookmakers.length > 0) {
                        const bookmaker = oddsGroup.bookmakers[0]; // Use first bookmaker
                        if (bookmaker.odds && bookmaker.odds.length >= 2) {
                            convertedOdds['match_result'] = {
                                '1': parseFloat(bookmaker.odds[0].value) || 0,
                                'x': 0, // Draw not applicable for tennis
                                '2': parseFloat(bookmaker.odds[1].value) || 0
                            };
                        }
                    }
                }
                // Add more market conversions as needed
            });
            
            console.log('Converted odds:', convertedOdds);
            return convertedOdds;
        }
        


        async function loadLiveOddsForEvents(liveEvents) {
            // Use JSON data instead of fetching live odds
            console.log('Using JSON data for odds');
            try {
                // Reload events from JSON data
                await loadEvents(currentSport);
                console.log('Events loaded from JSON successfully');
                displayEvents();
            } catch (error) {
                console.error('Error loading events from JSON:', error);
                displayEvents();
            }
        }

        function displayEvents() {
            const events = eventsData[currentSport] || [];
            const container = document.getElementById('eventsContent');
            
            // Filter out completed and cancelled matches
            let activeEvents = events.filter(event => !event.is_completed && !event.is_cancelled);
            
            // Apply current search filter if exists
            if (currentSearchTerm && currentSearchTerm.trim() !== '') {
                const searchTerm = currentSearchTerm.toLowerCase().trim();
                activeEvents = activeEvents.filter(event => {
                    const homeTeam = event.home_team?.toLowerCase() || '';
                    const awayTeam = event.away_team?.toLowerCase() || '';
                    const league = event.league?.toLowerCase() || '';
                    const venue = event.venue?.toLowerCase() || '';
                    
                    return homeTeam.includes(searchTerm) ||
                           awayTeam.includes(searchTerm) ||
                           league.includes(searchTerm) ||
                           venue.includes(searchTerm) ||
                           `${homeTeam} ${awayTeam}`.includes(searchTerm) ||
                           `${awayTeam} ${homeTeam}`.includes(searchTerm);
                });
            }
            
            if (activeEvents.length === 0) {
                if (currentSearchTerm && currentSearchTerm.trim() !== '') {
                    container.innerHTML = `<div class="loading-text">No events found for "${currentSearchTerm}"</div>`;
                } else {
                    container.innerHTML = '<div class="loading-text">No active events found for this sport</div>';
                }
                return;
            }
            
            // Sort events chronologically (live matches first, then by date/time)
            const sortedEvents = activeEvents.sort((a, b) => {
                // Live matches come first
                if (a.is_live && !b.is_live) return -1;
                if (!a.is_live && b.is_live) return 1;
                
                // Then sort by date and time
                const dateA = new Date(a.date + ' ' + new Date().getFullYear() + ' ' + a.time);
                const dateB = new Date(b.date + ' ' + new Date().getFullYear() + ' ' + b.time);
                
                return dateA - dateB;
            });
            
            // Store current events globally for market filtering
            window.currentEvents = sortedEvents;
            
            // Update filter counts
            updateFilterCounts(sortedEvents);
            
            // Restore search input state
            restoreSearchState();
            
            if (currentView === 'list') {
                displayListView(sortedEvents, container);
            } else {
                displayCouponView(sortedEvents, container);
            }
        }

        function updateFilterCounts(events) {
            // Filter out completed and cancelled events for counts
            const activeEvents = events.filter(event => !event.is_completed && !event.is_cancelled);
            
            console.log('üîç DEBUG: updateFilterCounts called with', activeEvents.length, 'active events');
            if (activeEvents.length > 0) {
                console.log('üîç DEBUG: Sample event date format:', activeEvents[0].date, 'Type:', typeof activeEvents[0].date);
            }
            
            const liveEvents = activeEvents.filter(event => event.is_live);
            const todayEvents = activeEvents.filter(event => {
                try {
                    // Handle different date formats from GoalServe API
                    let eventDate;
                    const currentYear = new Date().getFullYear();
                    
                    if (event.date && event.date.includes('.')) {
                        // Format: "07.08.2025" or "07.08"
                        const dateParts = event.date.split('.');
                        if (dateParts.length === 3) {
                            // Full date: "07.08.2025"
                            const day = parseInt(dateParts[0]);
                            const month = parseInt(dateParts[1]) - 1; // Month is 0-indexed
                            const year = parseInt(dateParts[2]);
                            eventDate = new Date(year, month, day);
                        } else if (dateParts.length === 2) {
                            // Partial date: "07.08" - assume current year
                            const day = parseInt(dateParts[0]);
                            const month = parseInt(dateParts[1]) - 1;
                            eventDate = new Date(currentYear, month, day);
                        }
                    } else if (event.date) {
                        // Try other formats like "Aug 05"
                        const dateTimeStr = `${event.date} ${currentYear}`;
                        eventDate = new Date(dateTimeStr);
                        
                        // If the event date is in the past, it might be next year
                        if (!isNaN(eventDate.getTime())) {
                            const now = new Date();
                            if (eventDate < now) {
                                eventDate.setFullYear(currentYear + 1);
                            }
                        }
                    }
                    
                    if (!eventDate || isNaN(eventDate.getTime())) {
                        console.warn('Could not parse date for event:', event.date, event);
                        return false;
                    }
                    
                    const today = new Date();
                    return eventDate.toDateString() === today.toDateString();
                } catch (error) {
                    console.error('Error parsing date for event:', event.date, error);
                    return false;
                }
            });
            const tomorrowEvents = activeEvents.filter(event => {
                try {
                    // Handle different date formats from GoalServe API
                    let eventDate;
                    const currentYear = new Date().getFullYear();
                    
                    if (event.date && event.date.includes('.')) {
                        // Format: "07.08.2025" or "07.08"
                        const dateParts = event.date.split('.');
                        if (dateParts.length === 3) {
                            // Full date: "07.08.2025"
                            const day = parseInt(dateParts[0]);
                            const month = parseInt(dateParts[1]) - 1; // Month is 0-indexed
                            const year = parseInt(dateParts[2]);
                            eventDate = new Date(year, month, day);
                        } else if (dateParts.length === 2) {
                            // Partial date: "07.08" - assume current year
                            const day = parseInt(dateParts[0]);
                            const month = parseInt(dateParts[1]) - 1;
                            eventDate = new Date(currentYear, month, day);
                        }
                    } else if (event.date) {
                        // Try other formats like "Aug 05"
                        const dateTimeStr = `${event.date} ${currentYear}`;
                        eventDate = new Date(dateTimeStr);
                        
                        // If the event date is in the past, it might be next year
                        if (!isNaN(eventDate.getTime())) {
                            const now = new Date();
                            if (eventDate < now) {
                                eventDate.setFullYear(currentYear + 1);
                            }
                        }
                    }
                    
                    if (!eventDate || isNaN(eventDate.getTime())) {
                        console.warn('Could not parse date for event:', event.date, event);
                        return false;
                    }
                    
                    const tomorrow = new Date();
                    tomorrow.setDate(tomorrow.getDate() + 1);
                    return eventDate.toDateString() === tomorrow.toDateString();
                } catch (error) {
                    console.error('Error parsing date for event:', event.date, error);
                    return false;
                }
            });

            document.getElementById('liveCount').textContent = liveEvents.length;
            document.getElementById('todayCount').textContent = todayEvents.length;
            document.getElementById('tomorrowCount').textContent = tomorrowEvents.length;
        }

        function filterLiveEvents() {
            const events = eventsData[currentSport] || [];
            const activeEvents = events.filter(event => !event.is_completed && !event.is_cancelled);
            const liveEvents = activeEvents.filter(event => event.is_live);
            
            // Sort live events by time
            const sortedLiveEvents = liveEvents.sort((a, b) => {
                const dateA = new Date(a.date + ' ' + new Date().getFullYear() + ' ' + a.time);
                const dateB = new Date(b.date + ' ' + new Date().getFullYear() + ' ' + b.time);
                return dateA - dateB;
            });
            
            displayListView(sortedLiveEvents, document.getElementById('eventsContent'));
        }

        function filterTodayEvents() {
            const events = eventsData[currentSport] || [];
            const activeEvents = events.filter(event => !event.is_completed && !event.is_cancelled);
            const todayEvents = activeEvents.filter(event => {
                try {
                    // Handle different date formats from GoalServe API
                    let eventDate;
                    const currentYear = new Date().getFullYear();
                    
                    if (event.date && event.date.includes('.')) {
                        // Format: "07.08.2025" or "07.08"
                        const dateParts = event.date.split('.');
                        if (dateParts.length === 3) {
                            // Full date: "07.08.2025"
                            const day = parseInt(dateParts[0]);
                            const month = parseInt(dateParts[1]) - 1; // Month is 0-indexed
                            const year = parseInt(dateParts[2]);
                            eventDate = new Date(year, month, day);
                        } else if (dateParts.length === 2) {
                            // Partial date: "07.08" - assume current year
                            const day = parseInt(dateParts[0]);
                            const month = parseInt(dateParts[1]) - 1;
                            eventDate = new Date(currentYear, month, day);
                        }
                    } else if (event.date) {
                        // Try other formats like "Aug 05"
                        const dateTimeStr = `${event.date} ${currentYear}`;
                        eventDate = new Date(dateTimeStr);
                        
                        // If the event date is in the past, it might be next year
                        if (!isNaN(eventDate.getTime())) {
                            const now = new Date();
                            if (eventDate < now) {
                                eventDate.setFullYear(currentYear + 1);
                            }
                        }
                    }
                    
                    if (!eventDate || isNaN(eventDate.getTime())) {
                        console.warn('Could not parse date for event:', event.date, event);
                        return false;
                    }
                    
                    const today = new Date();
                    return eventDate.toDateString() === today.toDateString();
                } catch (error) {
                    console.error('Error parsing date for event:', event.date, error);
                    return false;
                }
            });
            
            // Sort today's events chronologically
            const sortedTodayEvents = todayEvents.sort((a, b) => {
                try {
                    const dateA = new Date(a.date + ' ' + new Date().getFullYear() + ' ' + a.time);
                    const dateB = new Date(b.date + ' ' + new Date().getFullYear() + ' ' + b.time);
                    return dateA - dateB;
                } catch (error) {
                    console.error('Error sorting today events:', error);
                    return 0;
                }
            });
            
            displayListView(sortedTodayEvents, document.getElementById('eventsContent'));
        }

        function filterTomorrowEvents() {
            const events = eventsData[currentSport] || [];
            const activeEvents = events.filter(event => !event.is_completed && !event.is_cancelled);
            const tomorrowEvents = activeEvents.filter(event => {
                try {
                    // Handle different date formats from GoalServe API
                    let eventDate;
                    const currentYear = new Date().getFullYear();
                    
                    if (event.date && event.date.includes('.')) {
                        // Format: "07.08.2025" or "07.08"
                        const dateParts = event.date.split('.');
                        if (dateParts.length === 3) {
                            // Full date: "07.08.2025"
                            const day = parseInt(dateParts[0]);
                            const month = parseInt(dateParts[1]) - 1; // Month is 0-indexed
                            const year = parseInt(dateParts[2]);
                            eventDate = new Date(year, month, day);
                        } else if (dateParts.length === 2) {
                            // Partial date: "07.08" - assume current year
                            const day = parseInt(dateParts[0]);
                            const month = parseInt(dateParts[1]) - 1;
                            eventDate = new Date(currentYear, month, day);
                        }
                    } else if (event.date) {
                        // Try other formats like "Aug 05"
                        const dateTimeStr = `${event.date} ${currentYear}`;
                        eventDate = new Date(dateTimeStr);
                        
                        // If the event date is in the past, it might be next year
                        if (!isNaN(eventDate.getTime())) {
                            const now = new Date();
                            if (eventDate < now) {
                                eventDate.setFullYear(currentYear + 1);
                            }
                        }
                    }
                    
                    if (!eventDate || isNaN(eventDate.getTime())) {
                        console.warn('Could not parse date for event:', event.date, event);
                        return false;
                    }
                    
                    const tomorrow = new Date();
                    tomorrow.setDate(tomorrow.getDate() + 1);
                    return eventDate.toDateString() === tomorrow.toDateString();
                } catch (error) {
                    console.error('Error parsing date for event:', event.date, error);
                    return false;
                }
            });
            
            // Sort tomorrow's events chronologically
            const sortedTomorrowEvents = tomorrowEvents.sort((a, b) => {
                try {
                    const dateA = new Date(a.date + ' ' + new Date().getFullYear() + ' ' + a.time);
                    const dateB = new Date(b.date + ' ' + new Date().getFullYear() + ' ' + b.time);
                    return dateA - dateB;
                } catch (error) {
                    console.error('Error sorting tomorrow events:', error);
                    return 0;
                }
            });
            
            displayListView(sortedTomorrowEvents, document.getElementById('eventsContent'));
        }

        // Performance optimization: Debounced search
        let searchTimeout;
        function debouncedSearch(searchTerm) {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => {
                performSearch(searchTerm);
            }, 300); // 300ms delay
        }

        // Optimized search function
        function performSearch(searchTerm) {
            currentSearchTerm = searchTerm;
            if (currentView === 'list') {
                displayEvents(); // This will apply the search filter
            }
        }

        // Performance optimization: Cache for formatted times
        const timeFormatCache = new Map();
        
        // Optimized time formatting with caching
        function formatEventTime(event) {
            const cacheKey = `${event.date}_${event.time}`;
            if (timeFormatCache.has(cacheKey)) {
                return timeFormatCache.get(cacheKey);
            }
            
            // Handle the specific format from GoalServe API
            if (event.date && event.time) {
                try {
                    // Handle different date formats
                    let eventDate;
                    const currentYear = new Date().getFullYear();
                    
                    // Check if date is in "DD.MM.YYYY" format (like "07.08.2025")
                    if (event.date.includes('.')) {
                        const dateParts = event.date.split('.');
                        if (dateParts.length === 3) {
                            const day = parseInt(dateParts[0]);
                            const month = parseInt(dateParts[1]) - 1; // Month is 0-indexed
                            const year = parseInt(dateParts[2]);
                            eventDate = new Date(year, month, day);
                        }
                    } else {
                        // Handle "Aug 05" format
                        const dateTimeStr = `${event.date} ${currentYear} ${event.time}`;
                        eventDate = new Date(dateTimeStr);
                        
                        // If the event date is in the past, it might be next year
                        if (!isNaN(eventDate.getTime())) {
                            const now = new Date();
                            if (eventDate < now) {
                                eventDate.setFullYear(currentYear + 1);
                            }
                        }
                    }
                    
                    // Check if it's a valid date
                    if (!isNaN(eventDate.getTime())) {
                        // JSON time is always UTC - convert to local time
                        const timeParts = event.time.split(':');
                        const utcHour = parseInt(timeParts[0]);
                        const utcMinute = parseInt(timeParts[1]);
                        
                        // Create UTC date object
                        const utcDate = new Date(Date.UTC(
                            eventDate.getFullYear(),
                            eventDate.getMonth(),
                            eventDate.getDate(),
                            utcHour,
                            utcMinute
                        ));
                        
                        // Convert to user's local timezone using toLocaleString
                        const localTimeString = utcDate.toLocaleString('en-US', {
                            month: 'short',
                            day: 'numeric',
                            hour: '2-digit',
                            minute: '2-digit',
                            hour12: true,
                            timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone
                        });
                        
                        // Cache the result
                        timeFormatCache.set(cacheKey, localTimeString);
                        return localTimeString;
                    }
                } catch (e) {
                    console.log('Error parsing event time:', e);
                }
            }
            
            // Fallback to original time or date
            let fallbackResult;
            if (event.date && event.time) {
                fallbackResult = `${event.date} ${event.time}`;
            } else if (event.time) {
                fallbackResult = event.time;
            } else if (event.date) {
                fallbackResult = event.date;
            } else {
                fallbackResult = 'TBD';
            }
            
            // Cache the fallback result too
            timeFormatCache.set(cacheKey, fallbackResult);
            return fallbackResult;
        }

        // Performance optimization: Batch DOM updates
        function batchDOMUpdates(updates) {
            // Use requestAnimationFrame for smooth updates
            requestAnimationFrame(() => {
                updates.forEach(update => update());
            });
        }

        // Performance optimization: Lazy loading for events
        const EVENTS_PER_PAGE = 50;
        let currentPage = 0;
        let allEvents = [];

        function loadMoreEvents() {
            const startIndex = currentPage * EVENTS_PER_PAGE;
            const endIndex = startIndex + EVENTS_PER_PAGE;
            const eventsToShow = allEvents.slice(0, endIndex);
            
            displayEvents(eventsToShow);
            
            if (endIndex < allEvents.length) {
                // Show load more button
                const loadMoreBtn = document.createElement('button');
                loadMoreBtn.className = 'load-more-btn';
                loadMoreBtn.textContent = 'Load More Events';
                loadMoreBtn.onclick = () => {
                    currentPage++;
                    loadMoreEvents();
                };
                
                const container = document.getElementById('eventsContent');
                const existingBtn = container.querySelector('.load-more-btn');
                if (existingBtn) {
                    existingBtn.remove();
                }
                container.appendChild(loadMoreBtn);
            }
        }

        // Optimized displayEvents function
        function displayEvents(eventsToDisplay = null) {
            const events = eventsToDisplay || eventsData[currentSport] || [];
            const container = document.getElementById('eventsContent');
            
            // Filter out completed and cancelled matches
            let activeEvents = events.filter(event => !event.is_completed && !event.is_cancelled);
            
            // Apply current search filter if exists
            if (currentSearchTerm && currentSearchTerm.trim() !== '') {
                const searchTerm = currentSearchTerm.toLowerCase().trim();
                activeEvents = activeEvents.filter(event => {
                    const homeTeam = event.home_team?.toLowerCase() || '';
                    const awayTeam = event.away_team?.toLowerCase() || '';
                    const league = event.league?.toLowerCase() || '';
                    const venue = event.venue?.toLowerCase() || '';
                    
                    return homeTeam.includes(searchTerm) ||
                           awayTeam.includes(searchTerm) ||
                           league.includes(searchTerm) ||
                           venue.includes(searchTerm) ||
                           `${homeTeam} ${awayTeam}`.includes(searchTerm) ||
                           `${awayTeam} ${homeTeam}`.includes(searchTerm);
                });
            }
            
            if (activeEvents.length === 0) {
                if (currentSearchTerm && currentSearchTerm.trim() !== '') {
                    container.innerHTML = `<div class="loading-text">No events found for "${currentSearchTerm}"</div>`;
                } else {
                    container.innerHTML = '<div class="loading-text">No active events found for this sport</div>';
                }
                return;
            }
            
            // Sort events chronologically (live matches first, then by date/time)
            const sortedEvents = activeEvents.sort((a, b) => {
                // Live matches come first
                if (a.is_live && !b.is_live) return -1;
                if (!a.is_live && b.is_live) return 1;
                
                // Then sort by date and time
                const dateA = new Date(a.date + ' ' + new Date().getFullYear() + ' ' + a.time);
                const dateB = new Date(b.date + ' ' + new Date().getFullYear() + ' ' + b.time);
                
                return dateA - dateB;
            });
            
            // Store current events globally for market filtering
            window.currentEvents = sortedEvents;
            allEvents = sortedEvents; // Store for lazy loading
            currentPage = 0; // Reset pagination
            
            // Update filter counts
            updateFilterCounts(sortedEvents);
            
            // Restore search input state
            restoreSearchState();
            
            // Use lazy loading for large lists
            if (sortedEvents.length > EVENTS_PER_PAGE) {
                loadMoreEvents();
            } else {
                if (currentView === 'list') {
                    displayListView(sortedEvents, container);
                } else {
                    displayCouponView(sortedEvents, container);
                }
            }
        }

        // Helper function to get sport-specific column headers
        function getOddsColumns() {
            // Special handling for baseball - only show configured markets
            if (currentSport === 'baseball') {
                switch (currentMarket) {
                    case 'match_result':
                        return getSportSpecificHeaders();
                    case 'correct_score':
                        return '<div>1-0</div><div>2-1</div><div>2-0</div>';
                    case 'odd_even_including_ot':
                        return '<div>Yes</div><div>No</div>';
                    default:
                        return ''; // Hide invalid markets for baseball
                }
            }
            
            // Special handling for cricket - 1-2 market (no draw)
            if (currentSport === 'cricket' && currentMarket === 'match_result') {
                return '<div>1</div><div>2</div>';
            }
            
            // For other sports, use existing logic
            switch (currentMarket) {
                case 'match_result':
                    return getSportSpecificHeaders();
                case 'both_teams_score':
                case 'clean_sheet_home':
                case 'clean_sheet_away':
                case 'win_to_nil_home':
                case 'win_to_nil_away':
                case 'team_to_score_first':
                case 'home_team_score_goal':
                case 'away_team_score_goal':
                case 'odd_even':
                case 'odd_even_first_half':
                case 'odd_even_first_set':
                case 'odd_even_including_ot':
                case 'to_qualify':
                case 'tie_break_first_set':
                case 'win_one_set_player1':
                case 'win_one_set_player2':
                    return '<div>Yes</div><div>No</div>';
                case 'correct_score':
                case 'correct_score_first_half':
                case 'correct_score_second_half':
                    return '<div>1-0</div><div>2-1</div><div>2-0</div>';
                case 'asian_handicap':
                case 'asian_handicap_first_half':
                case 'asian_handicap_first_quarter':
                case 'asian_handicap_sets':
                case 'asian_handicap_games':
                case 'first_set':
                case 'second_set':
                case 'first_half_winner':
                case 'first_quarter_winner':
                case 'second_half_winner':
                    return '<div>Home</div><div>Away</div>';
                case 'over_under':
                case 'over_under_first_half':
                case 'over_under_first_quarter':
                case 'over_under_first_set':
                case 'games_over_under':
                case 'corners_over_under':
                    return '<div>Over</div><div>Under</div>';
                case 'set_betting':
                    return '<div>2-0</div><div>2-1</div><div>0-2</div>';
                case 'handicap_result':
                    return '<div>Home</div><div>Draw</div><div>Away</div>';
                case 'highest_scoring_half':
                case 'highest_scoring_quarter':
                    return '<div>1st</div><div>2nd</div><div>3rd</div>';
                case 'double_chance':
                case 'double_chance_first_half':
                case 'double_chance_second_half':
                    return '<div>1X</div><div>X2</div><div>12</div>';
                case 'win_both_halves':
                    return '<div>Yes</div><div>No</div>';
                case 'both_teams_score_first_half':
                case 'both_teams_score_second_half':
                    return '<div>Yes</div><div>No</div>';
                case 'results_both_teams_score':
                    return '<div>1/Yes</div><div>X/Yes</div><div>2/Yes</div>';
                case 'result_total_goals':
                    return '<div>1/Over</div><div>X/Over</div><div>2/Over</div>';
                case 'corners_1x2':
                    return '<div>Home</div><div>Draw</div><div>Away</div>';
                case 'ht_ft_double':
                    return '<div>1/1</div><div>1/X</div><div>1/2</div>';
                case 'first_half_3way_result':
                    return '<div>1</div><div>X</div><div>2</div>';
                default:
                    return getSportSpecificHeaders();
            }
        }

        // Optimized displayListView with virtual scrolling concept
        function displayListView(events, container) {
            // Filter out events that don't have odds for the current market
            const eventsWithOdds = events.filter(event => {
                if (!event.odds) return false;
                
                // Special handling for darts - only show correct_score market
                if (currentSport === 'darts' && currentMarket !== 'correct_score') {
                    return false;
                }
                
                // For match_result (main market), be more lenient - show all events
                if (currentMarket === 'match_result') {
                    return true; // Show all events for main market
                }
                
                // For secondary markets, check if the event has odds for the current market
                const hasOddsForCurrentMarket = event.odds[currentMarket] && 
                    Array.isArray(event.odds[currentMarket]) && 
                    event.odds[currentMarket].length > 0;
                
                return hasOddsForCurrentMarket;
            });
            
            console.log(`Filtered events: ${eventsWithOdds.length} out of ${events.length} have odds for market '${currentMarket}'`);
            
            // Use DocumentFragment for better performance
            const fragment = document.createDocumentFragment();
            
            // Create header
            const header = document.createElement('div');
            header.className = 'table-header';
            header.style.gridTemplateColumns = getSportSpecificGridTemplate();
            header.innerHTML = `
                <div>Date & Time</div>
                <div>Event</div>
                ${getOddsColumns()}
            `;
            fragment.appendChild(header);
            
            // Create event rows in batches
            const batchSize = 20;
            for (let i = 0; i < eventsWithOdds.length; i += batchSize) {
                const batch = eventsWithOdds.slice(i, i + batchSize);
                
                batch.forEach(event => {
                    const eventRow = document.createElement('div');
                    eventRow.className = `event-row ${event.is_live ? 'live-match' : ''}`;
                    eventRow.style.gridTemplateColumns = getSportSpecificGridTemplate();
                    eventRow.innerHTML = `
                        <div class="event-time">
                            ${formatEventTime(event)}
                            ${event.is_live ? '<span class="live-indicator">üî¥ LIVE</span>' : ''}
                            <div class="event-status">
                                ${formatMatchStatus(event.status)}
                            </div>
                        </div>
                        <div class="event-info">
                            <div class="event-teams">
                                ${event.home_team} vs ${event.away_team}
                                ${event.is_live ? `<span class="live-score">${event.home_score} - ${event.away_score}</span>` : ''}
                            </div>
                            <div class="event-league">${event.league || 'Unknown League'}</div>
                        </div>
                        ${generateOddsButtons(event, currentMarket)}
                    `;
                    fragment.appendChild(eventRow);
                });
                
                // Use requestAnimationFrame to prevent blocking
                if (i + batchSize < eventsWithOdds.length) {
                    setTimeout(() => {}, 0);
                }
            }
            
            // Clear container and append fragment
            container.innerHTML = '';
            container.appendChild(fragment);
        }

        function formatMatchStatus(status) {
            if (!status) return '';
            
            // If status is a number (minutes), add "'" to indicate minutes
            if (!isNaN(status) && status.length <= 2) {
                return `${status}'`;
            }
            
            // If status contains ":" it's a scheduled time - hide it
            if (status.includes(':')) {
                return ''; // Don't show scheduled times
            }
            
            // Common status codes - show these
            const statusMap = {
                'HT': 'HT',
                'FT': 'FT',
                '1H': '1H',
                '2H': '2H',
                'Cancl.': '‚ùå Cancelled',
                'Postp.': '‚è∏Ô∏è Postponed',
                'WO': '‚ùå Walk Over',
                'Aban.': 'üö´ Abandoned',
                'AET': '‚öΩ AET',
                'Pen.': 'üéØ Penalties'
            };
            
            return statusMap[status] || status;
        }

        // Helper function to get sport-specific column headers
        function getSportSpecificHeaders() {
            const sportsWithDraws = ['soccer', 'basketball', 'hockey', 'handball', 'cricket', 'rugby', 'rugbyleague', 'futsal'];
            const sportsWithoutDraws = ['tennis', 'volleyball', 'football', 'baseball', 'table_tennis', 'boxing', 'mma', 'darts', 'esports'];
            
            if (sportsWithoutDraws.includes(currentSport)) {
                return '<div>1</div><div>2</div>';
            } else {
                return '<div>1</div><div>X</div><div>2</div>';
            }
        }

        // Helper function to get sport-specific grid template
        function getSportSpecificGridTemplate() {
            const sportsWithDraws = ['soccer', 'basketball', 'hockey', 'handball', 'cricket', 'rugby', 'rugbyleague', 'futsal'];
            const sportsWithoutDraws = ['tennis', 'volleyball', 'football', 'baseball', 'table_tennis', 'boxing', 'mma', 'darts', 'esports'];
            
            // For match_result market, use sport-specific logic
            if (currentMarket === 'match_result') {
                if (sportsWithoutDraws.includes(currentSport)) {
                    return '120px 1fr 120px 120px'; // 4 columns: time, event, 1, 2
                } else {
                    return '120px 1fr 120px 120px 120px'; // 5 columns: time, event, 1, X, 2
                }
            }
            
            // For other markets, determine columns based on market type
            switch (currentMarket) {
                case 'goals_over_under':
                case 'both_teams_score':
                case 'asian_handicap':
                case 'over_under':
                case 'games_over_under':
                case 'first_set':
                case 'first_half':
                case 'first_quarter':
                    return '120px 1fr 120px 120px'; // 2 odds columns
                case 'correct_score':
                case 'set_betting':
                    return '120px 1fr 120px 120px 120px'; // 3 odds columns
                default:
                    return '120px 1fr 120px 120px 120px'; // Default 3 columns
            }
        }

        function displayCouponView(events, container) {
            container.innerHTML = `
                <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 1rem; padding: 1rem;">
                    ${events.map(event => `
                        <div style="background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 12px; padding: 1rem; transition: all 0.3s ease;">
                            <div style="text-align: center; margin-bottom: 1rem;">
                                <div style="font-size: 0.9rem; color: #fbbf24; margin-bottom: 0.5rem;">${formatEventTime(event)}</div>
                                <div style="font-weight: 600; margin-bottom: 0.25rem;">${event.home_team} VS ${event.away_team}</div>
                                <div style="font-size: 0.8rem; color: rgba(255, 255, 255, 0.6);">${event.league || 'Unknown League'}</div>
                        </div>
                            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.5rem;">
                                ${generateOddsButtons(event, currentMarket)}
                    </div>
                        </div>
                    `).join('')}
                    </div>
                `;
        }

        function getDisabledReason(event) {
            if (event.status === 'Aban.') return 'Abandoned';
            if (event.status === 'Cancl.') return 'Cancelled';
            if (event.status === 'FT' || event.is_completed) return 'Finished';
            
            // For live matches without live odds
            if (event.is_live && (!event.live_odds || Object.keys(event.live_odds).length === 0)) {
                return 'No Live Odds';
            }
            
            return 'Unavailable';
        }

        function generateOddsButtons(event, market) {
            console.log(`üéØ Generating odds buttons for ${event.home_team} vs ${event.away_team} - Market: ${market}`);
            console.log('Event odds:', event.odds);
            
                        // Check if match is available for betting
            const isAvailableForBetting = () => {
                // Don't allow betting on abandoned, cancelled, or completed matches
                if (event.status === 'Aban.' || event.status === 'Cancl.' || event.status === 'FT' || event.is_completed) {
                    return false;
                }
                
                // For live matches, only allow if we have live odds
                if (event.is_live) {
                    return event.live_odds && Object.keys(event.live_odds).length > 0;
                }
                
                // For pre-match, allow betting
                return true;
            };

            const getOdds = () => {
                switch (market) {
                    case 'match_result':
                    case 'match_winner':  // Basketball, Tennis, etc.
                        // Use odds from JSON files (event.odds.match_result)
                        if (event.odds && event.odds.match_result) {
                            console.log(`Using JSON odds for ${event.home_team} vs ${event.away_team}:`, event.odds.match_result);
                            const odds_data = event.odds.match_result;
                            const result = [
                                { label: '1', odds: parseFloat(odds_data['1']), selection: event.home_team }
                            ];
                            
                            // Add draw option if available
                            if (odds_data['X']) {
                                result.push({ label: 'X', odds: parseFloat(odds_data['X']), selection: 'Draw' });
                            }
                            
                            result.push({ label: '2', odds: parseFloat(odds_data['2']), selection: event.away_team });
                            
                            console.log('Generated odds result:', result);
                            return result;
                        } else {
                            console.log(`‚ùå No match_result odds found for ${event.home_team} vs ${event.away_team}`);
                            console.log('Available odds markets:', event.odds ? Object.keys(event.odds) : 'No odds object');
                            // No odds available - return null to indicate no betting
                            return null;
                        }
                    case 'both_teams_score':
                    case 'clean_sheet_home':
                    case 'clean_sheet_away':
                    case 'win_to_nil_home':
                    case 'win_to_nil_away':
                    case 'team_to_score_first':
                    case 'home_team_score_goal':
                    case 'away_team_score_goal':
                    case 'odd_even':
                    case 'odd_even_first_half':
                    case 'odd_even_first_set':
                    case 'odd_even_including_ot':
                    case 'to_qualify':
                    case 'tie_break_first_set':
                    case 'win_one_set_player1':
                    case 'win_one_set_player2':
                    case 'win_both_halves':
                    case 'both_teams_score_first_half':
                    case 'both_teams_score_second_half':
                        const yesNoMarket = market;
                        if (event.odds && event.odds[yesNoMarket] && event.odds[yesNoMarket].length >= 2) {
                            return [
                                { label: 'Yes', odds: parseFloat(event.odds[yesNoMarket][0]), selection: 'Yes' },
                                { label: 'No', odds: parseFloat(event.odds[yesNoMarket][1]), selection: 'No' }
                            ];
                        }
                        return null;
                    case 'correct_score':
                    case 'correct_score_first_half':
                    case 'correct_score_second_half':
                        const correctScoreMarket = market;
                        if (event.odds && event.odds[correctScoreMarket] && event.odds[correctScoreMarket].length >= 3) {
                            return [
                                { label: '1-0', odds: parseFloat(event.odds[correctScoreMarket][0]), selection: 'Correct Score 1-0' },
                                { label: '2-1', odds: parseFloat(event.odds[correctScoreMarket][1]), selection: 'Correct Score 2-1' },
                                { label: '2-0', odds: parseFloat(event.odds[correctScoreMarket][2]), selection: 'Correct Score 2-0' }
                            ];
                        }
                        return null;
                    case 'asian_handicap':
                        // For soccer, use actual markets from JSON
                        if (event.odds && event.odds.first_half_winner) {
                            console.log(`Found first_half_winner for ${event.home_team} vs ${event.away_team}:`, event.odds.first_half_winner);
                            const oddsData = event.odds.first_half_winner;
                            if (Array.isArray(oddsData) && oddsData.length >= 2) {
                                return [
                                    { label: 'Home', odds: parseFloat(oddsData[0]), selection: 'Home Win 1st Half' },
                                    { label: 'Away', odds: parseFloat(oddsData[1]), selection: 'Away Win 1st Half' }
                                ];
                            }
                        }
                        console.log(`No first_half_winner odds found for ${event.home_team} vs ${event.away_team}`);
                        console.log(`Available odds markets:`, event.odds ? Object.keys(event.odds) : 'No odds');
                        return null;
                    case 'asian_handicap_first_half':
                    case 'asian_handicap_first_quarter':
                    case 'asian_handicap_sets':
                    case 'asian_handicap_games':
                    case 'first_set':
                    case 'second_set':
                    case 'first_half_winner':
                    case 'first_quarter_winner':
                    case 'second_half_winner':
                        const homeAwayMarket = market;
                        if (event.odds && event.odds[homeAwayMarket] && event.odds[homeAwayMarket].length >= 2) {
                            return [
                                { label: 'Home', odds: parseFloat(event.odds[homeAwayMarket][0]), selection: 'Home Win' },
                                { label: 'Away', odds: parseFloat(event.odds[homeAwayMarket][1]), selection: 'Away Win' }
                            ];
                        }
                        return null;
                    case 'over_under':
                        // For soccer, use both_teams_score market from JSON
                        if (event.odds && event.odds.both_teams_score) {
                            console.log(`Found both_teams_score for ${event.home_team} vs ${event.away_team}:`, event.odds.both_teams_score);
                            const oddsData = event.odds.both_teams_score;
                            if (Array.isArray(oddsData) && oddsData.length >= 2) {
                                return [
                                    { label: 'Yes', odds: parseFloat(oddsData[0]), selection: 'Both Teams Score' },
                                    { label: 'No', odds: parseFloat(oddsData[1]), selection: 'Not Both Teams Score' }
                                ];
                            }
                        }
                        console.log(`No both_teams_score odds found for ${event.home_team} vs ${event.away_team}`);
                        console.log(`Available odds markets:`, event.odds ? Object.keys(event.odds) : 'No odds');
                        return null;
                    case 'over_under_first_half':
                    case 'over_under_first_quarter':
                    case 'over_under_first_set':
                    case 'games_over_under':
                    case 'corners_over_under':
                        const overUnderMarket = market;
                        if (event.odds && event.odds[overUnderMarket] && event.odds[overUnderMarket].length >= 2) {
                            return [
                                { label: 'Over', odds: parseFloat(event.odds[overUnderMarket][0]), selection: 'Over' },
                                { label: 'Under', odds: parseFloat(event.odds[overUnderMarket][1]), selection: 'Under' }
                            ];
                        }
                        return null;
                    case 'set_betting':
                        if (event.odds && event.odds.set_betting && event.odds.set_betting.length >= 3) {
                            return [
                                { label: '2-0', odds: parseFloat(event.odds.set_betting[0]), selection: 'Win 2-0' },
                                { label: '2-1', odds: parseFloat(event.odds.set_betting[1]), selection: 'Win 2-1' },
                                { label: '0-2', odds: parseFloat(event.odds.set_betting[2]), selection: 'Lose 0-2' }
                            ];
                        }
                        return null;
                    case 'handicap_result':
                    case 'corners_1x2':
                    case 'first_half_3way_result':
                        const threeWayMarket = market;
                        if (event.odds && event.odds[threeWayMarket] && event.odds[threeWayMarket].length >= 3) {
                            return [
                                { label: 'Home', odds: parseFloat(event.odds[threeWayMarket][0]), selection: 'Home' },
                                { label: 'Draw', odds: parseFloat(event.odds[threeWayMarket][1]), selection: 'Draw' },
                                { label: 'Away', odds: parseFloat(event.odds[threeWayMarket][2]), selection: 'Away' }
                            ];
                        }
                        return null;
                    case 'highest_scoring_half':
                    case 'highest_scoring_quarter':
                        const scoringMarket = market;
                        if (event.odds && event.odds[scoringMarket] && event.odds[scoringMarket].length >= 3) {
                            return [
                                { label: '1st', odds: parseFloat(event.odds[scoringMarket][0]), selection: '1st' },
                                { label: '2nd', odds: parseFloat(event.odds[scoringMarket][1]), selection: '2nd' },
                                { label: '3rd', odds: parseFloat(event.odds[scoringMarket][2]), selection: '3rd' }
                            ];
                        }
                        return null;
                    case 'double_chance':
                    case 'double_chance_first_half':
                    case 'double_chance_second_half':
                        const doubleChanceMarket = market;
                        if (event.odds && event.odds[doubleChanceMarket] && event.odds[doubleChanceMarket].length >= 3) {
                            return [
                                { label: '1X', odds: parseFloat(event.odds[doubleChanceMarket][0]), selection: '1X' },
                                { label: 'X2', odds: parseFloat(event.odds[doubleChanceMarket][1]), selection: 'X2' },
                                { label: '12', odds: parseFloat(event.odds[doubleChanceMarket][2]), selection: '12' }
                            ];
                        }
                        return null;
                    case 'results_both_teams_score':
                        if (event.odds && event.odds.results_both_teams_score && event.odds.results_both_teams_score.length >= 3) {
                            return [
                                { label: '1/Yes', odds: parseFloat(event.odds.results_both_teams_score[0]), selection: '1/Yes' },
                                { label: 'X/Yes', odds: parseFloat(event.odds.results_both_teams_score[1]), selection: 'X/Yes' },
                                { label: '2/Yes', odds: parseFloat(event.odds.results_both_teams_score[2]), selection: '2/Yes' }
                            ];
                        }
                        return null;
                    case 'result_total_goals':
                        if (event.odds && event.odds.result_total_goals && event.odds.result_total_goals.length >= 3) {
                            return [
                                { label: '1/Over', odds: parseFloat(event.odds.result_total_goals[0]), selection: '1/Over' },
                                { label: 'X/Over', odds: parseFloat(event.odds.result_total_goals[1]), selection: 'X/Over' },
                                { label: '2/Over', odds: parseFloat(event.odds.result_total_goals[2]), selection: '2/Over' }
                            ];
                        }
                        return null;
                    case 'ht_ft_double':
                        if (event.odds && event.odds.ht_ft_double && event.odds.ht_ft_double.length >= 3) {
                            return [
                                { label: '1/1', odds: parseFloat(event.odds.ht_ft_double[0]), selection: '1/1' },
                                { label: '1/X', odds: parseFloat(event.odds.ht_ft_double[1]), selection: '1/X' },
                                { label: '1/2', odds: parseFloat(event.odds.ht_ft_double[2]), selection: '1/2' }
                            ];
                        }
                        return null;
                    default:
                        return null; // No odds available
                        return null; // No odds available
                }
            };

            const odds = getOdds();
            
            // If no odds are available, don't show any betting buttons
            if (!odds) {
                return '';
            }
            
            // If match is not available for betting, show disabled buttons
            if (!isAvailableForBetting()) {
                return odds.map(odd => `
                    <button class="odds-btn disabled" disabled style="opacity: 0.5; cursor: not-allowed;">
                        <div style="font-weight: 600; font-size: 1.1rem;">${odd.odds}</div>
                        <div style="font-size: 0.7rem; color: #ef4444; margin-top: 0.25rem;">${getDisabledReason(event)}</div>
                    </button>
                `).join('');
            }
            
            return odds.map(odd => {
                // Find the actual market ID from the event's odds data
                let marketId = 'unknown';
                if (event && event.odds) {
                    // Look for the market with this display name and get its ID
                    if (Object.entries) {
                        for (var i = 0; i < Object.keys(event.odds).length; i++) {
                            var marketKey = Object.keys(event.odds)[i];
                            var marketData = event.odds[marketKey];
                            if (marketKey === market || marketData === market) {
                                // This is the market we're looking for, get its ID
                                const marketIdKey = `${marketKey}_market_id`;
                                if (event.odds[marketIdKey]) {
                                    marketId = event.odds[marketIdKey];
                                }
                                break;
                            }
                        }
                    } else {
                        // Fallback for older browsers
                        for (const marketKey in event.odds) {
                            if (event.odds.hasOwnProperty(marketKey)) {
                                const marketData = event.odds[marketKey];
                                if (marketKey === market || marketData === market) {
                                    // This is the market we're looking for, get its ID
                                    const marketIdKey = `${marketKey}_market_id`;
                                    if (event.odds[marketIdKey]) {
                                        marketId = event.odds[marketIdKey];
                                    }
                                    break;
                                }
                            }
                        }
                    }
                }
                
                console.log(`üéØ Market: ${market}, Market ID: ${marketId}, Event odds:`, event.odds);
                return `
                    <button class="odds-btn" onclick="addToBetSlip('${event.id || Math.random()}', '${event.home_team} vs ${event.away_team}', '${odd.selection}', ${odd.odds}, '${marketId}')">
                        <div style="font-weight: 600; font-size: 1.1rem;">${odd.odds}</div>
                    </button>
                `;
            }).join('');
        }

        // Market switching
        function switchMarket(market) {
            currentMarket = market;
            document.querySelectorAll('.market-tab').forEach(tab => tab.classList.remove('active'));
            event.target.classList.add('active');
            displayEvents();
        }

        // View switching
        function switchView(view) {
            currentView = view;
            document.querySelectorAll('.view-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            displayEvents();
        }

        // Bet slip functions
        let betMode = 'single'; // 'single' or 'combo'
        let maxComboBets = 5;
        
        function addToBetSlip(eventId, matchName, selection, odds, marketId) {
            console.log(`üéØ Adding to bet slip: ${eventId}, ${matchName}, ${selection}, ${odds}, market: ${marketId}`);
            
            // Check if we're in combo mode and have reached the limit
            if (betMode === 'combo' && betSlip.length >= maxComboBets) {
                showWarningAlert('Too Many Bets', `Maximum ${maxComboBets} bets allowed in combo mode.`, 3000);
                return;
            }
            
            const existingBet = betSlip.find(bet => bet.eventId === eventId && bet.selection === selection);
            if (existingBet) {
                return; // Already in bet slip
            }

            // Find the actual event to get the real match ID, time, sport, and timing
            const currentEvents = window.currentEvents || eventsData[currentSport] || [];
            const actualEvent = currentEvents.find(e => e.id === eventId);
            const matchId = actualEvent ? actualEvent.id : eventId; // Use actual GoalServe match ID
            const matchTime = actualEvent ? actualEvent.time : '';
            const sport = actualEvent ? actualEvent.sport : currentSport; // Get sport from event data
            const betTiming = 'pregame'; // Default to pregame for now, can be enhanced later

            betSlip.push({
                eventId,
                matchId: matchId, // Store actual GoalServe match ID for settlement
                matchName,
                matchTime: matchTime, // Store match time for validation
                selection,
                odds,
                stake: 10,
                sport: sport, // Store sport information for combo bets
                bet_timing: betTiming, // Store bet timing for combo bets
                marketId: marketId // Store market ID for admin liability calculation
            });
            
            // Start real-time updates if this is the first bet
            if (betSlip.length === 1) {
                startBetSlipUpdates();
            }
            
            updateBetSlip();
        }
        
        function toggleBetMode() {
            const newMode = (betMode === 'single') ? 'combo' : 'single';

            // If there are selections, confirm before switching
            if (Array.isArray(betSlip) && betSlip.length > 0) {
                const title = 'Switch Bet Mode';
                const msg = 'Switching bet modes will clear your current selections. Continue?';

                if (typeof showCustomConfirm === 'function') {
                    showCustomConfirm(
                        title,
                        msg,
                        function onConfirm() {
                            betMode = newMode;
                            betSlip = [];
                            comboTotalStake = (betMode === 'combo') ? 10 : 0;
                            stopBetSlipUpdates();
                            updateBetSlip();
                            updateBetModeDisplay();
                        },
                        function onCancel() {
                            // Do nothing; keep current mode
                        }
                    );
                    return; // wait for user action
                } else {
                    // Fallback to native confirm
                    if (!window.confirm(msg)) return;
                    betMode = newMode;
                    betSlip = [];
                    comboTotalStake = (betMode === 'combo') ? 10 : 0;
                    stopBetSlipUpdates();
                    updateBetSlip();
                    updateBetModeDisplay();
                    return;
                }
            }

            // No selections ‚Äî switch immediately
            betMode = newMode;
            comboTotalStake = (betMode === 'combo') ? 10 : 0;
            updateBetSlip();
            updateBetModeDisplay();
        }, function() {
                    // Revert the toggle
                    betMode = betMode === 'single' ? 'combo' : 'single';
                    return;
                });
            }
            
            // Initialize combo stake when switching to combo mode
            if (betMode === 'combo') {
                comboTotalStake = 10; // Default combo stake
            } else {
                comboTotalStake = 0; // Reset for single mode
            }
            
            updateBetSlip();
            updateBetModeDisplay();
        }

        
        function updateBetModeDisplay() {
            const modeButton = document.getElementById('betModeToggle');
            const sliderLabel = modeButton.querySelector('.slider-label');
            
            if (modeButton) {
                if (betMode === 'combo') {
                    modeButton.classList.add('active');
                    sliderLabel.textContent = 'Combo';
                } else {
                    modeButton.classList.remove('active');
                    sliderLabel.textContent = 'Single';
                }
            }
        }

        function updateBetSlip() {
            const container = document.getElementById('betSlipContent');
            const countElement = document.getElementById('betCount');
            
            countElement.textContent = betSlip.length;
            
            if (betSlip.length === 0) {
                container.innerHTML = `
                    <p>Your bet slip is empty</p>
                    <p>Click on odds to add selections</p>
                    ${betMode === 'combo' ? `<p style="font-size: 0.8rem; color: #4ade80;">Combo Mode: Up to ${maxComboBets} bets</p>` : ''}
                `;
                return;
            }
            
            // Update odds for each bet in the slip
            updateBetSlipOdds();
            
            // Calculate total stake based on bet mode
            let totalStake;
            if (betMode === 'combo') {
                totalStake = comboTotalStake; // Use the combo total stake
            } else {
                totalStake = betSlip.reduce((sum, bet) => sum + bet.stake, 0); // Sum individual stakes
            }
            
            // Calculate potential return based on bet mode
            let potentialReturn, totalOdds;
            if (betMode === 'combo') {
                // Combo bet: multiply all odds together
                totalOdds = betSlip.reduce((product, bet) => product * bet.odds, 1);
                potentialReturn = totalStake * totalOdds;
            } else {
                // Single bets: sum of individual returns
                potentialReturn = betSlip.reduce((sum, bet) => sum + (bet.stake * bet.odds), 0);
                totalOdds = 0; // Not applicable for single bets
            }

            container.innerHTML = `
                ${betMode === 'combo' ? `
                    <div style="background: linear-gradient(135deg, #4ade80, #22c55e); border-radius: 8px; padding: 0.75rem; margin-bottom: 1rem; text-align: center;">
                        <div style="font-weight: 600; color: #000;">üéØ COMBO BET</div>
                        <div style="font-size: 0.8rem; color: #000; margin-top: 0.25rem;">
                            ${betSlip.length}/${maxComboBets} selections ‚Ä¢ Total Odds: ${totalOdds.toFixed(2)}x
                        </div>
                    </div>
                ` : ''}
                ${betSlip.map((bet, index) => `
                    <div style="background: rgba(255, 255, 255, 0.05); border-radius: 8px; padding: 1rem; margin-bottom: 1rem;">
                        <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 0.5rem;">
                            <div style="flex: 1;">
                                <div style="font-weight: 600; font-size: 0.9rem; margin-bottom: 0.25rem;">${bet.matchName}</div>
                                <div style="color: #4ade80; font-size: 0.8rem; margin-bottom: 0.25rem;">${bet.selection}</div>
                                <div style="font-weight: 600;">@ ${parseFloat(bet.odds).toFixed(2)}</div>
                            </div>
                            <button onclick="removeFromBetSlip(${index})" style="background: #ef4444; border: none; border-radius: 4px; color: white; padding: 0.25rem 0.5rem; cursor: pointer;">&times;</button>
                        </div>
                        ${betMode === 'single' ? `
                            <div style="display: flex; align-items: center; gap: 0.5rem;">
                                <label style="font-size: 0.8rem; color: rgba(255, 255, 255, 0.7);">Stake:</label>
                                <input type="number" value="${bet.stake}" onchange="updateStake(${index}, this.value)" 
                                       style="background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 4px; padding: 0.25rem; color: white; width: 60px;">
                            </div>
                            <div style="margin-top: 0.5rem; font-size: 0.8rem; color: rgba(255, 255, 255, 0.7);">
                                Return: $${(bet.stake * parseFloat(bet.odds)).toFixed(2)}
                            </div>
                        ` : `
                            <div style="font-size: 0.8rem; color: rgba(255, 255, 255, 0.7); font-style: italic;">
                                Part of combo bet
                            </div>
                        `}
                    </div>
                `).join('')}
                <div style="border-top: 1px solid rgba(255, 255, 255, 0.1); padding-top: 1rem; margin-top: 1rem;">
                    ${betMode === 'combo' ? `
                        <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 1rem;">
                            <label style="font-size: 0.8rem; color: rgba(255, 255, 255, 0.7);">Total Stake:</label>
                            <input type="number" value="${totalStake}" onchange="updateComboStake(this.value)" 
                                   style="background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 4px; padding: 0.25rem; color: white; width: 80px;">
                        </div>
                    ` : ''}
                    <div style="display: flex; justify-content: space-between; margin-bottom: 0.5rem;">
                        <span>Total Stake:</span>
                        <span style="font-weight: 600;">$${totalStake.toFixed(2)}</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin-bottom: 1rem;">
                        <span>${betMode === 'combo' ? 'Combo Return:' : 'Potential Return:'}</span>
                        <span style="font-weight: 600; color: #4ade80;">$${potentialReturn.toFixed(2)}</span>
                    </div>
                    <button onclick="placeBets()" style="width: 100%; background: linear-gradient(135deg, #4ade80, #22c55e); border: none; border-radius: 8px; color: #000; font-weight: 600; padding: 0.75rem; cursor: pointer; transition: all 0.3s ease;">
                        Place ${betMode === 'combo' ? 'Combo ' : ''}Bet
                    </button>
                </div>
            `;
        }

        function removeFromBetSlip(index) {
            betSlip.splice(index, 1);
            
            // Stop updates if no bets left
            if (betSlip.length === 0) {
                stopBetSlipUpdates();
            }
            
            updateBetSlip();
        }

        function updateStake(index, newStake) {
            betSlip[index].stake = parseFloat(newStake) || 0;
            updateBetSlip();
        }
        
        function updateComboStake(totalStake) {
            comboTotalStake = parseFloat(totalStake) || 0;
            updateBetSlip();
        }
        
        // Real-time bet slip odds updates
        let betSlipUpdateInterval = null;
        
        function startBetSlipUpdates() {
            // Clear existing interval
            if (betSlipUpdateInterval) {
                clearInterval(betSlipUpdateInterval);
            }
            
            console.log('Starting bet slip updates every 0.5 seconds...');
            
            // Show live indicator
            const statusElement = document.getElementById('betSlipStatus');
            if (statusElement) {
                statusElement.style.display = 'block';
            }
            
            // Update bet slip odds every 5 seconds (increased from 0.5 seconds to reduce flickering)
            betSlipUpdateInterval = setInterval(() => {
                if (betSlip.length > 0) {
                    console.log('Updating bet slip odds...');
                    updateBetSlipOdds();
                }
            }, 5000); // Changed from 500 (0.5 seconds) to 5000 (5 seconds)
        }
        
        function stopBetSlipUpdates() {
            if (betSlipUpdateInterval) {
                clearInterval(betSlipUpdateInterval);
                betSlipUpdateInterval = null;
            }
            
            // Hide live indicator
            const statusElement = document.getElementById('betSlipStatus');
            if (statusElement) {
                statusElement.style.display = 'none';
            }
        }
        
        function updateBetSlipOdds() {
            if (betSlip.length === 0) return;
            
            console.log(`Updating odds for ${betSlip.length} bets in slip...`);
            
            // Get current live odds for all matches in bet slip
            const matchesInSlip = betSlip.map(bet => bet.matchName);
            
            // Find corresponding events with live odds
            const events = eventsData[currentSport] || [];
            
            let oddsUpdated = false;
            
            betSlip.forEach((bet, index) => {
                const matchingEvent = events.find(event => 
                    `${event.home_team} vs ${event.away_team}` === bet.matchName
                );
                
                if (matchingEvent && matchingEvent.live_odds) {
                    // Update odds based on current market
                    let newOdds = bet.odds;
                    let oddsChanged = false;
                    
                    if (currentMarket === 'match_result') {
                        if (bet.selection === matchingEvent.home_team && matchingEvent.live_odds['1x2']) {
                            newOdds = parseFloat(matchingEvent.live_odds['1x2']['1']);
                            oddsChanged = newOdds !== bet.odds;
                        } else if (bet.selection === matchingEvent.away_team && matchingEvent.live_odds['1x2']) {
                            newOdds = parseFloat(matchingEvent.live_odds['1x2']['2']);
                            oddsChanged = newOdds !== bet.odds;
                        } else if (bet.selection === 'Draw' && matchingEvent.live_odds['1x2']) {
                            newOdds = parseFloat(matchingEvent.live_odds['1x2']['x']);
                            oddsChanged = newOdds !== bet.odds;
                        }
                    }
                    
                    // Update bet if odds changed
                    if (oddsChanged) {
                        console.log(`Odds changed for ${bet.matchName} - ${bet.selection}: ${bet.odds} ‚Üí ${newOdds}`);
                        betSlip[index].odds = newOdds;
                        betSlip[index].oddsChanged = true; // Flag for visual indication
                        oddsUpdated = true;
                        
                        // Show odds change notification
                        showOddsChangeNotification(bet.matchName, bet.selection, newOdds);
                    }
                }
            });
            
            // Re-render bet slip with updated odds
            if (oddsUpdated) {
                console.log('Rendering updated bet slip...');
                renderBetSlip();
            }
        }
        
        function renderBetSlip() {
            const container = document.getElementById('betSlipContent');
            const countElement = document.getElementById('betCount');
            
            countElement.textContent = betSlip.length;
            
            if (betSlip.length === 0) {
                container.innerHTML = `
                    <p>Your bet slip is empty</p>
                    <p>Click on odds to add selections</p>
                `;
                return;
            }
            
            const totalStake = betSlip.reduce((sum, bet) => sum + bet.stake, 0);
            const totalOdds = betSlip.reduce((product, bet) => product * bet.odds, 1);
            const potentialReturn = totalStake * totalOdds;
            
            container.innerHTML = `
                ${betSlip.map((bet, index) => `
                    <div style="background: rgba(255, 255, 255, 0.05); border-radius: 8px; padding: 1rem; margin-bottom: 1rem; ${bet.oddsChanged ? 'border: 2px solid #4ade80; animation: pulse 1s;' : ''}">
                        <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 0.5rem;">
                            <div style="flex: 1;">
                                <div style="font-weight: 600; font-size: 0.9rem; margin-bottom: 0.25rem;">${bet.matchName}</div>
                                <div style="color: #4ade80; font-size: 0.8rem; margin-bottom: 0.25rem;">${bet.selection}</div>
                                <div style="font-weight: 600; ${bet.oddsChanged ? 'color: #4ade80;' : ''}">@ ${bet.odds.toFixed(2)}</div>
                            </div>
                            <button onclick="removeFromBetSlip(${index})" style="background: #ef4444; border: none; border-radius: 4px; color: white; padding: 0.25rem 0.5rem; cursor: pointer;">&times;</button>
                        </div>
                        <div style="display: flex; align-items: center; gap: 0.5rem;">
                            <label style="font-size: 0.8rem; color: rgba(255, 255, 255, 0.7);">Stake:</label>
                            <input type="number" value="${bet.stake}" onchange="updateStake(${index}, this.value)"
                                   style="background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 4px; padding: 0.25rem; color: white; width: 60px;">
                        </div>
                        <div style="margin-top: 0.5rem; font-size: 0.8rem; color: rgba(255, 255, 255, 0.7);">
                            Return: $${(bet.stake * bet.odds).toFixed(2)}
                        </div>
                    </div>
                `).join('')}
                <div style="border-top: 1px solid rgba(255, 255, 255, 0.1); padding-top: 1rem; margin-top: 1rem;">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 0.5rem;">
                        <span>Total Stake:</span>
                        <span style="font-weight: 600;">$${totalStake.toFixed(2)}</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin-bottom: 1rem;">
                        <span>Potential Return:</span>
                        <span style="font-weight: 600; color: #4ade80;">$${potentialReturn.toFixed(2)}</span>
                    </div>
                    <button onclick="placeBets()" style="width: 100%; background: linear-gradient(135deg, #4ade80, #22c55e); border: none; border-radius: 8px; color: #000; font-weight: 600; padding: 0.75rem; cursor: pointer; transition: all 0.3s ease;">
                        Place Bet
                    </button>
                </div>
            `;
            
            // Clear odds changed flag after rendering
            betSlip.forEach(bet => bet.oddsChanged = false);
        }
        
        function showOddsChangeNotification(matchName, selection, newOdds) {
            // Create a temporary notification
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #4ade80;
                color: #000;
                padding: 0.75rem 1rem;
                border-radius: 8px;
                font-weight: 600;
                z-index: 10000;
                animation: slideIn 0.3s ease;
                max-width: 300px;
            `;
            notification.innerHTML = `
                <div style="font-size: 0.9rem;">üìà Odds Updated</div>
                <div style="font-size: 0.8rem; margin-top: 0.25rem;">${matchName} - ${selection}</div>
                <div style="font-size: 0.8rem;">New odds: ${newOdds.toFixed(2)}</div>
            `;
            
            document.body.appendChild(notification);
            
            // Remove notification after 3 seconds
            setTimeout(() => {
                notification.style.animation = 'slideOut 0.3s ease';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, 3000);
        }

        async function placeBets() {
            if (betSlip.length === 0) return;

            try {
                if (betMode === 'combo') {
                    // Place combo bet as a single bet with combined odds
                    const totalOdds = betSlip.reduce((product, bet) => product * bet.odds, 1);
                    const totalStake = comboTotalStake;
                    
                    if (totalStake <= 0) {
                        showWarningAlert('Invalid Stake', 'Please enter a valid stake amount for your combo bet.', 3000);
                        return;
                    }
                    
                    // Create combo bet data
                    const comboBetData = {
                        bet_type: 'combo',
                        selections: betSlip.map(bet => ({
                            match_id: bet.matchId || bet.eventId,
                            match_name: bet.matchName,
                            match_time: bet.matchTime,
                            selection: bet.selection,
                            odds: parseFloat(bet.odds.toFixed(2)),
                            sport_name: bet.sport || currentSport,  // Include sport from event data
                            bet_timing: bet.bet_timing || 'pregame'  // Include bet timing from event data
                        })),
                        total_odds: parseFloat(totalOdds.toFixed(2)),
                        total_stake: totalStake
                    };
                    
                    const response = await fetch(`${API_BASE}/api/betting/place-combo`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(comboBetData)
                    });
                    
                    const data = await response.json();
                    
                    if (!response.ok) {
                        alert(data.message || 'Failed to place combo bet');
                        return;
                    }
                    
                    showSuccessAlert('Bet Placed! üéâ', 'Your combo bet has been placed successfully!', 4000);
                    
                    // Update balance from response
                    if (data.new_balance !== undefined) {
                        document.getElementById('userBalance').textContent = `$${data.new_balance.toFixed(2)}`;
                    }
                } else {
                    // Place each bet individually
                    for (const bet of betSlip) {
                        const response = await fetch(`${API_BASE}/api/betting/place`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                match_id: bet.matchId || bet.eventId,
                                match_name: bet.matchName,
                                match_time: bet.matchTime,
                                selection: bet.selection,
                                odds: parseFloat(bet.odds.toFixed(2)),
                                stake: bet.stake,
                                sport_name: bet.sport || currentSport,  // Include sport from event data
                                bet_timing: bet.bet_timing || 'pregame',  // Include bet timing from event data
                                market_id: bet.marketId || 'unknown'  // Include market ID for admin liability calculation
                            })
                        });
                        
                        const data = await response.json();
                        
                        if (!response.ok) {
                            alert(data.message || 'Failed to place bet');
                            return;
                        }
                        
                        // Update balance from response
                        if (data.new_balance !== undefined) {
                            document.getElementById('userBalance').textContent = `$${data.new_balance.toFixed(2)}`;
                        }
                    }
                    
                    showSuccessAlert('Bets Placed! üéâ', 'All your bets have been placed successfully!', 4000);
                }
                
                betSlip = [];
                comboTotalStake = 0; // Reset combo stake
                stopBetSlipUpdates();
                updateBetSlip();
                
            } catch (error) {
                console.error('Error placing bets:', error);
                alert('Error placing bets. Please try again.');
            }
        }

        // User menu functions
        function toggleUserMenu() {
            const dropdown = document.getElementById('userDropdown');
            if (dropdown.style.display === 'none') {
                dropdown.style.display = 'block';
                // Close dropdown when clicking outside
                setTimeout(() => {
                    document.addEventListener('click', closeUserMenu);
                }, 0);
            } else {
                dropdown.style.display = 'none';
            }
        }

        function closeUserMenu(event) {
            const userMenu = document.getElementById('userMenu');
            const dropdown = document.getElementById('userDropdown');
            if (!userMenu.contains(event.target) && !dropdown.contains(event.target)) {
                dropdown.style.display = 'none';
                document.removeEventListener('click', closeUserMenu);
            }
        }

        function logout() {
            localStorage.removeItem('token');
            localStorage.removeItem('user');
            window.location.reload();
        }

        // Page navigation functions
        async function showBetHistory() {
            try {
                const response = await fetch(`${API_BASE}/api/betting/bets`, {
                    credentials: 'include' // Include cookies for session
                });
                
                if (response.ok) {
                const data = await response.json();
                    displayBetHistory(data.bets);
                } else {
                    alert('Failed to load bet history');
                }
            } catch (error) {
                console.error('Error loading bet history:', error);
                alert('Error loading bet history');
            }
        }

        function displayBetHistory(bets) {
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.8);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 10000;
            `;

            const modalContent = document.createElement('div');
            modalContent.style.cssText = `
                background: #1a1a2e;
                border-radius: 12px;
                padding: 2rem;
                max-width: 90%;
                max-height: 80%;
                overflow-y: auto;
                border: 1px solid rgba(255, 255, 255, 0.1);
            `;

            const header = document.createElement('div');
            header.style.cssText = `
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 1.5rem;
                border-bottom: 1px solid rgba(255, 255, 255, 0.1);
                padding-bottom: 1rem;
            `;
            header.innerHTML = `
                <h2 style="color: #ffffff; margin: 0;">Bet History</h2>
                <button onclick="this.closest('.modal').remove()" style="background: #ef4444; border: none; border-radius: 4px; color: white; padding: 0.5rem 1rem; cursor: pointer;">&times;</button>
            `;

            modalContent.appendChild(header);

            if (bets.length === 0) {
                const noBets = document.createElement('div');
                noBets.style.cssText = `
                    text-align: center;
                    color: rgba(255, 255, 255, 0.7);
                    padding: 2rem;
                `;
                noBets.innerHTML = `
                    <div style="font-size: 3rem; margin-bottom: 1rem;">üìä</div>
                    <h3>No bets found</h3>
                    <p>You haven't placed any bets yet.</p>
                `;
                modalContent.appendChild(noBets);
            } else {
                const table = document.createElement('table');
                table.style.cssText = `
                    width: 100%;
                    border-collapse: collapse;
                    color: #ffffff;
                `;

                const thead = document.createElement('thead');
                thead.innerHTML = `
                    <tr style="border-bottom: 1px solid rgba(255, 255, 255, 0.1);">
                        <th style="padding: 0.75rem; text-align: left; font-weight: 600;">Date & Time</th>
                        <th style="padding: 0.75rem; text-align: left; font-weight: 600;">Match</th>
                        <th style="padding: 0.75rem; text-align: left; font-weight: 600;">Bet Selection</th>
                        <th style="padding: 0.75rem; text-align: center; font-weight: 600;">Odds</th>
                        <th style="padding: 0.75rem; text-align: center; font-weight: 600;">Stake</th>
                        <th style="padding: 0.75rem; text-align: center; font-weight: 600;">Potential Return</th>
                        <th style="padding: 0.75rem; text-align: center; font-weight: 600;">Status</th>
                    </tr>
                `;
                table.appendChild(thead);

                const tbody = document.createElement('tbody');
                bets.forEach(bet => {
                    const row = document.createElement('tr');
                    row.style.cssText = `
                        border-bottom: 1px solid rgba(255, 255, 255, 0.05);
                        transition: background-color 0.2s;
                    `;
                    row.onmouseover = () => row.style.backgroundColor = 'rgba(255, 255, 255, 0.05)';
                    row.onmouseout = () => row.style.backgroundColor = 'transparent';

                    const statusColor = {
                        'pending': '#f59e0b',
                        'won': '#10b981',
                        'lost': '#ef4444',
                        'void': '#6b7280',
                        'cashed_out': '#8b5cf6'
                    };

                    const statusText = {
                        'pending': 'Pending',
                        'won': 'Won',
                        'lost': 'Lost',
                        'void': 'Void',
                        'cashed_out': 'Cashed Out'
                    };

                    // Convert UTC time to local time
                    let localTime = 'N/A';
                    if (bet.created_at) {
                        const date = new Date(bet.created_at);
                        localTime = date.toLocaleString('en-US', {
                            month: 'short',
                            day: 'numeric',
                            hour: '2-digit',
                            minute: '2-digit',
                            hour12: true,
                            timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone
                        });
                    }

                    // Get proper match name (prefer match_name over match_id)
                    const matchName = bet.match_name || bet.match_id || 'N/A';

                    row.innerHTML = `
                        <td style="padding: 0.75rem; font-size: 0.9rem;">${localTime}</td>
                        <td style="padding: 0.75rem; font-weight: 500;">${matchName}</td>
                        <td style="padding: 0.75rem; color: #4ade80;">${bet.selection || 'N/A'}</td>
                        <td style="padding: 0.75rem; text-align: center;">${bet.odds || 'N/A'}</td>
                        <td style="padding: 0.75rem; text-align: center;">$${bet.stake?.toFixed(2) || 'N/A'}</td>
                        <td style="padding: 0.75rem; text-align: center;">$${bet.potential_return?.toFixed(2) || 'N/A'}</td>
                        <td style="padding: 0.75rem; text-align: center;">
                            <span style="
                                background: ${statusColor[bet.status] || '#6b7280'};
                                color: white;
                                padding: 0.25rem 0.5rem;
                                border-radius: 4px;
                                font-size: 0.8rem;
                                font-weight: 500;
                            ">${statusText[bet.status] || bet.status}</span>
                        </td>
                    `;
                    tbody.appendChild(row);
                });
                table.appendChild(tbody);
                modalContent.appendChild(table);
            }

            modal.appendChild(modalContent);
            document.body.appendChild(modal);

            // Close modal when clicking outside
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            });
        }

        function showAdminPanel() {
            // Implementation for admin panel
            alert('Admin Panel feature coming soon!');
        }

        function loadLiveOdds(liveEvents) {
            if (liveEvents.length === 0) return;
            
            fetch(`${API_BASE}/api/sports/${currentSport}/odds`)
                .then(response => response.json())
                .then(liveOddsData => {
                    console.log('Live odds data:', liveOddsData);
                    displayLiveOdds(liveOddsData);
                    
                    // Auto-refresh live odds every 30 seconds
                    setTimeout(() => {
                        if (liveEvents.length > 0) {
                            loadLiveOdds(liveEvents);
                        }
                    }, 30000);
                })
                .catch(error => {
                    console.error('Error loading live odds:', error);
                });
        }

        function displayLiveOdds(liveOddsData) {
            const container = document.getElementById('liveOddsContainer');
            if (!container) return;
            
            if (liveOddsData.length === 0) {
                container.innerHTML = '<div class="no-live-odds">No live odds available</div>';
                return;
            }
            
            container.innerHTML = `
                <div class="live-odds-header">
                    <h3>üî¥ LIVE ODDS</h3>
                    <div class="live-odds-timer">Updated: ${new Date().toLocaleTimeString()}</div>
                </div>
                <div class="live-odds-grid">
                    ${liveOddsData.map(match => `
                        <div class="live-odds-card">
                            <div class="match-header">
                                <div class="match-teams">
                                    <span class="home-team">${match.home_team}</span>
                                    <span class="vs">vs</span>
                                    <span class="away-team">${match.away_team}</span>
                                </div>
                                <div class="live-score">
                                    ${match.home_score} - ${match.away_score}
                                </div>
                                <div class="match-status">
                                    ${match.status} ${match.time_remaining ? `(${match.time_remaining}' remaining)` : ''}
                                </div>
                            </div>
                            <div class="odds-markets">
                                <div class="market-section">
                                    <h4>Match Result</h4>
                                    <div class="odds-row">
                                        <span class="selection">1</span>
                                        <span class="odds">${match.live_odds['1x2']['1']}</span>
                                        <span class="selection">X</span>
                                        <span class="odds">${match.live_odds['1x2']['x']}</span>
                                        <span class="selection">2</span>
                                        <span class="odds">${match.live_odds['1x2']['2']}</span>
                                    </div>
                                </div>
                                <div class="market-section">
                                    <h4>Total Goals</h4>
                                    <div class="odds-row">
                                        <span class="selection">Over 2.5</span>
                                        <span class="odds">${match.live_odds['total_goals']['over_2_5']}</span>
                                        <span class="selection">Under 2.5</span>
                                        <span class="odds">${match.live_odds['total_goals']['under_2_5']}</span>
                                    </div>
                                </div>
                                <div class="market-section">
                                    <h4>Next Goal</h4>
                                    <div class="odds-row">
                                        <span class="selection">${match.home_team}</span>
                                        <span class="odds">${match.live_odds['next_goal']['home']}</span>
                                        <span class="selection">${match.away_team}</span>
                                        <span class="odds">${match.live_odds['next_goal']['away']}</span>
                                    </div>
                                </div>
                                <div class="market-section">
                                    <h4>Both Teams Score</h4>
                                    <div class="odds-row">
                                        <span class="selection">Yes</span>
                                        <span class="odds">${match.live_odds['both_teams_score']['yes']}</span>
                                        <span class="selection">No</span>
                                        <span class="odds">${match.live_odds['both_teams_score']['no']}</span>
                                    </div>
                                </div>
                            </div>
                            <div class="match-progress">
                                <div class="progress-bar">
                                    <div class="progress-fill" style="width: ${match.live_odds.match_progress * 100}%"></div>
                                </div>
                                <span class="progress-text">${Math.round(match.live_odds.match_progress * 100)}% Complete</span>
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        // WebSocket functions
        function initWebSocket() {
            try {
                socket = io();
                
                socket.on('connect', function() {
                    console.log('WebSocket connected');
                    websocketConnected = true;
                    updateWebSocketStatus(true);
                    
                    // Subscribe to live odds updates
                    socket.emit('subscribe_live_odds', { sport: currentSport });
                    
                    // Start auto-refresh as backup
                    startAutoRefresh();
                });
                
                socket.on('disconnect', function() {
                    console.log('WebSocket disconnected');
                    websocketConnected = false;
                    updateWebSocketStatus(false);
                    
                    // Start auto-refresh when WebSocket disconnects
                    startAutoRefresh();
                });
                
                socket.on('live_odds_update', function(data) {
                    console.log('Received live odds update:', data);
                    handleLiveOddsUpdate(data);
                });
                
                socket.on('match_odds_update', function(data) {
                    console.log('Received specific match update:', data);
                    handleSpecificMatchUpdate(data);
                });
                
                socket.on('connection_status', function(data) {
                    console.log('Connection status:', data);
                });
                
                socket.on('subscription_confirmed', function(data) {
                    console.log('Subscription confirmed:', data);
                });
                
                socket.on('error', function(data) {
                    console.error('WebSocket error:', data);
                });
                
                socket.on('live_odds_response', function(data) {
                    console.log('Received immediate live odds response:', data);
                    handleLiveOddsUpdate(data);
                });
                
            } catch (error) {
                console.error('Failed to initialize WebSocket:', error);
            }
        }
        
        function handleLiveOddsUpdate(data) {
            if (data.sport === currentSport && data.odds) {
                // Update events data with new live odds
                data.odds.forEach(liveOdd => {
                    const matchingEvent = eventsData[currentSport]?.find(event => 
                        event.home_team === liveOdd.home_team && 
                        event.away_team === liveOdd.away_team
                    );
                    if (matchingEvent) {
                        matchingEvent.live_odds = liveOdd.live_odds;
                        console.log(`Updated live odds for ${liveOdd.home_team} vs ${liveOdd.away_team}`);
                    }
                });
                
                // Refresh the display
                displayEvents();
                
                // Update bet slip if there are bets
                if (betSlip.length > 0) {
                    updateBetSlipOdds();
                }
            }
        }
        
        function handleSpecificMatchUpdate(data) {
            // Handle updates for specific matches
            const matchingEvent = eventsData[currentSport]?.find(event => 
                event.match_id === data.match_id
            );
            if (matchingEvent) {
                matchingEvent.live_odds = data.odds;
                displayEvents();
            }
        }
        
        function requestImmediateLiveOdds() {
            console.log('Requesting immediate live odds...');
            
            // Show loading state
            const refreshBtn = document.querySelector('.refresh-btn');
            const originalText = refreshBtn.textContent;
            refreshBtn.textContent = '‚è≥ Loading...';
            refreshBtn.disabled = true;
            
            if (socket && websocketConnected) {
                socket.emit('request_live_odds', { sport: currentSport });
            } else {
                console.log('WebSocket not connected, trying direct API call...');
                // Fallback to direct API call
                fetch(`${API_BASE}/api/sports/events/${currentSport}`)
                    .then(response => response.json())
                    .then(data => {
                        console.log('Direct API response:', data);
                        handleLiveOddsUpdate({ sport: currentSport, odds: data });
                    })
                    .catch(error => {
                        console.error('Error fetching live odds:', error);
                    });
            }
            
            // Reset button after 2 seconds
            setTimeout(() => {
                refreshBtn.textContent = originalText;
                refreshBtn.disabled = false;
            }, 2000);
        }
        
        function forceRefreshLiveOdds() {
            console.log('Force refreshing from JSON data...');
            
            // Reload events from JSON data
            loadEvents(currentSport)
                .then(() => {
                    console.log('Events reloaded from JSON successfully');
                    // Also trigger bet slip update
                    if (betSlip.length > 0) {
                        updateBetSlipOdds();
                    }
                })
                .catch(error => {
                    console.error('Error force refreshing from JSON:', error);
                });
        }
        

        
        function updateWebSocketStatus(connected) {
            const statusElement = document.getElementById('websocketStatus');
            if (statusElement) {
                if (connected) {
                    statusElement.textContent = 'üü¢ Connected';
                    statusElement.className = 'status-indicator connected';
                } else {
                    statusElement.textContent = 'üî¥ Disconnected';
                    statusElement.className = 'status-indicator disconnected';
                }
            }
        }
        
        function startAutoRefresh() {
            // Clear existing interval
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
            }
            
            // Auto-refresh from JSON data every 30 seconds (increased from 5 seconds to reduce flickering)
            autoRefreshInterval = setInterval(() => {
                console.log('Auto-refreshing from JSON data...');
                // Only refresh events data without changing sport selection
                const currentSportBeforeRefresh = currentSport;
                loadEvents(currentSport).then(() => {
                    console.log('Events refreshed from JSON successfully');
                    // Ensure sport selection didn't change
                    if (currentSport !== currentSportBeforeRefresh) {
                        currentSport = currentSportBeforeRefresh;
                        console.log('Restored sport selection to:', currentSport);
                    }
                    // Update markets for the current sport
                    updateBettingMarkets();
                    // Update bet slip if there are bets
                    if (betSlip.length > 0) {
                        updateBetSlipOdds();
                    }
                }).catch(error => {
                        console.error('Auto-refresh error:', error);
                    });
            }, 30000); // Changed from 5000 (5 seconds) to 30000 (30 seconds)
            

        }
        

        
        function stopAutoRefresh() {
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
                autoRefreshInterval = null;
            }
        }
        
        // Search functionality
        
        function handleSearch(query) {
            // Clear previous timeout
            if (searchTimeout) {
                clearTimeout(searchTimeout);
            }
            
            // Debounce search to avoid too many calls
            searchTimeout = setTimeout(() => {
                performSearch(query);
            }, 300);
        }
        
        function showSearchSuggestions(searchTerm, allEvents) {
            // Get unique teams and leagues for suggestions
            const teams = new Set();
            const leagues = new Set();
            
            allEvents.forEach(event => {
                if (event.home_team) teams.add(event.home_team);
                if (event.away_team) teams.add(event.away_team);
                if (event.league) leagues.add(event.league);
            });
            
            // Find similar terms
            const similarTeams = Array.from(teams).filter(team => 
                team.toLowerCase().includes(searchTerm.substring(0, 3))
            ).slice(0, 3);
            
            const similarLeagues = Array.from(leagues).filter(league => 
                league.toLowerCase().includes(searchTerm.substring(0, 3))
            ).slice(0, 2);
            
            if (similarTeams.length > 0 || similarLeagues.length > 0) {
                const container = document.getElementById('eventsContent');
                container.innerHTML = `
                    <div class="loading-text">
                        <div style="margin-bottom: 1rem;">üîç</div>
                        <div>No events found for "${searchTerm}"</div>
                        <div style="font-size: 0.9rem; color: rgba(255, 255, 255, 0.6); margin-top: 0.5rem;">
                            Try searching for different teams, leagues, or venues
                        </div>
                        ${similarTeams.length > 0 ? `
                            <div style="margin-top: 1rem; padding: 1rem; background: rgba(255, 255, 255, 0.05); border-radius: 8px;">
                                <div style="font-weight: 600; margin-bottom: 0.5rem;">Similar teams:</div>
                                <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                                    ${similarTeams.map(team => `
                                        <span style="background: #4ade80; color: #000; padding: 0.25rem 0.5rem; border-radius: 4px; cursor: pointer; font-size: 0.8rem;" onclick="searchFor('${team}')">${team}</span>
                                    `).join('')}
                                </div>
                            </div>
                        ` : ''}
                        ${similarLeagues.length > 0 ? `
                            <div style="margin-top: 0.5rem; padding: 1rem; background: rgba(255, 255, 255, 0.05); border-radius: 8px;">
                                <div style="font-weight: 600; margin-bottom: 0.5rem;">Similar leagues:</div>
                                <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                                    ${similarLeagues.map(league => `
                                        <span style="background: #4ade80; color: #000; padding: 0.25rem 0.5rem; border-radius: 4px; cursor: pointer; font-size: 0.8rem;" onclick="searchFor('${league}')">${league}</span>
                                    `).join('')}
                                </div>
                            </div>
                        ` : ''}
                    </div>
                `;
            }
        }
        
        function searchFor(term) {
            const searchInput = document.querySelector('.search-input');
            searchInput.value = term;
            performSearch(term);
        }
        
        function displaySearchResults(events, searchTerm) {
            const container = document.getElementById('eventsContent');
            
            if (events.length === 0) {
                container.innerHTML = `
                    <div class="loading-text">
                        <div style="margin-bottom: 1rem;">üîç</div>
                        <div>No events found for "${searchTerm}"</div>
                        <div style="font-size: 0.9rem; color: rgba(255, 255, 255, 0.6); margin-top: 0.5rem;">
                            Try searching for different teams, leagues, or venues
                        </div>
                    </div>
                `;
                return;
            }
            
            // Sort events (live first, then by relevance)
            const sortedEvents = events.sort((a, b) => {
                // Live matches come first
                if (a.is_live && !b.is_live) return -1;
                if (!a.is_live && b.is_live) return 1;
                
                // Then sort by date and time
                const dateA = new Date(a.date + ' ' + new Date().getFullYear() + ' ' + a.time);
                const dateB = new Date(b.date + ' ' + new Date().getFullYear() + ' ' + b.time);
                return dateA - dateB;
            });
            
            // Display with search highlighting
            if (currentView === 'list') {
                displayListViewWithHighlight(sortedEvents, container, searchTerm);
            } else {
                displayCouponViewWithHighlight(sortedEvents, container, searchTerm);
            }
        }
        
        function displayListViewWithHighlight(events, container, searchTerm) {
            const getOddsColumns = () => {
                // Special handling for baseball - only show configured markets
                if (currentSport === 'baseball') {
                    switch (currentMarket) {
                        case 'match_result':
                            return getSportSpecificHeaders();
                        case 'correct_score':
                            return '<div>1-0</div><div>2-1</div><div>2-0</div>';
                        case 'odd_even_including_ot':
                            return '<div>Yes</div><div>No</div>';
                        default:
                            return ''; // Hide invalid markets for baseball
                    }
                }
                
                // Special handling for cricket - 1-2 market (no draw)
                if (currentSport === 'cricket' && currentMarket === 'match_result') {
                    return '<div>1</div><div>2</div>';
                }
                
                // For other sports, use existing logic
                switch (currentMarket) {
                    case 'match_result':
                        return getSportSpecificHeaders();
                    case 'both_teams_score':
                    case 'clean_sheet_home':
                    case 'clean_sheet_away':
                    case 'win_to_nil_home':
                    case 'win_to_nil_away':
                    case 'team_to_score_first':
                    case 'home_team_score_goal':
                    case 'away_team_score_goal':
                    case 'odd_even':
                    case 'odd_even_first_half':
                    case 'odd_even_first_set':
                    case 'odd_even_including_ot':
                    case 'to_qualify':
                    case 'tie_break_first_set':
                    case 'win_one_set_player1':
                    case 'win_one_set_player2':
                        return '<div>Yes</div><div>No</div>';
                    case 'correct_score':
                    case 'correct_score_first_half':
                    case 'correct_score_second_half':
                        return '<div>1-0</div><div>2-1</div><div>2-0</div>';
                    case 'asian_handicap':
                    case 'asian_handicap_first_half':
                    case 'asian_handicap_first_quarter':
                    case 'asian_handicap_sets':
                    case 'asian_handicap_games':
                    case 'first_set':
                    case 'second_set':
                    case 'first_half_winner':
                    case 'first_quarter_winner':
                    case 'second_half_winner':
                        return '<div>Home</div><div>Away</div>';
                    case 'over_under':
                    case 'over_under_first_half':
                    case 'over_under_first_quarter':
                    case 'over_under_first_set':
                    case 'games_over_under':
                    case 'corners_over_under':
                        return '<div>Over</div><div>Under</div>';
                    case 'set_betting':
                        return '<div>2-0</div><div>2-1</div><div>0-2</div>';
                    case 'handicap_result':
                        return '<div>Home</div><div>Draw</div><div>Away</div>';
                    case 'highest_scoring_half':
                    case 'highest_scoring_quarter':
                        return '<div>1st</div><div>2nd</div><div>3rd</div>';
                    case 'double_chance':
                    case 'double_chance_first_half':
                    case 'double_chance_second_half':
                        return '<div>1X</div><div>X2</div><div>12</div>';
                    case 'win_both_halves':
                        return '<div>Yes</div><div>No</div>';
                    case 'both_teams_score_first_half':
                    case 'both_teams_score_second_half':
                        return '<div>Yes</div><div>No</div>';
                    case 'results_both_teams_score':
                        return '<div>1/Yes</div><div>X/Yes</div><div>2/Yes</div>';
                    case 'result_total_goals':
                        return '<div>1/Over</div><div>X/Over</div><div>2/Over</div>';
                    case 'corners_1x2':
                        return '<div>Home</div><div>Draw</div><div>Away</div>';
                    case 'ht_ft_double':
                        return '<div>1/1</div><div>1/X</div><div>1/2</div>';
                    case 'first_half_3way_result':
                        return '<div>1</div><div>X</div><div>2</div>';
                    default:
                        return getSportSpecificHeaders();
                }
            };
            
            container.innerHTML = `
                <div class="table-header" style="grid-template-columns: ${getSportSpecificGridTemplate()};">
                    <div>Date & Time</div>
                    <div>Event</div>
                    ${getOddsColumns()}
                </div>
                ${events.map(event => `
                    <div class="event-row ${event.is_live ? 'live-match' : ''}" style="grid-template-columns: ${getSportSpecificGridTemplate()};">
                        <div class="event-time">
                            ${formatEventTime(event)}
                            ${event.is_live ? '<span class="live-indicator">üî¥ LIVE</span>' : ''}
                            <div class="match-status">
                                ${formatMatchStatus(event.status)}
                            </div>
                        </div>
                        <div class="event-info">
                            <div class="event-teams">
                                ${highlightSearchTerm(`${event.home_team} vs ${event.away_team}`, searchTerm)}
                                ${event.is_live ? `<span class="live-score">${event.home_score} - ${event.away_score}</span>` : ''}
                            </div>
                            <div class="event-league">${highlightSearchTerm(event.league || 'Unknown League', searchTerm)}</div>
                        </div>
                        ${generateOddsButtons(event, currentMarket)}
                    </div>
                `).join('')}
            `;
        }
        
        function displayCouponViewWithHighlight(events, container, searchTerm) {
            container.innerHTML = `
                <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 1rem; padding: 1rem;">
                    ${events.map(event => `
                        <div style="background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 12px; padding: 1rem; transition: all 0.3s ease;">
                            <div style="text-align: center; margin-bottom: 1rem;">
                                <div style="font-size: 0.9rem; color: #fbbf24; margin-bottom: 0.5rem;">${formatEventTime(event)}</div>
                                <div style="font-weight: 600; margin-bottom: 0.25rem;">${highlightSearchTerm(`${event.home_team} VS ${event.away_team}`, searchTerm)}</div>
                                <div style="font-size: 0.8rem; color: rgba(255, 255, 255, 0.6);">${highlightSearchTerm(event.league || 'Unknown League', searchTerm)}</div>
                            </div>
                            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.5rem;">
                                ${generateOddsButtons(event, currentMarket)}
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
        }
        
        function highlightSearchTerm(text, searchTerm) {
            if (!searchTerm || !text) return text;
            
            const regex = new RegExp(`(${searchTerm})`, 'gi');
            return text.replace(regex, '<mark style="background: #4ade80; color: #000; padding: 0.1rem 0.2rem; border-radius: 3px;">$1</mark>');
        }
        
        function toggleClearButton(input) {
            const clearButton = input.parentElement.querySelector('.search-clear');
            if (input.value.length > 0) {
                clearButton.classList.add('visible');
            } else {
                clearButton.classList.remove('visible');
            }
        }
        
        function clearSearch() {
            const searchInput = document.querySelector('.search-input');
            searchInput.value = '';
            currentSearchTerm = '';
            document.querySelector('.search-clear').classList.remove('visible');
            displayEvents(); // Show all events
        }
        
        function restoreSearchState() {
            const searchInput = document.querySelector('.search-input');
            if (currentSearchTerm && currentSearchTerm.trim() !== '') {
                searchInput.value = currentSearchTerm;
                document.querySelector('.search-clear').classList.add('visible');
            }
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            // Handle Google OAuth redirect: token may be provided in URL hash
            if (window.location.hash && window.location.hash.startsWith('#token=')) {
                const tokenFromHash = decodeURIComponent(window.location.hash.substring('#token='.length + 0));
                if (tokenFromHash) {
                    localStorage.setItem('token', tokenFromHash);
                    // Clean hash from URL without reloading
                    history.replaceState(null, document.title, window.location.pathname + window.location.search);
                }
            }
            // Fallback: if server set a cookie with token, migrate it into localStorage and clear the cookie
            try {
                const cookies = document.cookie ? document.cookie.split(';').map(s => s.trim()) : [];
                const cookiePair = cookies.find(c => c.startsWith('app_token='));
                if (cookiePair) {
                    const tokenFromCookie = decodeURIComponent(cookiePair.split('=')[1] || '');
                    if (tokenFromCookie) {
                        localStorage.setItem('token', tokenFromCookie);
                        // Clear the cookie
                        document.cookie = 'app_token=; Max-Age=0; path=/; samesite=Lax';
                    }
                }
            } catch (e) { /* ignore */ }
            
            // Authentication is now handled by the bootstrapAuth function above
            console.log('üîí Authentication handled by bootstrapAuth function');
            
            // Set a flag to indicate that auth is being handled
            window.AUTH_BEING_HANDLED = true;
        }

        // Update the search input event listener to use debounced search
        document.addEventListener('DOMContentLoaded', function() {
            const searchInput = document.getElementById('searchInput');
            if (searchInput) {
                searchInput.addEventListener('input', function(e) {
                    const searchTerm = e.target.value;
                    debouncedSearch(searchTerm);
                });
            }
        });}
        });

        // Performance optimization: Clear time cache when switching sports
        function clearTimeCache() {
            timeFormatCache.clear();
        }

        // Update selectSport to use cached data
        function selectSport(sport) {
            console.log(`üéØ Selecting sport: ${sport}`);
            currentSport = sport;
            console.log(`Current sport set to: ${currentSport}`);
            document.getElementById('currentSport').textContent = sport.charAt(0).toUpperCase() + sport.slice(1);
            
            // Clear time cache for new sport
            clearTimeCache();
            
            // Update sports display to show active state
            updateSportsActiveState(sport);
            
            // Update betting markets for the new sport
            updateBettingMarkets();
            
            // Load events for the selected sport (now from cache - instant!)
            loadEvents(sport);
        }
        
        // Loading indicator functions
        function showLoadingIndicator() {
            const indicator = document.getElementById('loadingIndicator');
            if (indicator) {
                indicator.style.display = 'flex';
            }
        }
        
        function hideLoadingIndicator() {
            const indicator = document.getElementById('loadingIndicator');
            if (indicator) {
                indicator.style.display = 'none';
            }
        }

        // Add missing functions that are referenced but not defined
        function updateSportsActiveState(activeSport) {
            // Update sports display to show active state
            document.querySelectorAll('.sport-item').forEach(item => {
                if (item.dataset.sport === activeSport) {
                    item.classList.add('active');
                } else {
                    item.classList.remove('active');
                }
            });
        }

        function getAvailableMarketsForSport(sport) {
            // Define available markets for each sport
            const sportMarkets = {
                'soccer': ['match_result', 'both_teams_score', 'correct_score', 'over_under'],
                'basketball': ['match_result', 'over_under', 'asian_handicap'],
                'tennis': ['match_result', 'set_betting', 'games_over_under'],
                'baseball': ['match_result', 'correct_score', 'over_under'],
                'hockey': ['match_result', 'both_teams_score', 'over_under'],
                'volleyball': ['match_result', 'set_betting', 'over_under'],
                'rugby': ['match_result', 'handicap_result', 'over_under'],
                'cricket': ['match_result', 'correct_score', 'over_under'],
                'mma': ['match_result', 'method_of_victory', 'round_betting'],
                'boxing': ['match_result', 'method_of_victory', 'round_betting'],
                'golf': ['match_result', 'top_finisher', 'head_to_head'],
                'darts': ['match_result', 'correct_score', 'over_under'],
                'esports': ['match_result', 'correct_score', 'over_under'],
                'table_tennis': ['match_result', 'set_betting', 'games_over_under'],
                'handball': ['match_result', 'both_teams_score', 'over_under'],
                'futsal': ['match_result', 'correct_score', 'over_under'],
                'rugbyleague': ['match_result', 'handicap_result', 'over_under']
            };
            
            return sportMarkets[sport] || ['match_result'];
        }

        function formatMarketName(market) {
            const marketNames = {
                'match_result': 'Match Result',
                'both_teams_score': 'Both Teams Score',
                'correct_score': 'Correct Score',
                'over_under': 'Over/Under',
                'asian_handicap': 'Asian Handicap',
                'set_betting': 'Set Betting',
                'games_over_under': 'Games Over/Under',
                'handicap_result': 'Handicap Result',
                'method_of_victory': 'Method of Victory',
                'round_betting': 'Round Betting',
                'top_finisher': 'Top Finisher',
                'head_to_head': 'Head to Head'
            };
            
            return marketNames[market] || market.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
        }



        function getSportSpecificHeaders() {
            // Return appropriate headers based on current sport and market
            if (currentSport === 'cricket' && currentMarket === 'match_result') {
                return '<div>1</div><div>2</div>'; // No draw in cricket
            }
            
            switch (currentMarket) {
                case 'match_result':
                    return '<div>1</div><div>X</div><div>2</div>';
                case 'both_teams_score':
                case 'clean_sheet_home':
                case 'clean_sheet_away':
                case 'win_to_nil_home':
                case 'win_to_nil_away':
                case 'team_to_score_first':
                case 'home_team_score_goal':
                case 'away_team_score_goal':
                case 'odd_even':
                case 'odd_even_first_half':
                case 'odd_even_first_set':
                case 'odd_even_including_ot':
                case 'to_qualify':
                case 'tie_break_first_set':
                case 'win_one_set_player1':
                case 'win_one_set_player2':
                    return '<div>Yes</div><div>No</div>';
                case 'correct_score':
                case 'correct_score_first_half':
                case 'correct_score_second_half':
                    return '<div>1-0</div><div>2-1</div><div>2-0</div>';
                case 'asian_handicap':
                case 'asian_handicap_first_half':
                case 'asian_handicap_first_quarter':
                case 'asian_handicap_sets':
                case 'asian_handicap_games':
                case 'first_set':
                case 'second_set':
                case 'first_half_winner':
                case 'first_quarter_winner':
                case 'second_half_winner':
                    return '<div>Home</div><div>Away</div>';
                case 'over_under':
                case 'over_under_first_half':
                case 'over_under_first_quarter':
                case 'over_under_first_set':
                case 'games_over_under':
                case 'corners_over_under':
                    return '<div>Over</div><div>Under</div>';
                case 'set_betting':
                    return '<div>2-0</div><div>2-1</div><div>0-2</div>';
                case 'handicap_result':
                    return '<div>Home</div><div>Draw</div><div>Away</div>';
                case 'highest_scoring_half':
                case 'highest_scoring_quarter':
                    return '<div>1st</div><div>2nd</div><div>3rd</div>';
                case 'double_chance':
                case 'double_chance_first_half':
                case 'double_chance_second_half':
                    return '<div>1X</div><div>X2</div><div>12</div>';
                case 'win_both_halves':
                    return '<div>Yes</div><div>No</div>';
                case 'both_teams_score_first_half':
                case 'both_teams_score_second_half':
                    return '<div>Yes</div><div>No</div>';
                case 'results_both_teams_score':
                    return '<div>1/Yes</div><div>X/Yes</div><div>2/Yes</div>';
                case 'result_total_goals':
                    return '<div>1/Over</div><div>X/Over</div><div>2/Over</div>';
                case 'corners_1x2':
                    return '<div>Home</div><div>Draw</div><div>Away</div>';
                case 'ht_ft_double':
                    return '<div>1/1</div><div>1/X</div><div>1/2</div>';
                case 'first_half_3way_result':
                    return '<div>1</div><div>X</div><div>2</div>';
                default:
                    return '<div>1</div><div>X</div><div>2</div>';
            }
        }

        function getSportSpecificGridTemplate() {
            // Return appropriate grid template based on current sport and market
            const baseColumns = 'auto 1fr';
            const marketColumns = getMarketColumns();
            return `${baseColumns} ${marketColumns}`;
        }

        function getMarketColumns() {
            // Return appropriate columns based on current market
            switch (currentMarket) {
                case 'match_result':
                    if (currentSport === 'cricket') {
                        return 'auto auto'; // 1, 2 (no draw)
                    }
                    return 'auto auto auto'; // 1, X, 2
                case 'both_teams_score':
                case 'clean_sheet_home':
                case 'clean_sheet_away':
                case 'win_to_nil_home':
                case 'win_to_nil_away':
                case 'team_to_score_first':
                case 'home_team_score_goal':
                case 'away_team_score_goal':
                case 'odd_even':
                case 'odd_even_first_half':
                case 'odd_even_first_set':
                case 'odd_even_including_ot':
                case 'to_qualify':
                case 'tie_break_first_set':
                case 'win_one_set_player1':
                case 'win_one_set_player2':
                    return 'auto auto'; // Yes, No
                case 'correct_score':
                case 'correct_score_first_half':
                case 'correct_score_second_half':
                    return 'auto auto auto'; // 1-0, 2-1, 2-0
                case 'asian_handicap':
                case 'asian_handicap_first_half':
                case 'asian_handicap_first_quarter':
                case 'asian_handicap_sets':
                case 'asian_handicap_games':
                case 'first_set':
                case 'second_set':
                case 'first_half_winner':
                case 'first_quarter_winner':
                case 'second_half_winner':
                    return 'auto auto'; // Home, Away
                case 'over_under':
                case 'over_under_first_half':
                case 'over_under_first_quarter':
                case 'over_under_first_set':
                case 'games_over_under':
                case 'corners_over_under':
                    return 'auto auto'; // Over, Under
                case 'set_betting':
                    return 'auto auto auto'; // 2-0, 2-1, 0-2
                case 'handicap_result':
                    return 'auto auto auto'; // Home, Draw, Away
                case 'highest_scoring_half':
                case 'highest_scoring_quarter':
                    return 'auto auto auto'; // 1st, 2nd, 3rd
                case 'double_chance':
                case 'double_chance_first_half':
                case 'double_chance_second_half':
                    return 'auto auto auto'; // 1X, X2, 12
                case 'win_both_halves':
                    return 'auto auto'; // Yes, No
                case 'both_teams_score_first_half':
                case 'both_teams_score_second_half':
                    return 'auto auto'; // Yes, No
                case 'results_both_teams_score':
                    return 'auto auto auto'; // 1/Yes, X/Yes, 2/Yes
                case 'result_total_goals':
                    return 'auto auto auto'; // 1/Over, X/Over, 2/Over
                case 'corners_1x2':
                    return 'auto auto auto'; // Home, Draw, Away
                case 'ht_ft_double':
                    return 'auto auto auto'; // 1/1, 1/X, 1/2
                case 'first_half_3way_result':
                    return 'auto auto auto'; // 1, X, 2
                default:
                    return 'auto auto auto'; // Default to 1, X, 2
            }
        }

        function formatMatchStatus(status) {
            if (!status) return '';
            
            const statusMap = {
                'live': 'üî¥ LIVE',
                'finished': '‚úÖ FINISHED',
                'scheduled': '‚è∞ SCHEDULED',
                'postponed': '‚è∏Ô∏è POSTPONED',
                'cancelled': '‚ùå CANCELLED',
                'suspended': '‚è∏Ô∏è SUSPENDED'
            };
            
            return statusMap[status.toLowerCase()] || status;
        }

        function generateOddsButtons(event, market) {
            // This function should generate odds buttons based on the market
            // For now, return a placeholder
            return '<div class="odds-placeholder">Odds loading...</div>';
        }
    </script>

    <!-- Authentication handled by /login page -->
    

</body>
</html>

