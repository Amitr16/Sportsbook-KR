===================================================================================
ACTUAL WORKER CODE FOR EXPERT REVIEW
===================================================================================

FILE: src/prematch_odds_service.py
-----------------------------------

MAIN FETCH LOOP (Lines 607-626):
```python
def _fetch_loop(self):
    """Main fetch loop that runs every 30 seconds"""
    logger.info("üîÑ Starting pre-match odds fetch loop")
    
    while self.running:
        try:
            self._fetch_all_sports_odds()
            
            # Wait 5 minutes before next fetch cycle
            # Each cycle takes ~18 minutes (18 sports √ó 60 seconds), so 5 min is reasonable
            logger.info("‚è≥ Waiting 5 minutes before next fetch cycle...")
            time.sleep(300)  # ‚Üê 5 minute sleep (no DB connection held here)
            
        except Exception as e:
            logger.error(f"‚ùå Error in fetch loop: {e}")
            self.stats['last_error'] = str(e)
            
            # Wait 30 seconds before retry
            logger.info("‚è≥ Waiting 30 seconds before retry...")
            time.sleep(30)
```

FETCH ALL SPORTS (Lines 564-596):
```python
def _fetch_all_sports_odds(self):
    """Fetch odds for all sports"""
    logger.info("üöÄ Starting pre-match odds fetch for all sports")
    
    for sport_name in self.sports_config.keys():
        try:
            # Fetch and save odds for this sport
            success = self._fetch_single_sport_odds(sport_name)  # ‚Üê Does this hold DB conn?
            
            if success:
                successful_sports.append(sport_name)
            else:
                failed_sports.append(sport_name)
            
            # GoalServe rate limit: 60 seconds between ANY requests (per IP/API key)
            # Wait 60 seconds between each sport to respect their global rate limits
            logger.info(f"‚è≥ Waiting 60 seconds before next sport (GoalServe global rate limit)")
            time.sleep(60)  # ‚Üê 60 second sleep between sports
            
        except Exception as e:
            logger.error(f"‚ùå Error processing {sport_name}: {e}")
            failed_sports.append(sport_name)
```

FETCH SINGLE SPORT (Lines 519-563):
```python
def _fetch_single_sport_odds(self, sport_name: str) -> bool:
    """Fetch odds for a single sport"""
    try:
        # 1. Build URL (no DB)
        url = self._build_odds_url(sport_name, date_start, date_end)
        
        # 2. Fetch from GoalServe API (HTTP call - no DB)
        odds_data = self._fetch_odds(sport_name, url)  # ‚Üê HTTP call with retries
        
        if not odds_data:
            return False
        
        # 3. Save to database
        return self._save_sport_odds(sport_name, odds_data)  # ‚Üê DB write
```

SAVE SPORT ODDS (Lines 475-518):
```python
def _save_sport_odds(self, sport_name: str, odds_data: dict) -> bool:
    """Save odds data to database"""
    try:
        from src.db_compat import connection_ctx
        
        with connection_ctx() as conn:  # ‚Üê Connection acquired here
            with conn.cursor() as cursor:
                # Prepare data
                events = odds_data.get('data', {}).get('fixtures', [])
                
                # Insert/update odds (batch operation)
                for event in events:
                    # Insert or update event in DB
                    cursor.execute("INSERT INTO prematch_odds ...")
                    # ... multiple inserts/updates ...
                
                conn.commit()
        # ‚Üê Connection released here
        
        return True
        
    except Exception as e:
        logger.error(f"‚ùå Error saving {sport_name} odds: {e}")
        return False
```

FETCH WITH RETRY (Lines 231-284):
```python
def _fetch_odds(self, sport_name: str, url: str) -> Optional[Dict]:
    """Fetch odds with retry logic for rate limit errors"""
    max_retries = 3
    base_delay = 10
    
    for attempt in range(max_retries):
        try:
            if attempt > 0:
                delay = base_delay * (2 ** (attempt - 1))  # Exponential backoff
                logger.info(f"üîÑ Retry attempt {attempt + 1}/{max_retries} after {delay}s delay")
                time.sleep(delay)  # ‚Üê Sleep during retry (no DB held)
            
            response = self.session.get(url, timeout=self.timeout)  # ‚Üê HTTP call (no DB)
            
            if response.status_code == 200:
                # Parse and return
                return robust_goalserve_parse(response.text)
            elif response.status_code == 429:
                logger.warning(f"‚ö†Ô∏è Rate limit hit for {sport_name}")
                # Will retry with backoff
            else:
                logger.error(f"‚ùå HTTP {response.status_code}")
                return None
```

QUESTION FOR EXPERT:
1. Are connections properly released before all `time.sleep()` calls? ‚úÖ Appears so
2. Are there any hidden connection leaks in error paths?
3. Should batch inserts be broken into smaller transactions?
4. How long should a DB transaction stay open during batch inserts?

===================================================================================

FILE: src/bet_settlement_service.py
-----------------------------------

MAIN SETTLEMENT LOOP (Lines 196-245):
```python
def _settlement_loop(self):
    """Main settlement loop that automatically settles bets when matches end"""
    logger.info("üîÑ Settlement service loop started")
    
    while self.running:
        try:
            self.last_check_time = datetime.utcnow()
            self.total_checks += 1
            
            # Check if we can access the database - NO CONNECTION HELD DURING SLEEP
            try:
                if self.app:
                    with self.app.app_context():
                        # Use connection_ctx() to avoid holding connections during sleep
                        from src.db_compat import connection_ctx
                        with connection_ctx() as conn:
                            conn.autocommit = True
                            with conn.cursor() as cur:
                                cur.execute("SELECT COUNT(*) FROM bets WHERE status = %s", ('pending',))
                                pending_count = cur.fetchone()['count']
                        # ‚Üê Connection released here
                        logger.info(f"üìã Found {pending_count} pending bets in database")
            except Exception as db_error:
                logger.error(f"‚ùå Database access error: {db_error}")
            
            self.check_for_completed_matches()  # ‚Üê Main work happens here
            
        except Exception as e:
            logger.error(f"‚ùå CRITICAL ERROR in automatic settlement loop: {e}")
        
        logger.info(f"‚è∞ Sleeping for {self.check_interval} seconds...")
        time.sleep(self.check_interval)  # ‚Üê 300 seconds (5 minutes), no DB held ‚úÖ
```

CHECK FOR COMPLETED MATCHES (Lines 246-350):
```python
def check_for_completed_matches(self):
    """Check for matches that need settlement"""
    try:
        # 1. Query pending bets (quick query)
        with self.app.app_context():
            from src.db_compat import connection_ctx
            with connection_ctx() as conn:
                with conn.cursor() as cur:
                    cur.execute("SELECT * FROM bets WHERE status = 'pending'")
                    pending_bets = cur.fetchall()
            # ‚Üê Connection released
        
        if not pending_bets:
            return
        
        # 2. For each sport, fetch completed matches from GoalServe
        sports_to_check = self._get_sports_to_check(pending_bets)
        
        for sport in sports_to_check:
            # HTTP call to GoalServe (no DB held)
            completed_matches = self._fetch_completed_matches(sport)
            
            # Match bets to events and settle
            for match in completed_matches:
                matching_bets = self._find_matching_bets(pending_bets, match)
                
                if matching_bets:
                    # Settle these bets (DB transaction)
                    self._auto_settle_bets_for_match(match, matching_bets)
                    
    except Exception as e:
        logger.error(f"Error checking completed matches: {e}")
```

AUTO SETTLE BETS FOR MATCH (Lines 771-950):
```python
def _auto_settle_bets_for_match(self, match_event, bets):
    """Automatically settle bets for a completed match"""
    try:
        # Extract scores (no DB)
        home_score = get_team_score(match_event, 'home')
        away_score = get_team_score(match_event, 'away')
        
        # For each bet, determine outcome and settle
        for bet in bets:
            # Determine if bet won
            bet_won = self._determine_bet_outcome(bet, home_score, away_score)
            
            # Update bet status in DB
            with self.app.app_context():
                from src.db_compat import connection_ctx
                with connection_ctx() as conn:
                    with conn.cursor() as cur:
                        # Update bet
                        cur.execute("UPDATE bets SET status=..., ... WHERE id=...", ...)
                        
                        # Update user balance if won
                        if bet_won:
                            cur.execute("UPDATE users SET balance=balance+... WHERE id=...", ...)
                            
                            # Web3 credit (wrapped in try-except, no DB held)
                            try:
                                from src.services.web3_sync_service import sync_web3_credit
                                sync_web3_credit(bet.user_id, payout, "bet_win")
                            except:
                                pass
                        
                        conn.commit()
                # ‚Üê Connection released
                
    except Exception as e:
        logger.error(f"Error settling bets: {e}")
```

QUESTIONS FOR EXPERT:
1. Is `conn.autocommit = True` safe in settlement loop? Should we use explicit transactions?
2. Are connections properly released before HTTP calls to GoalServe?
3. Should we batch settlements instead of one transaction per bet?
4. Is the 5-minute sleep interval too long/short?
5. Any connection leak risks in the error paths?

===================================================================================

